<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Basic Principles" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Basic Principles" name="description"/>
            <meta content="en" name="language"/>
            <title>Basic Principles</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h1.6">1.6    The Core: V8 Engine<a class="indexanchor" id="i01_74"/></h2>
        <p class="standard">For you, as a developer, to assess whether a technology can be used in a project, you should be sufficiently familiar with the characteristics of that technology. The sections that follow now dive deep into the internal details of Node.js to show you the components that make up the platform and how you can use them to the advantage of an application.</p>
        <p class="standard"><a id="p42"/>The central and thus most important component of the Node.js platform is the V8 JavaScript engine developed by Google (for more information, visit the V8 Project page at <span class="url"><a href="https://code.google.com/p/v8/">https://code.google.com/p/v8/</a></span>). The JavaScript engine is responsible for interpreting and executing the JavaScript source code. There isn’t just one engine for JavaScript; instead, the different browser manufacturers use their own implementations. One of the problems with JavaScript is that each engine behaves slightly differently. Standardization to ECMAScript attempts to find a reliable common denominator so that you, as a JavaScript application developer, have less uncertainty to worry about. The competition among JavaScript engines resulted in a number of optimized engines<a class="indexanchor" id="i01_75"/><a class="indexanchor" id="i01_76"/>, all with the goal of interpreting JavaScript code as quickly as possible. Over time, several engines have established themselves on the market: Mozilla’s JaegerMonkey<a class="indexanchor" id="i01_77"/>, Apple’s Nitro<a class="indexanchor" id="i01_78"/>, and Google’s V8 engine, among others. Microsoft meanwhile uses the same technical basis as Chrome for its Edge browser, so it also uses the V8 engine.</p>
        <p class="standard">Node.js uses Google’s V8 engine. This engine has been developed by Google since 2006, mainly in Denmark, in collaboration with Aarhus University. The engine’s primary area of use is Google’s Chrome<a class="indexanchor" id="i01_79"/> browser, where it’s responsible for interpreting and executing JavaScript code. The goal of developing a new JavaScript engine was to significantly improve the performance of interpreting JavaScript. The engine now fully implements the ECMAScript standard ECMA-262 in the fifth version and large parts of the sixth version. The V8 engine itself is written in C++, runs on various platforms, and is available under the Berkeley Source Distribution (BSD) license<a class="indexanchor" id="i01_80"/> as open-source software for any developer to use and improve. For example, you can integrate the engine into any C++ application.</p>
        <p class="standard">As usual in JavaScript, the source code isn’t compiled before execution; instead, the files containing the source code are read directly when the application is launched. Launching the application starts a new Node.js process. This is where the first optimization by the V8 engine takes place. The source code isn’t directly interpreted, but is first translated into machine code, which is then executed. This technology is referred to as just-in-time (JIT) compilation<a class="indexanchor" id="i01_81"/> and is used to increase the execution speed of the JavaScript application. The actual application is then executed on the basis of the compiled machine code. The V8 engine makes further optimizations in addition to JIT compilation. Among other things, these include improved garbage collection<a class="indexanchor" id="i01_82"/> and an improvement in the context of accessing object properties. For all the optimizations that the JavaScript engine makes, you should keep in mind that the source code is read at process startup, so the changes to the files have no effect on the running application. For your changes to take effect, you must exit and restart your application so that the customized source code files are read again.</p>
        
            <h3 class="t3" id="h1.6.1">1.6.1    Memory Model<a class="indexanchor" id="i01_83"/></h3>
            <p class="standard">The goal of developing the V8 engine was to achieve the highest possible speed in the execution of JavaScript source code. For this reason, the memory model has also been <a id="p43"/>optimized. Tagged pointers, which are references in memory that are marked as such in a special way, are used in the V8 engine. All objects are 4-byte-aligned, which means that 2 bits are available to identify pointers. A pointer always ends on 01 in the memory model of the V8 engine, whereas a normal integer value ends on 0. This measure allows integer values to be distinguished very quickly from memory references, which provides an extremely significant performance advantage<a class="indexanchor" id="i01_84"/>. The object representations of the V8 engine in memory each consist of three data words. The first data word consists of a reference to the hidden class of the object, which you’ll learn more about in later sections. The second data word is a pointer to the attributes, that is, the properties of the object. Finally, the third data word refers to the elements of the object. These are the properties with a numeric key. This structure supports the JavaScript engine in its work and is optimized in such a way that elements in the memory can be accessed very fast so that little wait time arises from searching objects.</p>
        
        
            <h3 class="t3" id="h1.6.2">1.6.2    Accessing Properties<a class="indexanchor" id="i01_85"/></h3>
            <p class="standard">As you probably know, JavaScript doesn’t know classes; the object model of JavaScript is based on prototypes. In class-based languages such as Java or PHP, classes<a class="indexanchor" id="i01_86"/> represent the blueprint of objects. These classes can’t be changed at runtime. Prototypes in JavaScript, on the other hand, are dynamic, which means that properties and methods can be added and removed at runtime. As with all other languages that implement the object-oriented programming paradigm<a class="indexanchor" id="i01_87"/>, objects are represented by their properties and methods, where properties represent the state of an object, and methods are used to interact with the object. In an application, you usually access the properties of the various objects very frequently. In addition, methods in JavaScript are also properties of objects that are stored with a function. In JavaScript, you work almost exclusively with properties and methods, so access to them must be very fast.</p>
            <div class="box box_standard">
                <h6 class="boxheading">Prototypes<a class="indexanchor" id="i01_88"/> in JavaScript</h6>
                <p class="standard first last">JavaScript differs from languages such as C, Java, or PHP in that it doesn’t take a class-based approach but instead is based on prototypes, such as the Self language. In JavaScript, every object normally has a <samp class="listingcharacter listingcharacter">prototype</samp> property and thus a prototype. In JavaScript, as in other languages, you can create objects. For this purpose, however, you don’t use classes in conjunction with the <samp class="listingcharacter listingcharacter">new</samp> operator. Instead, you can create new objects in several different ways. Among other things, you can use constructor functions<a class="indexanchor" id="i01_89"/> or the <samp class="listingcharacter listingcharacter">Object.create</samp> method. These methods have in common that you create an object and assign the prototype. The prototype is an object from which another object inherits its properties. Another feature of prototypes is that they can be modified at application runtime, allowing you to add new properties and methods. By using prototypes, you can build an inheritance hierarchy in JavaScript.</p>
            </div>
            <p class="standard"><a id="p44"/>Normally, accessing properties in a JavaScript engine is done through a directory in the memory. So, if you access a property, this directory<a class="indexanchor" id="i01_90"/> is searched for the memory section of the respective property, and then the value can be accessed. Now imagine a large application that maps its business logic in JavaScript on the client side, and in which a large number of objects are held in parallel in the memory, constantly communicating with each other. This method of accessing properties would quickly turn into a problem. The developers of the V8 engine have recognized this vulnerability and developed a solution for it—the hidden classes<a class="indexanchor" id="i01_91"/>. The real problem with JavaScript is that the structure of objects is only known at runtime and not already during the compilation process because such a process doesn’t exist with JavaScript. This is further complicated by the fact that there isn’t just one prototype in the structure of objects, but they can rather exist in a chain. In classical languages, the object structure doesn’t change at application runtime; the properties of objects are always located in the same place, which significantly speeds up accessing them.</p>
            <p class="standard">A hidden class is nothing more than a description in which the individual properties of an object can be found in the memory. For this purpose, a hidden class is assigned to each object. This contains the offset to the memory section<a class="indexanchor" id="i01_92"/> within the object where the respective property is stored. As soon as you access a property of an object, a hidden class is created for that property and reused for each subsequent access. So for an object, there is potentially a separate hidden class for each property.</p>
            <p class="standard">In <span class="crossreference "><a href="01_006.html#l1.1">Listing 1.1</a></span>, you can see an example that illustrates how hidden classes work.</p>
            <div class="listing " id="l1.1"><pre><span class="rot">class Person</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="schwarz">constructor(</span><span class="schwarz">firstname</span><span class="schwarz">,</span><span class="schwarz"> lastname</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">this</span><span class="schwarz">.</span><span class="schwarz">firstname </span><span class="dunkelblau">=</span><span class="schwarz"> firstname</span><span class="schwarz">;</span><span class="schwarz"><br/></span>    <span class="rot">this</span><span class="schwarz">.</span><span class="schwarz">lastname </span><span class="dunkelblau">=</span><span class="schwarz"> lastname</span><span class="schwarz">;</span><span class="schwarz"><br/></span>  <span class="schwarz">}</span><span class="schwarz"><br/></span><span class="schwarz">}</span><span class="schwarz"><br/></span><span class="rot">const</span><span class="schwarz"> johnDoe </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">new </span><span class="schwarz">Person(</span><span class="hellblau">"John"</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">"Doe"</span><span class="schwarz">);</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 1.1</b>    
            Accessing Properties in a Class</p>
            <p class="standard">In the example, you create a new constructor function for the group of <samp class="listingcharacter listingcharacter">person</samp> objects. This constructor has two parameters—the first name and the last name of the person. These two values are to be stored in the <samp class="listingcharacter listingcharacter">firstname</samp> and <samp class="listingcharacter listingcharacter">lastname</samp> properties of the object, respectively. When a new object is created with this constructor using the <samp class="listingcharacter listingcharacter">new</samp> operator, an initial hidden class, class 0, is created first. This doesn’t yet contain any pointers to properties. If the first assignment is made, that is, the first name is set, a new hidden class, class 1, is created based on class 0. This now contains a reference to the memory section of the <samp class="listingcharacter listingcharacter">firstname</samp> property, relative to the beginning of the object’s namespace<a class="indexanchor" id="i01_93"/>. In addition, a class transition is added to class 0, which states that class 1 should be used instead of class 0 if the <samp class="listingcharacter listingcharacter">firstname</samp> property is added. The same process takes place when the second assignment is performed for the last name. Another hidden class, class 2, is <a id="p45"/>created based on class 1, which then contains the offset for both the <samp class="listingcharacter listingcharacter">firstname</samp> and <samp class="listingcharacter listingcharacter">lastname</samp> properties and inserts a transition indicating that class 2 should be used when the <samp class="listingcharacter listingcharacter">lastname</samp> property is used. If properties are added away from the constructor,<a class="indexanchor" id="i01_94"/> and this is done in a different order, new hidden classes are created in each case. <span class="crossreference "><a href="01_006.html#f1.3">Figure 1.3</a></span> clarifies this process.</p>
            <p class="standard">When the properties of an object are accessed for the first time, the use of hidden classes doesn’t yet result in a speed advantage. However, all subsequent accesses to the property of the object then happen many times faster, because the engine can directly use the hidden class of the object and this contains the reference to the memory section of the property.</p>
            <div class="imagebox figure-type"><a href="img-f1.3.html" id="f1.3"><img alt="Hidden Classes in the V8 Engine (https://github.com/v8/v8/wiki/Design%20Elements#fast-property-access)" id="img-f1.3" src="bilderklein/klein01_003.png"/></a></div>
            <p class="caption "><b>Figure 1.3</b>    
            Hidden Classes in the V8 Engine (<span class="url"><a href="https://github.com/v8/v8/wiki/Design%20Elements#fast-property-access">https://github.com/v8/v8/wiki/Design%20Elements#fast-property-access</a></span>)</p>
        
        
            <h3 class="t3" id="h1.6.3">1.6.3    Machine Code Generation<a class="indexanchor" id="i01_95"/><a class="indexanchor" id="i01_96"/></h3>
            <p class="standard">As you already know, the V8 engine doesn’t directly interpret the JavaScript application source code, but performs a JIT compilation into native machine code to increase execution speed. No optimizations are made to the source code during this compilation. The source code written by the developer is thus converted one to one. In addition to this JIT compiler<a class="indexanchor" id="i01_97"/>, the V8 engine has another compiler<a class="indexanchor" id="i01_98"/> that is capable of optimizing the machine code. To decide which code fragments to optimize, the engine maintains internal statistics about the number of function calls and how long each function is executed. Based on this data, the decision is made regarding whether the machine code<a class="indexanchor" id="i01_99"/> of a function requires optimizing.</p>
            <p class="standard">Now you’re probably wondering why the entire source code of the application isn’t compiled with the second, much better compiler. There is a very simple reason for this: <a id="p46"/>a compiler that doesn’t perform optimizations is much faster. Because the source code is compiled JIT, this process is very time critical because any wait times caused by a compilation process<a class="indexanchor" id="i01_100"/> that takes too long can have a direct impact on the user. Therefore, only code sections that justify this additional effort are optimized. This machine code optimization has a particularly positive effect on larger and longer-running applications and on those in which functions are called more often than just once.</p>
            <p class="standard">Another optimization the V8 engine performs is related to the hidden classes and internal caching<a class="indexanchor" id="i01_101"/><a class="indexanchor" id="i01_102"/><a class="indexanchor" id="i01_103"/> already described earlier. After the application is launched and the machine code is generated, the V8 engine searches for the associated hidden class each time a property is accessed. As a further optimization, the engine assumes that the objects used at this point will have the same hidden class in the future, so it modifies the machine code accordingly. The next time the code section is traversed, the property can be accessed directly with no need to search for the associated hidden class first. If the object used doesn’t have the same hidden class, the engine detects this, removes the previously generated machine code, and replaces it with the corrected version. There is a critical problem with this approach: Imagine you have a code section where two different objects with different hidden classes are always used in alternation. Then the optimization with the prediction of the hidden class would never take effect at the next execution. In this case, various code fragments are used, which can’t be used to find the memory section of a property as quickly as with just one hidden class, but the code in this case is many times faster than without the optimization because it’s usually possible to select from a very small set of hidden classes. The generation of machine code and the hidden classes in combination with the caching mechanisms creates possibilities that are familiar from class-based languages.</p>
        
        
            <h3 class="t3" id="h1.6.4">1.6.4    Garbage Collection<a class="indexanchor" id="i01_104"/></h3>
            <p class="standard">The optimizations described so far mainly affect the speed of an application. Another very important feature is the garbage collector of the V8 engine. <span class="italic">Garbage collection</span> refers to the process of clearing up the application’s memory area<a class="indexanchor" id="i01_105"/> in the main memory. Elements that are no longer used are removed from memory so that the space freed up becomes available to the application again.</p>
            <p class="standard">If you’re wondering why you need a garbage collector in JavaScript, the answer is quite simple: Originally, JavaScript was intended for small tasks on web pages. These web pages, and thus the JavaScript on this page, had a fairly short lifetime until the page was reloaded, completely emptying the memory containing the JavaScript objects. The more JavaScript is executed on a page and the more complex the tasks to be performed become, the greater the risk that memory will be filled with objects that are no longer needed. If you now assume you have an application in Node.js that has to run for several days, weeks, or even months without restarting the process, the problem becomes clear. The V8 engine’s garbage collector comprises a number of features that allow it to <a id="p47"/>perform its tasks very quickly and efficiently. Basically, when the garbage collector is running, the engine stops the execution of the application completely and resumes it as soon as the run is finished. These application pauses are in the single-digit millisecond range so that the user normally doesn’t feel any negative effects due to the garbage collector. To keep the interruption by the garbage collector as short as possible, the complete memory isn’t cleaned up, but only parts of it. In addition, the V8 engine knows at all times where in the memory which objects and pointers are located.</p>
            <p class="standard">The V8 engine divides the available memory into two areas—one area for storing objects and another area to keep the information about the hidden classes and the executable machine code<a class="indexanchor" id="i01_106"/>. The process of garbage collection is relatively simple. When an application is executed, objects and pointers are created in the short-lived area of the V8 engine’s memory. If this memory area is full, it’s cleaned up. Objects that are no longer used are deleted, and objects that are still needed are moved to the long-lived area. During this shift, the object itself is shifted, and the pointers to the object’s memory location are corrected. The partitioning of memory areas makes different types of garbage collection necessary.</p>
            <p class="standard">The fastest variant is represented by the scavenge collector<a class="indexanchor" id="i01_107"/>, which is very fast and efficient and deals only with the short-lived area<a class="indexanchor" id="i01_108"/><a class="indexanchor" id="i01_109"/>. Two different garbage collection algorithms exist for the long-lived memory section<a class="indexanchor" id="i01_110"/><a class="indexanchor" id="i01_111"/>, both based on mark-and-sweep<a class="indexanchor" id="i01_112"/>. The entire memory is searched, and elements that are no longer needed are marked and later deleted. The real problem with this algorithm is that it creates gaps in the memory, which causes problems over a longer runtime of an application. For this reason, a second algorithm exists that also searches the elements of the memory for those that are no longer needed, marks them, and deletes them.</p>
            <p class="standard">The most important difference between the two is that the second algorithm defragments the memory<a class="indexanchor" id="i01_113"/><a class="indexanchor" id="i01_114"/>; that is, it rearranges the remaining objects in the memory so that afterwards, the memory has as few gaps as possible. This defragmentation can only happen because V8 knows all objects and pointers. For all its benefits, the garbage collection process also has a drawback: it takes time. The fastest the scavenge collection can run is about 2 ms. This is followed by the mark-and-sweep process without optimizations at 50 ms and finally the mark-and-sweep with defragmentation with an average of 100 ms.</p>
            <p class="standard">In the following sections, you’ll learn more about the other elements used in the Node.js platform besides the V8 engine.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>