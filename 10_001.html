<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="REST Server" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - REST Server" name="description"/>
            <meta content="en" name="language"/>
            <title>REST Server</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main"><h1 class="t1" id="h10">10    <a id="p295"/>REST Server</h1><p class="introductorynote indent_chapter_double">It is the mind that builds the body.<br/>—Friedrich Schiller</p><p class="standard">In<a class="indexanchor" id="i10_00"/> the previous chapters, you’ve extended your web application step by step from a simple web server to using template engines and the integration of various databases. However, it often happens during development that such a setup isn’t suitable. Especially in the case of single-page applications, you don’t need a template engine because the result of an HTTP request is returned to the client as a JavaScript Object Notation (JSON) structure<a class="indexanchor" id="i10_01"/>. Output in HTML documents is also not very helpful for the communication between server systems. Instead, other requirements are placed on the web server here, such as the ability to handle different HTTP request headers, or to support authentication via JSON web tokens<a class="indexanchor" id="i10_02"/> (JWTs).</p><p class="standard">In this chapter, you’ll learn how you can restructure your existing application so that you can both consume it with a frontend single-page application based on Angular<a class="indexanchor" id="i10_03"/>, React<a class="indexanchor" id="i10_04"/>, or Vue<a class="indexanchor" id="i10_05"/>, for example, and retrieve data from that application through another web server.</p><p class="standard">The chapter is based on the movie database you developed in the previous chapters; SQLite is used as the database for data management. In the following sections, you'll restructure the application to respond with JSON data instead of rendered HTML views.</p>
        <h2 class="t2" id="h10.1">10.1    Introduction to REST and Usage in Web Applications</h2>
        <p class="standard"><span class="italic">Representational State Transfer (REST)</span> was developed in the context of Roy Fielding’s doctoral thesis<a class="indexanchor" id="i10_06"/>. The corresponding excerpt from the thesis can be found at <span class="url"><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></span>. REST represents an architectural paradigm frequently used in web applications. One of the most important features of REST is that it relies heavily on the elements of HTTP, using the URL path to map resources and describing how they are accessed through the various HTTP methods. The main features of a REST interface are as follows:</p>
        <ul>
            <li>
                <p class="standard first-item last-item"><span class="bold"><a id="p296"/>Statelessness</span><a class="indexanchor" id="i10_07"/><br/>Each request to the service should contain all the required information, so the server doesn’t need to keep any state information.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Resources</span><a class="indexanchor" id="i10_08"/><br/>Each resource is accessible via a unique URI. For example, you can retrieve the data record of a movie with ID 1 via the URL <span class="italic">http://localhost:8080/movie/1</span>.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Hypermedia as the Engine of Application State (HATEOAS)</span><a class="indexanchor" id="i10_09"/><br/>This represents the central component of a REST architecture. Various links tell the consumer of the interface what state changes are possible with the requested resource. This is also one of the major differences from other approaches such as Simple Object Access Protocol (SOAP), where there is only a fixed interface and not a dynamic one that depends on the state of the resource as in REST.</p>
            </li>
        </ul>
        <p class="standard">In most applications, the first two characteristics, that is, statelessness and resource mapping, are still implemented quite well. However, the third feature, HATEOAS, is often neglected so that most REST interfaces aren’t true REST at all, but rather stateless resource mapping. A clean implementation of the HATEOAS principle in the frontend and backend requires some work and conception, but the interfaces are more expressive.</p>
    </div><p class="signatur"/>
                    </body>
                </html>