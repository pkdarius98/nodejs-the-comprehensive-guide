<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Performance" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Performance" name="description"/>
            <meta content="en" name="language"/>
            <title>Performance</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main"><h1 class="t1" id="h26">26    <a id="p733"/>Performance</h1><p class="introductorynote indent_chapter_double">Most people don’t even know what kind of pace they could have if they just rubbed the sleep out of their eyes for once.<br/>—Christian Morgenstern</p><p class="standard">As<a class="indexanchor" id="i26_00"/> a platform, Node.js claims to be lightweight<a class="indexanchor" id="i26_01"/> and flexible<a class="indexanchor" id="i26_02"/>. The individual components of the platform have proven themselves in practical use over many years and have shown that it’s possible to implement even business-critical applications with server-side JavaScript. Throughout this book, you’ve already learned about some aspects of the Node.js architecture. In this chapter, we’ll take a look at Node.js and the applications you build on top of it from a performance perspective. For a Node.js application, performance generally refers to the question as to how fast<a class="indexanchor" id="i26_03"/> it can perform a given task. This can involve solving a specific problem from the command line on the local system as well as answering a request from a browser to a web interface as quickly as possible.</p><p class="standard">The use of resources has a decisive influence on the performance of your application. In the context of Node.js, you should always keep an eye on three types of resources: the processor, memory, and, if you’re on the web, the network. In this chapter, you’ll learn some best practices for performant applications as well as analysis tools<a class="indexanchor" id="i26_04"/>.</p>
        <h2 class="t2" id="h26.1">26.1    <a class="indexanchor" id="i26_05"/>You Aren’t Gonna Need It</h2>
        <p class="standard">In feature development, the “you aren’t gonna need it” (YAGNI) principle stands for functionality that developers and product managers envision for future use, but which isn’t needed at the current time and possibly even in the future. Of course, this isn’t to say that you don’t need good performance, but you should be aware that performance also costs money. We’re not talking about general good programming and avoiding bottlenecks<a class="indexanchor" id="i26_06"/> in your application, but rather about micro-optimizations, which can cost more than they bring if you do them in the wrong place. For this reason, you should ensure a good basic performance in your application, but you should only implement the real optimizations when you know where performance problems will occur in your application. To do this, you need to know the volume of data<a class="indexanchor" id="i26_07"/> your application needs to handle, and you need to know the critical workflows. Then you can start measuring the actual situation and analyzing the results. Based on these results, you can make optimizations and then measure again whether the desired results have been achieved.</p>
    </div><p class="signatur"/>
                    </body>
                </html>