<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Testing" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Testing" name="description"/>
            <meta content="en" name="language"/>
            <title>Testing</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h23.3">23.3    Jasmine<a class="indexanchor" id="i23_38"/></h2>
        <p class="standard">Numerous unit test frameworks are available for client-side JavaScript. The test frameworks can be roughly divided into two categories: (1) frameworks tightly bound to a JavaScript library or framework, and (2) independent testing frameworks that allow you to test applications independently of the library you use. <span class="italic">Jasmine</span> represents this second category. The good news is that Jasmine is also available natively for Node.js, so you can use the framework directly without wrapper libraries.</p>
        <p class="standard">Jasmine isn’t a typical unit test framework, instead it follows the approach of <span class="italic">behavior-driven development</span> (BDD)<a class="indexanchor" id="i23_39"/>. The core idea of BDD is that not only developers can formulate tests but also other people who aren’t directly involved in the development, and that the tests themselves as well as their output are much more readable. Unlike unit tests, with BDD, you test not only atomic units in the source code but also the behavior of specific components of your application. However, Jasmine can also be used for classic unit testing. <span class="crossreference "><a href="23_003.html#l23.12">Listing 23.12</a></span> shows a unit test with Jasmine that resembles the test from <span class="crossreference "><a href="23_002.html#l23.2">Listing 23.2</a></span>.</p>
        <div class="listing " id="l23.12"><pre><span class="schwarz">describe(</span><span class="hellblau">'Buffer'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="schwarz">it(</span><span class="hellblau">'should return the String representation if toString is called'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">const</span><span class="schwarz"> myBuffer </span><span class="dunkelblau">=</span><span class="schwarz"> Buffer</span><span class="schwarz">.from(</span><span class="hellblau">'Hello World'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><br/>    <span class="rot">const</span><span class="schwarz"> result </span><span class="dunkelblau">=</span><span class="schwarz"> myBuffer</span><span class="schwarz">.toString();</span><span class="schwarz"><br/></span><br/>    <span class="schwarz">expect(</span><span class="schwarz">result</span><span class="schwarz">).toEqual(</span><span class="hellblau">'Hello World'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
        <p class="caption "><b>Listing 23.12</b>    
            Test in Jasmine (buffer.spec.mjs)</p>
        <p class="standard"><a id="p664"/>The structure of a Jasmine test is fundamentally different from a test of the <samp class="listingcharacter listingcharacter">assert</samp> module. Jasmine allows you to group your tests logically. For this purpose, you can use the <samp class="listingcharacter listingcharacter">describe</samp> method<a class="indexanchor" id="i23_40"/><a class="indexanchor" id="i23_41"/>. The first argument this method accepts is a character string describing what will be tested in the tests that follow. The second argument is a function containing the actual tests.</p>
        <p class="standard">The test functions are encapsulated by a call of the <samp class="listingcharacter listingcharacter">it</samp> method<a class="indexanchor" id="i23_42"/> of Jasmine. This method is named <samp class="listingcharacter listingcharacter">it</samp> because it symbolizes that the test will form coherent sentences such as <samp class="listingcharacter listingcharacter">"It should return the String representation if toString is called."</samp>. Again, the first argument is a brief description of what will be tested. In the second argument, you formulate the test itself within a function. Again, you proceed according to the AAA scheme. The first two steps are identical to the ones in the <samp class="listingcharacter listingcharacter">assert</samp> module. You create a <samp class="listingcharacter listingcharacter">buffer</samp> object, call the <samp class="listingcharacter listingcharacter">toString</samp> method, and save the result in a variable. For the assert step, Jasmine also provides a set of assertion methods<a class="indexanchor" id="i23_43"/>, but you can’t call them directly, only in conjunction with the <samp class="listingcharacter listingcharacter">expect</samp> method. This method accepts a value as an argument and returns an object on which you can then run the various assertion methods.</p>
        
            <h3 class="t3" id="h23.3.1">23.3.1    Installation<a class="indexanchor" id="i23_44"/></h3>
            <p class="standard">To run the test, you must first install Jasmine. It’s available as a Node Package Manager (npm) package and can be installed locally as well as globally. <span class="crossreference "><a href="23_003.html#l23.13">Listing 23.13</a></span> shows the command line for installation. As with other packages, you should install Jasmine locally.</p>
            <div class="listing " id="l23.13"><pre>npm install -D jasmine </pre></div>
            <p class="caption "><b>Listing 23.13</b>    
            Installing Jasmine</p>
            <div class="box box_standard">
                <h6 class="boxheading">Jasmine and ECMAScript Modules</h6>
                <p class="standard first last">When using Jasmine, note that currently the Jasmine loader still has problems with ECMAScript modules. If you set the <samp class="listingcharacter listingcharacter">type</samp> property in your <span class="italic">package.json</span> file to the <samp class="listingcharacter listingcharacter">module</samp> value to support native ECMAScript modules, Jasmine throws an exception during test execution. To solve this problem, you mustn’t use the property in <span class="italic">package.json</span> and have your test files end with <span class="italic">.mjs</span> to support ECMAScript modules in your test code.</p>
            </div>
        
        
            <h3 class="t3" id="h23.3.2">23.3.2    Configuration<a class="indexanchor" id="i23_45"/></h3>
            <p class="standard">Once you’ve installed Jasmine, you still need to initialize your project. For this purpose, the <samp class="listingcharacter listingcharacter">jasmine</samp> command-line tool provides the <samp class="listingcharacter listingcharacter">init</samp> option. If you use this option, Jasmine will create a <span class="italic">spec</span> directory for you with the <span class="italic">support</span> subdirectory containing the <span class="italic">jasmine.json</span> file<a class="indexanchor" id="i23_46"/>. This file contains the configuration for your tests. <span class="crossreference "><a href="23_003.html#l23.14">Listing 23.14</a></span> shows an example of this configuration.</p>
            <div class="listing " id="l23.14"><pre><span class="schwarz"/><span class="schwarz"><a id="p665"/>{</span><span class="schwarz"><br/></span><span class="schwarz">  </span><span class="hellblau"/><span class="hellblau">"spec_dir"</span><span class="schwarz"/><span class="schwarz">:</span><span class="schwarz"/><span class="schwarz"> </span><span class="hellblau"/><span class="hellblau">"spec"</span><span class="schwarz"/><span class="schwarz">,</span><span class="schwarz"><br/></span><span class="schwarz">  </span><span class="hellblau"/><span class="hellblau">"spec_files"</span><span class="schwarz"/><span class="schwarz">:</span><span class="schwarz"/><span class="schwarz"> </span><span class="schwarz"/><span class="schwarz">[</span><span class="schwarz"><br/></span><span class="schwarz">    </span><span class="gruen"/><span class="gruen">"**/*[sS]pec.?(m)js"</span><br/><span class="schwarz"/><span class="schwarz">  ],</span><span class="gruen"/><span class="gruen"/><br/>  "helpers"<span class="schwarz"/><span class="schwarz">: [</span><span class="gruen"/><span class="gruen"/><br/>    "helpers/**/*<span class="hellblau"/><span class="hellblau">.?(m)js"</span><span class="schwarz"><br/></span><span class="schwarz">  </span><span class="schwarz"/><span class="schwarz">],</span><span class="schwarz"><br/></span><span class="schwarz">  </span><span class="hellblau"/><span class="hellblau">"stopSpecOnExpectationFailure"</span><span class="schwarz"/><span class="schwarz">:</span><span class="schwarz"/><span class="schwarz"> </span><span class="rot"/><span class="rot">false</span><span class="schwarz"/><span class="schwarz">,</span><span class="schwarz"><br/></span><span class="schwarz">  </span><span class="hellblau"/><span class="hellblau">"random"</span><span class="schwarz"/><span class="schwarz">:</span><span class="schwarz"/><span class="schwarz"> </span><span class="rot"/><span class="rot">true</span><span class="schwarz"><br/></span><span class="schwarz"/><span class="schwarz">}</span><span class="schwarz"/><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 23.14</b>    
            Configuration of Jasmine (spec/support/jasmine.json)</p>
            <p class="standard">Now that you’ve installed and configured Jasmine, the next step is to move on to formulating and running your tests.</p>
        
        
            <h3 class="t3" id="h23.3.3">23.3.3    Tests in Jasmine<a class="indexanchor" id="i23_47"/></h3>
            <p class="standard">According to the guidelines of Jasmine, you must place your tests in a directory structure within the <span class="italic">spec</span> directory<a class="indexanchor" id="i23_48"/>. In the configuration file, you’ll also see the naming convention for the test files. The test files have the extension <span class="italic">.spec.mjs</span>. If this isn’t the case, the tests won’t run. Consequently, you should save the code from <span class="crossreference "><a href="23_003.html#l23.12">Listing 23.12</a></span> in a file named <span class="italic">buffer.spec.mjs</span> and place it in the <span class="italic">spec</span> directory. In <span class="crossreference "><a href="23_003.html#l23.15">Listing 23.15</a></span>, you can see what the result looks like after running the test.</p>
            <div class="listing " id="l23.15"><pre><span class="bold"><samp class="listingcharacter listingcharacter">$ npx jasmine</samp></span><br/>Randomized with seed 49771<br/>Started<br/>.<br/><br/>1 spec, 0 failures<br/>Finished in 0.007 seconds<br/>Randomized with seed 49771 (jasmine --random=true --seed=49771) </pre></div>
            <p class="caption "><b>Listing 23.15</b>    
            Running the Test with Jasmine</p>
            <p class="standard">To run the tests for your application, it’s sufficient to run<a class="indexanchor" id="i23_49"/> Jasmine on your command line<a class="indexanchor" id="i23_50"/>. If you’ve installed Jasmine only locally, as recommended, you can either use the <samp class="listingcharacter listingcharacter">npx jasmine</samp> command or create a test script in your <span class="italic">package.json</span> file. <span class="crossreference "><a href="23_003.html#l23.16">Listing 23.16</a></span> shows how this works. Then you can also start your tests via the <samp class="listingcharacter listingcharacter">npm test</samp> command.</p>
            <div class="listing " id="l23.16"><pre>{<br/>  "name": "node-book",<br/>  "version": "1.0.0",<br/><a id="p666"/>  "main": "buffer.js",<br/>  "private": true,<br/>  <span class="bold"><samp class="listingcharacter listingcharacter">"scripts": {<br/>    "test": "jasmine"<br/>  },<br/></samp></span>  "license": "ISC",<br/>  "devDependencies": {<br/>    "jasmine": "^3.9.0"<br/>  }<br/>} </pre></div>
            <p class="caption "><b>Listing 23.16</b>    
            Test Script in the “package.json” File</p>
            <p class="standard">The program now uses the configuration to search for the tests and then executes them. In <span class="crossreference "><a href="23_003.html#l23.15">Listing 23.15</a></span>, you can also see that, by default, Jasmine runs the tests in random order. The <samp class="listingcharacter listingcharacter">seed</samp> option allows you to re-create such a random test execution<a class="indexanchor" id="i23_51"/> to track any failure based on a specific execution order.</p>
            <p class="standard">Compared to the <samp class="listingcharacter listingcharacter">assert</samp> module of Node.js, Jasmine has the clear advantage that the output<a class="indexanchor" id="i23_52"/> contains much more information for you as a user. You also receive feedback on the progress of the tests in the event of success. As you can see in <span class="crossreference "><a href="23_003.html#l23.15">Listing 23.15</a></span>, the tool provides the following information: the time taken by the tests in the current run, the number of tests performed, and the number of failures that occurred.</p>
            <p class="standard">If you now add a second failing test, as shown in <span class="crossreference "><a href="23_003.html#l23.17">Listing 23.17</a></span>, you’ll receive the output shown in <span class="crossreference "><a href="23_003.html#l23.18">Listing 23.18</a></span>.</p>
            <div class="listing " id="l23.17"><pre><span class="schwarz">describe(</span><span class="hellblau">'Buffer'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="schwarz">it(</span><span class="hellblau">'should return the String representation if toString is called'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">const</span><span class="schwarz"> myBuffer </span><span class="dunkelblau">=</span><span class="schwarz"> Buffer</span><span class="schwarz">.from(</span><span class="hellblau">'Hello World'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><br/>    <span class="rot">const</span><span class="schwarz"> result </span><span class="dunkelblau">=</span><span class="schwarz"> myBuffer</span><span class="schwarz">.toString();</span><span class="schwarz"><br/></span><br/>    <span class="schwarz">expect(</span><span class="schwarz">result</span><span class="schwarz">).toEqual(</span><span class="hellblau">'Hello World'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><br/>  <span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter">it(<span class="hellblau">'should return the String representation if toString is called'</span><span class="schwarz">, () </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>    <span class="rot">const</span><span class="schwarz"> myBuffer </span><span class="dunkelblau">=</span><span class="schwarz"> Buffer.from(</span><span class="hellblau">'Hello World'</span><span class="schwarz">);</span><br/><br/>    <span class="rot">const</span><span class="schwarz"> result </span><span class="dunkelblau">=</span><span class="schwarz"> myBuffer.toString();</span><br/><br/>    expect(result).toEqual(<span class="hellblau">'Hello Sun'</span><span class="schwarz">);</span><br/>  });</samp></span><br/>}); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 23.17</b>    
            Failing Test in Jasmine (spec/buffer.spec.mjs)</p>
            <div class="listing " id="l23.18"><pre><span class="bold"><samp class="listingcharacter listingcharacter"><a id="p667"/>$ jasmine</samp></span><br/>Randomized with seed 18063<br/>Started<br/>.F<br/><br/>Failures:<br/>1) Buffer should return the String representation if toString is called<br/>  Message:<br/>    Expected 'Hello World' to equal 'Hello Sun'.<br/>  Stack:<br/>    Error: Expected 'Hello World' to equal 'Hello Sun'.<br/>        at &lt;Jasmine&gt;<br/>        at UserContext.&lt;anonymous&gt; (/srv/node/spec/buffer.spec.js:15:20)<br/>        at &lt;Jasmine&gt;<br/><br/>2 specs, 1 failure<br/>Finished in 0.009 seconds<br/>Randomized with seed 18063 (jasmine --random=true --seed=18063) </pre></div>
            <p class="caption "><b>Listing 23.18</b>    
            Output in Case of Failure in Jasmine</p>
            <p class="standard">Especially in the case of failing tests<a class="indexanchor" id="i23_53"/>, another advantage of Jasmine over the <samp class="listingcharacter listingcharacter">assert</samp> module becomes apparent: if a test fails, the remaining tests will still be run. At the beginning of the output, a <samp class="listingcharacter listingcharacter">.</samp> represents a successful test, and an <samp class="listingcharacter listingcharacter">F</samp> stands for a failed test.</p>
            <p class="standard">In addition to the information you receive after a successful test run, further information is available in the event of a failure. For example, for each failed test, the string identifying the test and describing what that test was intended to check is displayed. In addition, the expectation that you’ve formulated using the <samp class="listingcharacter listingcharacter">expect</samp> method and assertion is output in plain text. Finally, you get a comprehensive stack trace that gives you further insight into the origin of the problem.</p>
            <p class="standard">To help you organize your tests, Jasmine allows you to nest multiple calls of <samp class="listingcharacter listingcharacter">describe</samp> to emulate the structure of your application.</p>
        
        
            <h3 class="t3" id="h23.3.4">23.3.4    Assertions<a class="indexanchor" id="i23_54"/></h3>
            <p class="standard">In the previous examples, you’ve already learned about the use of assertion methods. Unlike the <samp class="listingcharacter listingcharacter">assert</samp> module, you can’t use assertions directly but must first call the <samp class="listingcharacter listingcharacter">expect</samp> method. Jasmine provides you with a few more assertions than the <samp class="listingcharacter listingcharacter">assert</samp> module does. <span class="crossreference "><a href="23_003.html#t23.2">Table 23.2</a></span> contains an overview of the most important assertions.</p>
            <table class="standardtable" id="t23.2">
                <thead>
                    <tr>
                        <th class="tablehead tablecell_first top_border_cell">
                            <p class="standard first-item last-item"><a id="p668"/>Assertion</p>
                        </th>
                        <th class="tablehead tablecell_last top_border_cell">
                            <p class="standard first-item last-item">Description</p>
                        </th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="tablecell tablecell_first top_border_cell">
                            <p class="standard first-item last-item"><samp class="listingcharacter listingcharacter">toBe(value)</samp></p>
                        </td>
                        <td class="tablecell tablecell_last top_border_cell">
                            <p class="standard first-item last-item">Compares type-safe with the <samp class="listingcharacter listingcharacter">===</samp> operator.</p>
                        </td>
                    </tr>
                    <tr class="light">
                        <td class="tablecell tablecell_first">
                            <p class="standard first-item last-item"><samp class="listingcharacter listingcharacter">toEqual(value)</samp></p>
                        </td>
                        <td class="tablecell tablecell_last">
                            <p class="standard first-item last-item">Checks whether the input value of <samp class="listingcharacter listingcharacter">expect</samp> corresponds to the specified value. It doesn’t compare type-safe with the <samp class="listingcharacter listingcharacter">==</samp> operator.</p>
                        </td>
                    </tr>
                    <tr>
                        <td class="tablecell tablecell_first">
                            <p class="standard first-item last-item"><samp class="listingcharacter listingcharacter">toMatch(regex)</samp></p>
                        </td>
                        <td class="tablecell tablecell_last">
                            <p class="standard first-item last-item">Compares the input with a regular expression.</p>
                        </td>
                    </tr>
                    <tr class="light">
                        <td class="tablecell tablecell_first">
                            <p class="standard first-item last-item"><samp class="listingcharacter listingcharacter">toBeDefined()</samp></p>
                        </td>
                        <td class="tablecell tablecell_last">
                            <p class="standard first-item last-item">Checks if the input value doesn’t correspond to the <samp class="listingcharacter listingcharacter">undefined</samp> value.</p>
                        </td>
                    </tr>
                    <tr>
                        <td class="tablecell tablecell_first">
                            <p class="standard first-item last-item"><samp class="listingcharacter listingcharacter">toBeNull()</samp></p>
                        </td>
                        <td class="tablecell tablecell_last">
                            <p class="standard first-item last-item">Checks whether the entered value corresponds to the value <samp class="listingcharacter listingcharacter">null</samp>.</p>
                        </td>
                    </tr>
                    <tr class="light">
                        <td class="tablecell tablecell_first">
                            <p class="standard first-item last-item"><samp class="listingcharacter listingcharacter">toBeTruthy(), toBeFalsy()</samp></p>
                        </td>
                        <td class="tablecell tablecell_last">
                            <p class="standard first-item last-item">Checks whether a value after a cast to Boolean corresponds to the value <samp class="listingcharacter listingcharacter">true</samp> or <samp class="listingcharacter listingcharacter">false</samp>, respectively.</p>
                        </td>
                    </tr>
                    <tr>
                        <td class="tablecell tablecell_first">
                            <p class="standard first-item last-item"><samp class="listingcharacter listingcharacter">toContain(value)</samp></p>
                        </td>
                        <td class="tablecell tablecell_last">
                            <p class="standard first-item last-item">Checks whether an input array contains the element specified in <samp class="listingcharacter listingcharacter">value</samp>.</p>
                        </td>
                    </tr>
                    <tr class="light">
                        <td class="tablecell tablecell_first">
                            <p class="standard first-item last-item"><samp class="listingcharacter listingcharacter">toThrow()</samp></p>
                        </td>
                        <td class="tablecell tablecell_last">
                            <p class="standard first-item last-item">Expects the function passed to <samp class="listingcharacter listingcharacter">expect</samp> to throw an error.</p>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p class="caption "><b>Table 23.2</b>    
            Assertions in Jasmine</p>
            <p class="standard">In addition to these assertions, which are called <span class="italic">matchers</span> in Jasmine, there are several other methods you can use to compare a value with a certain expectation. For more information on Jasmine, visit <span class="url"><a href="http://jasmine.github.io">http://jasmine.github.io</a></span>.</p>
            <p class="standard">As in the <samp class="listingcharacter listingcharacter">assert</samp> module, negations for the individual matchers also exist for Jasmine<a class="indexanchor" id="i23_55"/>. In this case, however, you don’t need to call another method, but simply place <samp class="listingcharacter listingcharacter">.not</samp> before the method call. <span class="crossreference "><a href="23_003.html#l23.19">Listing 23.19</a></span> demonstrates this procedure.</p>
            <div class="listing " id="l23.19"><pre><span class="schwarz">describe(</span><span class="hellblau">'Negation'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">function()</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="schwarz">it(</span><span class="hellblau">'should work in positive case'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">function()</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="schwarz">expect(</span><span class="hellblau">'Node.js'</span><span class="schwarz">).toEqual(</span><span class="hellblau">'Node.js'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><br/>  <span class="schwarz">it(</span><span class="hellblau">'should work in negative case'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">function()</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="schwarz">expect(</span><span class="hellblau">'Node.js'</span><span class="schwarz">).</span><span class="schwarz">not</span><span class="schwarz">.toEqual(</span><span class="hellblau">'React'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 23.19</b>    
            Negation in Jasmine Tests (spec/negation.spec.mjs)</p>
            <p class="standard">With the matchers included in Jasmine, you can cover most of the cases you’ll encounter in your unit tests. However, should you ever come across a special case that can only be solved very awkwardly with the standard matchers, you can also define your own <a id="p669"/>matchers. This is especially worthwhile if the case for which you need the matcher occurs multiple times in your tests. This is true when you want to test specific operations on classes of objects that you define. For more information on this topic, see the documentation at <span class="url"><a href="https://jasmine.github.io/tutorials/custom_matcher">https://jasmine.github.io/tutorials/custom_matcher</a></span>. <span class="crossreference "><a href="23_003.html#l23.20">Listing 23.20</a></span> shows an example of such a custom matcher.<a class="indexanchor" id="i23_56"/></p>
            <div class="listing " id="l23.20"><pre><span class="rot">const</span><span class="schwarz"> customMatchers </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="schwarz">toHaveATitle()</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">return</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      <span class="schwarz">compare(</span><span class="schwarz">actual</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>        <span class="rot">const</span><span class="schwarz"> result </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>          pass<span class="schwarz">:</span><span class="schwarz"> actual</span><span class="schwarz">.hasOwnProperty(</span><span class="hellblau">'title'</span><span class="schwarz">),</span><span class="schwarz"><br/></span>        <span class="schwarz">};</span><span class="schwarz"><br/></span><br/>        <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">result</span><span class="schwarz">.</span><span class="schwarz">pass</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>          result<span class="schwarz">.</span><span class="schwarz">message </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="violett">`Expected ${JSON.stringify(actual)} to have a title`</span><span class="schwarz">;</span><span class="schwarz"><br/></span>        <span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">else</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>          result<span class="schwarz">.</span><span class="schwarz">message </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="violett">`Expected ${JSON.stringify(</span><br/>            actual, <br/>          )} to have a title, but it didn<span class="hellblau">'t.`;</span><br/>        }<br/>        return result;<br/>      },<br/>    };<br/>  },<br/>};<br/><br/>describe('<span class="schwarz">Custom Matchers</span><span class="hellblau">', () =&gt; {</span><br/>  beforeAll(() =&gt; {<br/>    jasmine.addMatchers(customMatchers);<br/>  });<br/><br/>  it('<span class="schwarz">should have a title property</span><span class="hellblau">', () =&gt; {</span><br/>    const withTitle = { title: '<span class="schwarz">My Title</span><span class="hellblau">' };</span><br/>    expect(withTitle).toHaveATitle();<br/>  });<br/><br/>  it('<span class="schwarz">should fail without a title</span><span class="hellblau">', () =&gt; {</span><br/>    const withoutTitle = { name: '<span class="schwarz">no title' </span><span class="schwarz">};</span><span class="schwarz"><br/></span>    <span class="schwarz">expect(</span><span class="schwarz">withoutTitle</span><span class="schwarz">).toHaveATitle();</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 23.20</b>    
            Custom Matchers in Jasmine (spec/customMatcher.spec.mjs)</p>
            <p class="standard"><a id="p670"/>To create a custom matcher, you must first define an object that contains the individual matchers as properties. These each return an object with a <samp class="listingcharacter listingcharacter">compare</samp> method. Within this method, you can access the object to be checked as well as the control object via the parameters. The return value of the <samp class="listingcharacter listingcharacter">compare</samp> method is expected to be an object containing the <samp class="listingcharacter listingcharacter">pass</samp> property, which indicates whether the test was successful, and <samp class="listingcharacter listingcharacter">message</samp>, which contains details about the test.</p>
        
        
            <h3 class="t3" id="h23.3.5">23.3.5    Spies<a class="indexanchor" id="i23_57"/></h3>
            <p class="standard">In addition to the matcher methods, Jasmine implements spies, another significant feature with regard to testing applications. In general, a spy represents a wrapper around functions. In the simplest case, this wrapper<a class="indexanchor" id="i23_58"/> enables you to monitor the call of a method.</p>
            <p class="standard">In the first test in <span class="crossreference "><a href="23_003.html#l23.21">Listing 23.21</a></span>, you see how to create a wrapper around the <samp class="listingcharacter listingcharacter">toString</samp> method of the <samp class="listingcharacter listingcharacter">buffer</samp> object using the <samp class="listingcharacter listingcharacter">spyOn</samp> method. This wrapper then ensures that you can use the <samp class="listingcharacter listingcharacter">toHaveBeenCalled</samp> method<a class="indexanchor" id="i23_59"/> to check whether the <samp class="listingcharacter listingcharacter">toString</samp> method was called by the test. This functionality isn’t really useful for direct calls like the one shown in the example. However, if you want to test more complex workflows where a method calls other methods, this type of testing becomes relevant again.</p>
            <p class="standard">The second test shown in <span class="crossreference "><a href="23_003.html#l23.21">Listing 23.21</a></span> introduces you to another feature of the spies in Jasmine. You can use spies to manipulate the return value of a method. For this purpose, you must call the <samp class="listingcharacter listingcharacter">and.returnValue</samp> method on the return value of the <samp class="listingcharacter listingcharacter">spyOn</samp> method<a class="indexanchor" id="i23_60"/>. Finally, you pass to it the value that this method should output. As you can see in the example, you can modify the <samp class="listingcharacter listingcharacter">toString</samp> method in such a way that it returns a different string.</p>
            <div class="listing " id="l23.21"><pre><span class="schwarz">describe(</span><span class="hellblau">'Spy'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">let</span><span class="schwarz"> buffer</span><span class="schwarz">;</span><span class="schwarz"><br/></span><br/>  <span class="schwarz">beforeEach(()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    buffer <span class="dunkelblau">=</span><span class="schwarz"> Buffer</span><span class="schwarz">.from(</span><span class="hellblau">'Hello World'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><br/>  <span class="schwarz">it(</span><span class="schwarz">"should track calls to </span><span class="hellblau">'toString'</span><span class="schwarz">"</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="schwarz">spyOn(</span><span class="schwarz">buffer</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'toString'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><br/>    buffer<span class="schwarz">.toString();</span><span class="schwarz"><br/></span><br/>    <span class="schwarz">expect(</span><span class="schwarz">buffer</span><span class="schwarz">.</span><span class="schwarz">toString</span><span class="schwarz">).toHaveBeenCalled();</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><br/>  <span class="schwarz">it(</span><span class="hellblau">'should return a different result'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="schwarz">spyOn(</span><span class="schwarz">buffer</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'toString'</span><span class="schwarz">).</span><span class="schwarz">and</span><span class="schwarz">.returnValue(</span><span class="hellblau">'Hello Node.js'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><br/><a id="p671"/>    <span class="rot">const</span><span class="schwarz"> result </span><span class="dunkelblau">=</span><span class="schwarz"> buffer</span><span class="schwarz">.toString();</span><span class="schwarz"><br/></span><br/>    <span class="schwarz">expect(</span><span class="schwarz">buffer</span><span class="schwarz">.</span><span class="schwarz">toString</span><span class="schwarz">).toHaveBeenCalled();</span><span class="schwarz"><br/></span>    <span class="schwarz">expect(</span><span class="schwarz">result</span><span class="schwarz">).toEqual(</span><span class="hellblau">'Hello Node.js'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 23.21</b>    
            Spies in Jasmine (spec/spies.spec.mjs)</p>
        
        
            <h3 class="t3" id="h23.3.6">23.3.6    beforeEach<a class="indexanchor" id="i23_61"/> and afterEach<a class="indexanchor" id="i23_62"/></h3>
            <p class="standard">The example shown in <span class="crossreference "><a href="23_003.html#l23.21">Listing 23.21</a></span> introduces yet another feature of Jasmine. If you build your tests according to the AAA scheme, in most cases, you’ll simply copy the first phase for at least a set of tests to initialize the correct environment for your tests. The same is true with regard to any cleanup work after the tests. For this reason, Jasmine offers the <samp class="listingcharacter listingcharacter">beforeEach</samp><a class="indexanchor" id="i23_63"/> and <samp class="listingcharacter listingcharacter">afterEach</samp><a class="indexanchor" id="i23_64"/> methods. In both methods, you define a function that is run before and after each test.</p>
            <p class="standard">The following section introduces you to Jest, another testing framework for Node.js.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>