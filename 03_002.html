<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Developing Your First Application" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Developing Your First Application" name="description"/>
            <meta content="en" name="language"/>
            <title>Developing Your First Application</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h3.2">3.2    The First Application<a class="indexanchor" id="i03_27"/></h2>
        <p class="standard">When you create applications using Node.js, the source code of that application is contained in one or more files. When launching the application, you specify the name of the initial file as an option in the command line. From this file, you then load the rest of the components of your application via the Node.js module system<a class="indexanchor" id="i03_28"/>. The entire source code is read in and optimized by the JavaScript engine<a class="indexanchor" id="i03_29"/>. As a consequence, changes to the source code don’t directly affect the running application. This means you need to exit and restart it for the changes to become active. <span class="crossreference "><a href="03_002.html#l3.8">Listing 3.8</a></span> shows how you can run an application with Node.js.</p>
        <div class="listing " id="l3.8"><pre>$ node server.mjs<br/>Hello world!<br/>$ </pre></div>
        <p class="caption "><b>Listing 3.8</b>    
            Running Node.js Applications</p>
        <p class="standard"><a id="p80"/>The <span class="italic">server.mjs</span> file contains only the <samp class="listingcharacter listingcharacter">console.log('Hello world!')</samp> line. The advantage of this method of running<a class="indexanchor" id="i03_30"/> an application is that you can run the application as many times as you want, and all you need to do is run the command line from <span class="crossreference "><a href="03_002.html#l3.8">Listing 3.8</a></span>. In addition, you can easily run the source code on other systems or make the application available to other users as open-source software.</p>
        <div class="box box_standard">
            <h6 class="boxheading">Node.js Module Systems<a class="indexanchor" id="i03_31"/></h6>
            <p class="standard first">Currently, Node.js supports two different module systems. The previous implementation—the CommonJS module system<a class="indexanchor" id="i03_32"/>—uses <samp class="listingcharacter listingcharacter">module.exports</samp> to export elements and the <samp class="listingcharacter listingcharacter">require</samp> function to load elements. This module system has been part of the Node.js platform from the beginning.</p>
            <p class="standard">Meanwhile, another module system—the ECMAScript module system<a class="indexanchor" id="i03_33"/>—has also been included in the standard ECMAScript. This system uses the <samp class="listingcharacter listingcharacter">import</samp> and <samp class="listingcharacter listingcharacter">export</samp> keywords and isn’t compatible with the CommonJS module system.</p>
            <p class="standard last">For several years now, Node.js has been in a transition phase away from the CommonJS module system and toward the ECMAScript module system. For the ECMAScript modules to work, it’s required that the files have the <span class="italic">.mjs</span><a class="indexanchor" id="i03_34"/> extension. Throughout this book, we’ll use the ECMAScript module system. However, in <span class="crossreference "><a href="04_001.html#h4">Chapter 4</a></span>, you’ll also learn more about the CommonJS module system and how you can work with both systems.</p>
        </div>
        <p class="standard">Note that the output of <samp class="listingcharacter listingcharacter">Hello world!</samp> doesn’t yet represent an application. However, with Node.js, you can create dynamic web applications<a class="indexanchor" id="i03_35"/><a class="indexanchor" id="i03_36"/> without the need for a separate web server because Node.js allows you to create your own web server via the <samp class="listingcharacter listingcharacter">http</samp> module. The following sections will guide you step by step through the classic example of a Node.js application: a very lightweight web server.</p>
        
            <h3 class="t3" id="h3.2.1">3.2.1    Web Server<a class="indexanchor" id="i03_37"/> in Node.js</h3>
            <p class="standard">The web server you develop in this example should be able to accept requests from browsers and respond to them with a correct HTTP response<a class="indexanchor" id="i03_38"/> and the output of the <samp class="listingcharacter listingcharacter">Hello world</samp> string. You start with a basic framework and extend it until the application meets the requirements. <span class="crossreference "><a href="03_002.html#l3.9">Listing 3.9</a></span> contains the basic structure of the application. You should save this code in a separate file named <span class="italic">server.mjs</span>.</p>
            <div class="listing " id="l3.9"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'http'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> server </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createServer();</span><span class="schwarz"><br/></span>server<span class="schwarz">.listen(8080,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz"><br/></span>    <span class="violett">`Server is listening to http://localhost:${server.address().port}`</span><span class="schwarz">,</span><span class="schwarz"><br/></span>  <span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 3.9</b>    
            Structure of a Web Server in Node.js</p>
            <div class="box box_standard">
                <h6 class="boxheading"><a id="p81"/>Template Strings<a class="indexanchor" id="i03_39"/></h6>
                <p class="standard first last">With <span class="italic">template strings</span>, such as those used in <span class="crossreference "><a href="03_002.html#l3.9">Listing 3.9</a></span>, there is a third way to define strings in JavaScript besides single and double quotes. However, this is a special form whose processing is somewhat slower than that of simple strings. With template strings defined with the backtick<a class="indexanchor" id="i03_40"/> character (<samp class="listingcharacter listingcharacter">`</samp>), you can use <samp class="listingcharacter listingcharacter">${}</samp> to replace variables or evaluate the JavaScript expressions within a string. It’s also possible to insert line breaks without concatenating the string with the <samp class="listingcharacter listingcharacter">+</samp> operator.</p>
            </div>
            <p class="standard">Actually, a JavaScript engine such as V8 doesn’t have the capabilities to provide a web server in a simple way. For this reason, modules<a class="indexanchor" id="i03_41"/> exist for Node.js that extend the functionality of the Node.js platform. In this example, you need the functionality of a web server. A separate module exists for Node.js for this purpose and to solve other tasks related to HTTP. The functionality from the various modules of Node.js is automatically available to you. As a developer, all you need to do is load the modules you need for your application before using them. Loading<a class="indexanchor" id="i03_42"/> modules and other files in Node.js is done via the <samp class="listingcharacter listingcharacter">import</samp> keyword. As you can see in the example, you can directly address the parts of the interface of the respective module that you need for your application.</p>
            <div class="box box_standard">
                <h6 class="boxheading">var<a class="indexanchor" id="i03_43"/>, let<a class="indexanchor" id="i03_44"/>, and const<a class="indexanchor" id="i03_45"/></h6>
                <p class="standard first">In JavaScript, there are now three ways available to define variables<a class="indexanchor" id="i03_46"/>. Each of these ways has an impact on the way you develop your applications. If you define your variables by prefixing them with the <samp class="listingcharacter listingcharacter">var</samp> keyword, this has the effect that the variable is valid in the current function and all subfunctions<a class="indexanchor" id="i03_47"/>. For a long time, this was the only available option.</p>
                <p class="standard">The <samp class="listingcharacter listingcharacter">let</samp> keyword enables you to define variables at the block level<a class="indexanchor" id="i03_48"/>. For example, if you define a counter variable in a <samp class="listingcharacter listingcharacter">for</samp> loop with <samp class="listingcharacter listingcharacter">let</samp>, this variable is valid only within the loop. A variable defined with <samp class="listingcharacter listingcharacter">let</samp> in a function has the same properties as one defined with <samp class="listingcharacter listingcharacter">var</samp>. <samp class="listingcharacter listingcharacter">let</samp> has the same range of functions as <samp class="listingcharacter listingcharacter">var</samp> except that you have even better control over the scope. So, there are actually hardly any reasons to continue using <samp class="listingcharacter listingcharacter">var</samp>. However, be careful not to mix <samp class="listingcharacter listingcharacter">var</samp> and <samp class="listingcharacter listingcharacter">let</samp> within your application, as this can easily lead to errors that are difficult to locate.</p>
                <p class="standard last">The third way to define a variable is with the <samp class="listingcharacter listingcharacter">const</samp> keyword. Such variables aren’t variables in the true sense, but constants<a class="indexanchor" id="i03_49"/>, which means that you can’t change the value of the variable after the initial assignment. The fact that JavaScript works with references for nonprimitive values such as objects or arrays puts the whole thing into perspective again. With a <samp class="listingcharacter listingcharacter">const</samp> object, you can no longer change the reference, but you can change the properties of the object itself. Try to use <samp class="listingcharacter listingcharacter">const</samp> as much as possible during development to avoid overwriting variables by mistake. If you actually need variables, you should use <samp class="listingcharacter listingcharacter">let</samp>.</p>
            </div>
            <p class="standard"><a id="p82"/>Using the <samp class="listingcharacter listingcharacter">http</samp> module, you can create a client to query other web servers in addition to the initial server. However, for your web server application, you only need the server. You can create this with the imported <samp class="listingcharacter listingcharacter">createServer</samp> function of the <samp class="listingcharacter listingcharacter">http</samp> module. The return value of this method is the HTTP server,<a class="indexanchor" id="i03_50"/> which is available to you as an object for later use. The newly created server object<a class="indexanchor" id="i03_51"/> currently has no functionality, nor is a connection opened to the outside world.</p>
            <p class="standard">The next step is to open this very connection toward the clients so that they can connect to the server and retrieve data. The server provides you with the <samp class="listingcharacter listingcharacter">listen</samp> method, a way to specify a port and an IP address<a class="indexanchor" id="i03_52"/> through which your users can connect to the server. You can pass the port number and the IP address to which the server should be bound to the <samp class="listingcharacter listingcharacter">listen</samp> method. Normally, however, you should at least specify the port number, as otherwise any free port will be assigned. The port number<a class="indexanchor" id="i03_53"/> is specified as an integer, which must be between 0 and 65,535. There are two things to keep in mind when choosing a port for your web server: The port used must not already be taken by another application, and it should not be in the range of system ports<a class="indexanchor" id="i03_54"/> between 0 and 1,023. If you use a port 1,024 or higher, you can run your Node.js script as a normal user; for ports below that value, you need admin privileges<a class="indexanchor" id="i03_55"/>. You should always run tests and examples as a normal user because as an administrator you have considerably more privileges and can seriously damage the system. You can specify the IP address as a string, for example, <samp class="listingcharacter listingcharacter">'127.0.0.1'</samp>. If you don’t specify any address, the IPv6 address <a class="indexanchor" id="i03_56"/><samp class="listingcharacter listingcharacter">::</samp> or the IPv4 address <a class="indexanchor" id="i03_57"/><samp class="listingcharacter listingcharacter">0.0.0.0</samp> will be used by default. This means that the server is bound to all interfaces of the system. So, for example, you can reach your server using the name <samp class="listingcharacter listingcharacter">localhost</samp>.</p>
            <p class="standard">In addition to specifying the address and port, calling the HTTP server’s <samp class="listingcharacter listingcharacter">listen</samp> method opens the connection and makes the server wait for incoming requests. You can also pass a callback function to the <samp class="listingcharacter listingcharacter">listen</samp> method as the last argument. This is executed as soon as the server is bound. In the example, this function outputs the information that the server is ready to operate and at which address you can reach it. If you don’t take care of such an output yourself, Node.js doesn’t display any further information. Now you should save the script under the name <span class="italic">server.mjs</span>. You can run the web server on your system and test the result already. <span class="crossreference "><a href="03_002.html#l3.10">Listing 3.10</a></span> shows what the result of the test looks like.</p>
            <div class="listing " id="l3.10"><pre><span class="bold">$ node server.mjs </span><br/>Server is listening to http://localhost:8080 </pre></div>
            <p class="caption "><b>Listing 3.10</b>    
            Running the Web Server on Node.js</p>
            <p class="standard">If you get the error<a class="indexanchor" id="i03_58"/> <samp class="listingcharacter listingcharacter">create Server: listen EADDRINUSE :::8080</samp> when running your application, it means that the port is already taken by another application, and you need to choose another port for your Node.js application.</p>
            <p class="standard">The <samp class="listingcharacter listingcharacter">node</samp> command with the file containing the source code of the web server as an option causes a Node.js process to be started that connects to the specified combination of address and port and then waits for incoming connections that it can serve. By exe<a id="p83"/>cuting the script, the command line is blocked, and you can’t make any further entries to it. Due to the architecture of Node.js, which is based on the event-driven principle, very little load is created by the web server script because Node.js doesn’t block<a class="indexanchor" id="i03_59"/> when it has nothing to do. If you want to cancel the script, you can do this via the <span class="keyboard">(Ctrl)</span>+<span class="keyboard">(C)</span> shortcut, which returns a command prompt. Now you can test the web server with your browser by entering “http://localhost:8080” in the address bar.</p>
            <p class="standard">The problem is that although your web server is bound to the correct address and port, it has no logic to handle incoming requests. This primarily causes you to get no output when testing, and, if you leave your browser window open long enough, a time-out error<a class="indexanchor" id="i03_60"/>. For this reason, you’ll insert source code in the next step to ensure that incoming requests are also served in a meaningful way.</p>
            <p class="standard">The web server you create here in Node.js differs seriously in some features from other implementations in dynamic scripting languages such as PHP. Here, each request is served separately, and the necessary source code is read in the process. With Node.js, the application’s code is read once and then remains in the memory. The application runs permanently. This is where an important aspect of Node.js comes into play: asynchronous task processing. The web server responds to events, in this case, to the clients’ requests. For this purpose, a function is defined—a callback—which is executed as soon as a request is received. Although this code is defined in a block, as in other languages, the source code responsible for handling the requests isn’t executed until such a request is received.</p>
        
        
            <h3 class="t3" id="h3.2.2">3.2.2    Extending the Web Server</h3>
            <p class="standard">In <span class="crossreference "><a href="03_002.html#l3.11">Listing 3.11</a></span> you can see the extended source code from <span class="crossreference "><a href="03_002.html#l3.9">Listing 3.9</a></span>. This version of the web server can also handle requests correctly.</p>
            <div class="listing " id="l3.11"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'http'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> server </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createServer(</span><span class="bold">(request, response) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  response.writeHead(200, { <span class="hellblau">'content-type'</span><span class="schwarz">: </span><span class="hellblau">'text/plain; charset=utf-8'</span><span class="schwarz"> });</span><br/>  response.write(<span class="hellblau">'Hello '</span><span class="schwarz">);</span><br/>  response.end(<span class="hellblau">' World\n'</span><span class="schwarz">);</span><br/>});<br/> </span><br/>server.listen(8080, () <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="magenta">console</span><span class="schwarz">.log(</span><br/>    <span class="violett">`Server is listening to http://localhost:${server.address().port}`</span><span class="schwarz">,</span><br/>  );<br/>}); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 3.11</b>    
            Web Server with Callback</p>
            <p class="standard"><a id="p84"/>The only adaptation of the example from <span class="crossreference "><a href="03_002.html#l3.9">Listing 3.9</a></span> takes place in the call of the <samp class="listingcharacter listingcharacter">createServer</samp> function. Here, Node.js receives the callback that specifies what should happen when a request from a client reaches the server. In this simple example, you first just output the string <samp class="listingcharacter listingcharacter">Hello world</samp> in the client’s browser<a class="indexanchor" id="i03_61"/>.</p>
            <p class="standard">To achieve this output, you should first look at the structure of the callback function. It has two parameters, a <samp class="listingcharacter listingcharacter">request</samp><a class="indexanchor" id="i03_62"/> and a <samp class="listingcharacter listingcharacter">response</samp> object<a class="indexanchor" id="i03_63"/>, representing the client’s request and the server’s response, respectively. In this example, you should first disregard the client’s request and focus on the server’s response. The first step is to prepare the HTTP header<a class="indexanchor" id="i03_64"/> information that will later be sent back to the client. This is done using the <samp class="listingcharacter listingcharacter">writeHead</samp> method. The first argument of this function consists of a number representing the HTTP status code<a class="indexanchor" id="i03_65"/>. The second argument is an object that contains the actual HTTP header. The key values of the object, such as the <samp class="listingcharacter listingcharacter">content-type</samp><a class="indexanchor" id="i03_66"/> value in the example, should be written in lowercase according to convention. In the example, you can see the specification of the content type, which in this case is set to <samp class="listingcharacter listingcharacter">text/plain</samp> to indicate to the client that the server’s response contains only text. Because some browsers such as Firefox return error messages if the character coding isn’t specified correctly, the content type is extended by the information <samp class="listingcharacter listingcharacter">charset=utf-8</samp> to inform the browser that the HTTP body is UTF-8<a class="indexanchor" id="i03_67"/> encoded.</p>
            <p class="standard">You can create the response visible to the user—the HTTP body<a class="indexanchor" id="i03_68"/>—using the <samp class="listingcharacter listingcharacter">write</samp> method. When this method is called, fragments of the response, called <span class="italic">chunks</span>, are sent. You can call this method several times in a row, which will result in the individual parts being joined together. However, you should make sure that before calling <samp class="listingcharacter listingcharacter">write</samp>, the correct HTTP headers are always sent with <samp class="listingcharacter listingcharacter">writeHead</samp>. If you don’t call the <samp class="listingcharacter listingcharacter">writeHead</samp> method, the Node.js HTTP server implicitly sends an HTTP header with a status code of <samp class="listingcharacter listingcharacter">200</samp> and a content type of <samp class="listingcharacter listingcharacter">text/plain</samp>, so a response without explicitly providing header information is also valid. Calling <samp class="listingcharacter listingcharacter">write</samp> ensures that parts of the response are sent to the client. However, in this case, the client doesn’t know when the server is finished sending the response. You, as the developer, must take care of this by using the <samp class="listingcharacter listingcharacter">end</samp> method of the <samp class="listingcharacter listingcharacter">response</samp> object. You can optionally provide a string as an argument. In this case, <samp class="listingcharacter listingcharacter">end</samp> behaves in the same way as <samp class="listingcharacter listingcharacter">write</samp> as it sends the specified chunk to the client and then terminates the response.</p>
            <p class="standard">The <samp class="listingcharacter listingcharacter">write</samp> method has two other features worth mentioning. For one thing, not only can you pass strings as arguments but also as <samp class="listingcharacter listingcharacter">buffer</samp> objects<a class="indexanchor" id="i03_69"/>. A <samp class="listingcharacter listingcharacter">buffer</samp> object consists of binary data that greatly facilitates the streaming of data. This class of objects primarily comes into play when streams are used. The second feature consists of specifying the coding of the string, namely, via the second parameter of the <samp class="listingcharacter listingcharacter">write</samp> method. This is optional, and, if omitted, Node.js uses <samp class="listingcharacter listingcharacter">utf-8</samp> as the default coding method. Possible other values are <samp class="listingcharacter listingcharacter">utf16le</samp>, <samp class="listingcharacter listingcharacter">ascii</samp>, or <samp class="listingcharacter listingcharacter">hex</samp>. UTF-8 as the coding<a class="indexanchor" id="i03_70"/> method is permitted in this example, which is why it’s also not necessary to specify a character coding. As an alternative to combining multiple <samp class="listingcharacter listingcharacter">write</samp> calls and one <samp class="listingcharacter listingcharacter">end</samp> call, you can also store the entire response to the client in a variable and send it in a single call of the <samp class="listingcharacter listingcharacter">end</samp> method.</p>
            <p class="standard"><a id="p85"/>For the example to work correctly, you need to make sure that you restart the web server so that the custom source code from Node.js is read correctly. For this purpose, it’s best to terminate the possibly still running instance of the first example via the shortcut <span class="keyboard">(Ctrl)</span>+<span class="keyboard">(C)</span> and restart the web server by calling the <samp class="listingcharacter listingcharacter">node</samp> command again with the name of the file of your source code. <span class="crossreference "><a href="03_002.html#f3.2">Figure 3.2</a></span> shows the result of the request.</p>
            <div class="imagebox figure-type"><a href="img-f3.2.html" id="f3.2"><img alt="Response from the Web Server to the Client" id="img-f3.2" src="bilderklein/klein03_002.png"/></a></div>
            <p class="caption "><b>Figure 3.2</b>    
            Response from the Web Server to the Client</p>
            <p class="standard">In this example, you’ve seen how it’s possible, with just a few lines of JavaScript code, to create a functional web server that responds to a client’s request with a correct HTTP response.</p>
        
        
            <h3 class="t3" id="h3.2.3">3.2.3    Creating an HTML Response<a class="indexanchor" id="i03_71"/></h3>
            <p class="standard">In reality, however, you rarely have to deal with responses from web servers in plain text. Thus, we’ll now extend the example so that the server responds with a response in HTML, just as a normal web server would. <span class="crossreference "><a href="03_002.html#l3.12">Listing 3.12</a></span> shows the adjustments you need to make for this.</p>
            <div class="listing " id="l3.12"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'http'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><br/><span class="rot">const</span><span class="schwarz"> server </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createServer((</span><span class="schwarz">request</span><span class="schwarz">,</span><span class="schwarz"> response</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="bold"><span class="schwarz">response.writeHead(200, { </span><span class="hellblau">'content-type'</span><span class="schwarz">: </span><span class="hellblau">'text/html; charset=utf-8'</span><span class="schwarz"> });</span><br/><br/>  <span class="rot">const</span><span class="schwarz"> body </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="violett">`&lt;!DOCTYPE html&gt;</span><br/>    &lt;html&gt;<br/>      &lt;head&gt;<br/>        &lt;meta charset=<span class="hellblau">"utf-8"</span><span class="violett">&gt;</span><br/>        &lt;title&gt;Node.js Demo&lt;/title&gt;<br/>      &lt;/head&gt;<br/>      &lt;body&gt;<br/>        &lt;h1 style=<span class="hellblau">"color:green"</span><span class="violett">&gt;Hello World&lt;/h1&gt;</span><br/>      &lt;/body&gt;<br/>    &lt;/html&gt;`<span class="schwarz">;</span><br/><br/>  response.end(body);</span><br/><a id="p86"/>});<br/>server.listen(8080, () <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="magenta">console</span><span class="schwarz">.log(</span><br/>    <span class="violett">`Server is listening to http://localhost:${server.address().port}`</span><span class="schwarz">,</span><br/>  );<br/>}); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 3.12</b>    
            Web Server HTML Response</p>
            <p class="standard">The only change you need to make to the source code of the example is to adjust the content type, which is now <samp class="listingcharacter listingcharacter">text/html</samp> instead of <samp class="listingcharacter listingcharacter">text/plain</samp><a class="indexanchor" id="i03_72"/>. In addition, the <samp class="listingcharacter listingcharacter">write</samp> was dropped, and the HTTP body is sent entirely using the <samp class="listingcharacter listingcharacter">end</samp> method. The value passed to the <samp class="listingcharacter listingcharacter">end</samp> method contains an HTML string that reflects the structure of the web page to be displayed. Because this string is quite large, it’s best to outsource it to the separate <samp class="listingcharacter listingcharacter">body</samp> constant and use a template string to create a clear multiline string with simple means. Finally, you must pass the <samp class="listingcharacter listingcharacter">body</samp> constant to the <samp class="listingcharacter listingcharacter">end</samp> method. Once you’ve made these changes, all you need to do is restart the Node.js process running your web server for the changes to take effect. When you reload the page in your browser now, you should see a similar result to the one shown in <span class="crossreference "><a href="03_002.html#f3.3">Figure 3.3</a></span>.</p>
            <div class="imagebox figure-type"><a href="img-f3.3.html" id="f3.3"><img alt="Output of an HTML Page" id="img-f3.3" src="bilderklein/klein03_003.png"/></a></div>
            <p class="caption "><b>Figure 3.3</b>    
            Output of an HTML Page</p>
            <p class="standard">Up to this point, you’ve predominantly been concerned with the <samp class="listingcharacter listingcharacter">response</samp> object, that is, the response to the client. Now it’s time to take a closer look at the <samp class="listingcharacter listingcharacter">request</samp> object, which is the actual request. This object allows you to read the information sent by the client and include it in the response generation.</p>
        
        
            <h3 class="t3" id="h3.2.4">3.2.4    Generating Dynamic<a class="indexanchor" id="i03_73"/> Responses</h3>
            <p class="standard">In classic web applications, information is sent from the browser using the HTTP methods <samp class="listingcharacter listingcharacter">GET</samp><a class="indexanchor" id="i03_74"/> and <samp class="listingcharacter listingcharacter">POST</samp><a class="indexanchor" id="i03_75"/>. Mostly this is done via forms<a class="indexanchor" id="i03_76"/> or parameters<a class="indexanchor" id="i03_77"/> that are coded in the URL. You’ll now extend the example and display a string specified by the user in the URL on the output page.</p>
            <p class="standard"><a id="p87"/>You can use the source code from <span class="crossreference "><a href="03_002.html#l3.12">Listing 3.12</a></span> as a basis. The adapted source code is shown in <span class="crossreference "><a href="03_002.html#l3.13">Listing 3.13</a></span>, followed by the corresponding explanations of the changes.</p>
            <div class="listing " id="l3.13"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'http'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> server </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createServer((</span><span class="schwarz">request</span><span class="schwarz">,</span><span class="schwarz"> response</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  response<span class="schwarz">.writeHead(200,</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> </span><span class="hellblau">'content-type'</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">'text/html; charset=utf-8'</span><span class="schwarz"> </span><span class="schwarz">});</span><span class="schwarz"><br/></span> <br/>  <span class="bold"><span class="rot">const</span><span class="schwarz"> url </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">new </span><span class="schwarz">URL(request.url, </span><span class="hellblau">'http://localhost:8080'</span><span class="schwarz">);</span><br/> </span><br/>  <span class="rot">const</span><span class="schwarz"> body </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="violett">`&lt;!DOCTYPE html&gt;</span><br/>    &lt;html&gt;<br/>      &lt;head&gt;<br/>        &lt;meta charset=<span class="hellblau">"utf-8"</span><span class="violett">&gt;</span><br/>        &lt;title&gt;Node.js Demo&lt;/title&gt;<br/>      &lt;/head&gt;<br/>      &lt;body&gt;<br/>        &lt;h1 style=<span class="hellblau">"color:green"</span><span class="violett">&gt;Hello </span><span class="bold">${url.searchParams.get(<span class="hellblau">'name'</span><span class="violett">)}</span></span>&lt;/h1&gt;<br/>      &lt;/body&gt;<br/>    &lt;/html&gt;`<span class="schwarz">;</span><br/> <br/>  response.end(body);<br/>});<br/>server.listen(8080, () <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="magenta">console</span><span class="schwarz">.log(</span><br/>    <span class="violett">`Server is listening to http://localhost:${server.address().port}`</span><span class="schwarz">,</span><br/>  );<br/>}); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 3.13</b>    
            Manipulating Web Pages via Parameters</p>
            <p class="standard">The most important adaptation of the source code is that you read the URL the client has requested in the source code and write parts of it in the response. In the <samp class="listingcharacter listingcharacter">request</samp> object, the information about which URL the user specified in their browser is present in the <samp class="listingcharacter listingcharacter">url</samp> property. For example, if you assume that the user typed the URL <span class="italic">http://localhost:8080/?name=Besucher</span> in the address bar of their browser, the <samp class="listingcharacter listingcharacter">url</samp> property of the <samp class="listingcharacter listingcharacter">request</samp> object contains the value <samp class="listingcharacter listingcharacter">/?name=visitor</samp>.</p>
            <p class="standard">Your goal now is to output the <samp class="listingcharacter listingcharacter">Hello visitor</samp> string. To do this, you need to extract the string, in this case <samp class="listingcharacter listingcharacter">visitor</samp>, from the <samp class="listingcharacter listingcharacter">url</samp> property. You can do this, for example, by splitting the string with the JavaScript string function <samp class="listingcharacter listingcharacter">split</samp> at the equal sign and using the second element of the resulting array. However, this variant only works as long as the user passes only one parameter in the URL or this parameter is in the first position in the case of several parameters.</p>
            <p class="standard"><a id="p88"/>A better way to handle URLs is to use the WHATWG URL API, which is now a native part of the Node.js platform; therefore, no separate import is required for the URL class<a class="indexanchor" id="i03_78"/>. Among other things, this API enables you to parse URLs and thus break them down into their individual components. To do this, you must create a new instance of the URL class and pass the constructor the relative path of the call contained in the <samp class="listingcharacter listingcharacter">url</samp> property of the <samp class="listingcharacter listingcharacter">request</samp> object and the base URL of your application, in this case, <samp class="listingcharacter listingcharacter">http://localhost:8080/</samp>. The newly created object represents the requested URL with all of its components. You can find the individual query parameters that were transferred in the <samp class="listingcharacter listingcharacter">searchParams</samp> property. You can read these using the <samp class="listingcharacter listingcharacter">get</samp> method and transfer the desired parameter name. In our example, this is the <samp class="listingcharacter listingcharacter">name</samp> string. Here, the number and order of the parameters<a class="indexanchor" id="i03_79"/> in the URL no longer play any role either because you can access the value via the name of the parameter. Thus, you can then access the string the user has entered in the address bar of the browser via <samp class="listingcharacter listingcharacter">url.searchParams.get('name')</samp>. This means you have all the components you need to achieve your goal.</p>
            <p class="standard">After you’ve made the adjustments to the source code and restarted the web server, you can test the result by calling the page again. <span class="crossreference "><a href="03_002.html#f3.4">Figure 3.4</a></span> shows the result you get when you call the page <span class="italic">http://localhost:8080/?name=user</span>.</p>
            <div class="imagebox figure-type"><a href="img-f3.4.html" id="f3.4"><img alt="The First Dynamic Website on Node.js" id="img-f3.4" src="bilderklein/klein03_004.png"/></a></div>
            <p class="caption "><b>Figure 3.4</b>    
            The First Dynamic Website on Node.js</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>