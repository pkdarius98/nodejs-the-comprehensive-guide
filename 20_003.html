<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Socket Server" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Socket Server" name="description"/>
            <meta content="en" name="language"/>
            <title>Socket Server</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h20.3">20.3    TCP Sockets<a class="indexanchor" id="i20_26"/></h2>
        <p class="standard">You use TCP sockets primarily when you want to make sure that two applications residing on different systems communicate with each other. As with all socket solutions, you have maximum flexibility<a class="indexanchor" id="i20_27"/> when it comes to the question of which types of applications communicate with each other. The two endpoints of the connection—the client and the server—don’t necessarily have to be implementations in Node.js. For example, your server could be implemented in Java and the client in Node.js. But any other combination is also conceivable. Moreover, the two applications don’t need to run on the same system. However, you can still communicate between different applications within the same system. The prerequisite for this type of communication is that both computers on which the software is executed have an existing network connection and the respective remote system can be reached.</p>
        <p class="standard">If you transfer your data with TCP (<span class="url"><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">https://en.wikipedia.org/wiki/Transmission_Control_Protocol</a></span>), it will be fragmented<a class="indexanchor" id="i20_28"/>. For example, if you want to transfer a 2 MB file from one system to another, it will be split into several small parts, which will be automatically put back into the correct order on the target system. You won’t notice anything—neither the fragmentation nor the reassembling in your application. The maximum size of these individual fragments is 65,535 bytes, but it’s usually limited to <a id="p604"/>1,500 bytes by deeper protocols<a class="indexanchor" id="i20_29"/>. However, not only does TCP send the packages, it’s also responsible for securing the connection. This means that the protocol ensures that no packages are lost during transmission. Various mechanisms of TCP ensure that no data arrives at the recipient in a falsified form. The packages in which the data is sent over a TCP connection consist of a header and the message body. The header is divided into several fields, one of which consists of a checksum<a class="indexanchor" id="i20_30"/> over the package’s data and certain header fields. This checksum is created by the sender and used by the recipient to verify that the data package arrived without error. Another field contains a sequence number indicating the order of the packages. It’s used to reassemble the individual parts into a complete package. If the recipient notices an error in the checksum or that one of the packages is missing in the sequence, this error is handled and acted upon accordingly. These mechanisms ensure that communication via TCP can be described as reliable. <span class="crossreference "><a href="20_003.html#f20.4">Figure 20.4</a></span> summarizes the structure of a TCP header<a class="indexanchor" id="i20_31"/> for you.</p>
        <div class="imagebox figure-type"><a href="img-f20.4.html" id="f20.4"><img alt="Structure of a TCP Header (Source: https://en.wikipedia.org/wiki/Transmission_Control_Protocol)" id="img-f20.4" src="bilderklein/klein20_004.png"/></a></div>
        <p class="caption "><b>Figure 20.4</b>    
            Structure of a TCP Header (Source: <span class="url"><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">https://en.wikipedia.org/wiki/Transmission_Control_Protocol</a></span>)</p>
        <p class="standard">When using TCP sockets, you should note that a connection must always be established between the systems involved. This connection is established via the <span class="italic">handshake</span><a class="indexanchor" id="i20_32"/>. In doing so, the client sends a SYN package. The name has been derived from the term <span class="italic">synchronize</span> and means that the client and server synchronize for communication. The server responds with a SYN/ACK package<a class="indexanchor" id="i20_33"/>. This term stands for <span class="italic">synchronize acknowledgement</span>, meaning confirmation of synchronization. Finally, the client also sends an ACK<a class="indexanchor" id="i20_34"/> package, that is, an acknowledgement on its part as well. Once this three-way handshake is complete, the connection is considered established and can be used by both sides for communication. As a developer, you don’t come across the connection setup directly. However, you should keep this in mind when it comes to the performance of your application.</p>
        <p class="standard">Communication via the network always involves a certain overhead. Part of this consists of the handshake just described, which takes a certain amount of time. You have to accept further potential performance losses when the packages are sent through the individual network layers such as IP and Ethernet. To get from the data source to the <a id="p605"/>communication target, a package must take a certain path. On this path, in turn, there may be network nodes such as routers that redirect or check the package, which also takes time. TCP is a network protocol<a class="indexanchor" id="i20_35"/>, which means, unlike file system-based communication over Unix sockets, you no longer have full control over who connects to your application. Of course, there are also security mechanisms<a class="indexanchor" id="i20_36"/> such as firewalls that you can use to restrict access to a TCP server. With TCP, the work isn’t as simple as access control with Unix sockets. To limit the number of users of a service, you can, for example, use firewalls that only allow requests from certain sources.</p>
        
            <h3 class="t3" id="h20.3.1">20.3.1    Data Transfer<a class="indexanchor" id="i20_37"/></h3>
            <p class="standard">As a basis for the following section, we’ll use the basic implementation of a TCP server. <a class="indexanchor" id="i20_38"/><span class="crossreference "><a href="20_003.html#l20.9">Listing 20.9</a></span> shows the required source code for this.</p>
            <div class="listing " id="l20.9"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="schwarz">createServer((</span><span class="schwarz">socket</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  socket<span class="schwarz">.on(</span><span class="hellblau">'readable'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">const</span><span class="schwarz"> data </span><span class="dunkelblau">=</span><span class="schwarz"> socket</span><span class="schwarz">.read();</span><span class="schwarz"><br/></span>    <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">Buffer</span><span class="schwarz">.isBuffer(</span><span class="schwarz">data</span><span class="schwarz">))</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      <span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">data</span><span class="schwarz">.toString());</span><span class="schwarz"><br/></span>    <span class="schwarz">}</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">}).listen(8080,</span><span class="schwarz"> </span><span class="hellblau">'127.0.0.1'</span><span class="schwarz">);</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.9</b>    
            TCP Server (server.js)</p>
            <p class="standard">The functionality of this server is that it only opens a connection on the local machine on port <samp class="listingcharacter listingcharacter">8080</samp> and waits for incoming connections. If a connection is established, a call of <samp class="listingcharacter listingcharacter">console.log</samp> ensures that the transmitted information is output to the console. You can see the implementation of a TCP client<a class="indexanchor" id="i20_39"/> connecting to this server in <span class="crossreference "><a href="20_003.html#l20.10">Listing 20.10</a></span>.</p>
            <div class="listing " id="l20.10"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> connect </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> port </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">8080;</span><span class="schwarz"><br/></span><span class="rot">const</span><span class="schwarz"> host </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="hellblau">'127.0.0.1'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> client </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">connect({</span><span class="schwarz"> port</span><span class="schwarz">,</span><span class="schwarz"> host </span><span class="schwarz">},</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  client<span class="schwarz">.end(</span><span class="hellblau">'Hello Server!'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.10</b>    
            TCP Client (client.js)</p>
            <p class="standard">In this example, the client does nothing but connect through the TCP port previously opened by the server and send a message. After that, the application gets closed. The <a id="p606"/>server process continues to run and accept incoming connections. The console output of the server consists of the string, <samp class="listingcharacter listingcharacter">Hello Server!</samp>. In the next step, you’ll extend this simple example so that the client sends a file to the server.</p>
        
        
            <h3 class="t3" id="h20.3.2">20.3.2    File Transfer<a class="indexanchor" id="i20_40"/></h3>
            <p class="standard">With a few adjustments to the source code from <span class="crossreference "><a href="20_003.html#l20.9">Listing 20.9</a></span> and <span class="crossreference "><a href="20_003.html#l20.10">Listing 20.10</a></span>, you can implement a simple file transfer (see <span class="crossreference "><a href="20_003.html#l20.11">Listing 20.11</a></span>).</p>
            <div class="listing " id="l20.11"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> writeFile </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'fs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="schwarz">createServer((</span><span class="schwarz">socket</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">let</span><span class="schwarz"> file </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="hellblau">''</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/>  socket<span class="schwarz">.on(</span><span class="hellblau">'readable'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    file <span class="dunkelblau">+=</span><span class="schwarz"> socket</span><span class="schwarz">.read();</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span> <br/>  socket<span class="schwarz">.on(</span><span class="hellblau">'end'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">const</span><span class="schwarz"> input </span><span class="dunkelblau">=</span><span class="schwarz"> Buffer</span><span class="schwarz">.from(</span><span class="schwarz">file</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'base64'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>    <span class="schwarz">writeFile(</span><span class="hellblau">'dest.png'</span><span class="schwarz">,</span><span class="schwarz"> input</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{});</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">}).listen(8080,</span><span class="schwarz"> </span><span class="hellblau">'127.0.0.1'</span><span class="schwarz">);</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.11</b>    
            TCP Server for File Transfer (server.js)</p>
            <p class="standard">The first difference from <span class="crossreference "><a href="20_003.html#l20.9">Listing 20.9</a></span> is that, in this case, you need the <samp class="listingcharacter listingcharacter">fs</samp> module in addition to the <samp class="listingcharacter listingcharacter">net</samp> module to save the transferred file in the file system. The receipt of data in the callback function is divided into several steps. This means that during data reception, several packages are accepted and assembled accordingly. If you assume an image file with a size of about 128 KB, only about 50 KB will be received with a call of the <samp class="listingcharacter listingcharacter">read</samp> method. For this reason, you need to collect the data in a variable, in this case, <samp class="listingcharacter listingcharacter">file</samp>, and you can continue processing only after the operation is finished in the callback function of the <samp class="listingcharacter listingcharacter">end</samp> event. Here, the received data is recoded using a <samp class="listingcharacter listingcharacter">buffer</samp> object and stored in a file named <span class="italic">dest.png</span>. This encoding<a class="indexanchor" id="i20_41"/> takes place so that the image, which is a binary<a class="indexanchor" id="i20_42"/> file, can be easily transferred from the client to the server, where it can then be used appropriately. <span class="crossreference "><a href="20_003.html#l20.12">Listing 20.12</a></span> contains the source code for the client, which sends an image to the server.</p>
            <div class="listing " id="l20.12"><pre><span class="rot">const</span><span class="schwarz"> net </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">require(</span><span class="hellblau">'net'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="rot">const</span><span class="schwarz"> fs </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">require(</span><span class="hellblau">'fs'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><br/>fs<span class="schwarz">.readFile(</span><span class="hellblau">'logo.png'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">err</span><span class="schwarz">,</span><span class="schwarz"> data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">const</span><span class="schwarz"> client </span><span class="dunkelblau">=</span><span class="schwarz"> net</span><span class="schwarz">.connect({</span><span class="schwarz"> port</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="schwarz">8080,</span><span class="schwarz"> host</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">'127.0.0.1'</span><span class="schwarz"> </span><span class="schwarz">},</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span><a id="p607"/>    client<span class="schwarz">.end(</span><span class="schwarz">data</span><span class="schwarz">.toString(</span><span class="hellblau">'base64'</span><span class="schwarz">));</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.12</b>    
            TCP Client for Data Transfer (client.js)</p>
            <p class="standard">In the client, you also need the <samp class="listingcharacter listingcharacter">fs</samp> module to read the content of the file to be sent from the file system. Inside the callback function of the <samp class="listingcharacter listingcharacter">readFile</samp> function, you establish the connection to the server and send the contents of the file using the <samp class="listingcharacter listingcharacter">end</samp> method of the open socket. As mentioned in the context of the server, you need to make sure that the data is sent in a format that allows you to transfer the file without loss or errors, so that it can still be used after the transfer. For this purpose, you can use Base64 encoding<a class="indexanchor" id="i20_43"/>. It’s often used on the web when it comes to transmitting files, such as sending emails with attachments.</p>
            <p class="standard">Once you’ve made the adjustments to the client and server, you can start the server first so that the TCP port is opened, and then the client. The client then reads the <span class="italic">logo.png</span> file from the file system and transmits it Base64-encoded to the server. The server receives the individual components of the file, assembles them, decodes the entire package, and stores the result again on the file system. The <samp class="listingcharacter listingcharacter">net</samp> module provides even more options to intervene in a controlling manner, in addition to its pure data transmission functionality. The following sections will introduce you to further concepts of sockets.</p>
        
        
            <h3 class="t3" id="h20.3.3">20.3.3    Flow Control<a class="indexanchor" id="i20_44"/></h3>
            <p class="standard">You can transfer large amounts of data through a socket connection. This holds true for both TCP sockets and file system-based solutions such as Unix sockets<a class="indexanchor" id="i20_45"/> and Windows pipes<a class="indexanchor" id="i20_46"/>. In the stream API<a class="indexanchor" id="i20_47"/> of Node.js in versions prior to 0.10, it was possible to control the data flow. Typical situations where you might need these features could be that data is arriving faster than you can process it, or that you’re writing data to a stream faster than it can deliver the data.</p>
            <p class="standard">The <samp class="listingcharacter listingcharacter">write</samp> method of streams always returns a value regardless of whether they are network-based systems or file system-based streams. This value indicates whether the data has already been sent or cached in memory. For readable data streams<a class="indexanchor" id="i20_48"/>, the two methods <samp class="listingcharacter listingcharacter">pause</samp> and <samp class="listingcharacter listingcharacter">resume</samp> exist. The <samp class="listingcharacter listingcharacter">pause</samp> method makes sure that no further <samp class="listingcharacter listingcharacter">data</samp> events get triggered. The <samp class="listingcharacter listingcharacter">resume</samp> method enables you to reactivate the sending of the data stream and allows further <samp class="listingcharacter listingcharacter">data</samp> events to occur. The source code in <span class="crossreference "><a href="20_003.html#l20.13">Listing 20.13</a></span> shows how these mechanisms can be combined within an application.</p>
            <div class="listing " id="l20.13"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> connect</span><span class="schwarz">,</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> client </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">connect({</span><span class="schwarz"> host</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">'127.0.0.1'</span><span class="schwarz">,</span><span class="schwarz"> port</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="schwarz">8080</span><span class="schwarz"> </span><span class="schwarz">},</span><span class="schwarz"> </span><br/>  <span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span><a id="p608"/>    <span class="schwarz">createServer((</span><span class="schwarz">socket</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      client<span class="schwarz">.on(</span><span class="hellblau">'data'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>       <span class="gruen"> // calculate</span><span class="schwarz"><br/></span> <br/>        <span class="rot">const</span><span class="schwarz"> flushed </span><span class="dunkelblau">=</span><span class="schwarz"> socket</span><span class="schwarz">.write(</span><span class="schwarz">data</span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/>        <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="dunkelblau">!</span><span class="schwarz">flushed</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>          client<span class="schwarz">.pause();</span><span class="schwarz"><br/></span>        <span class="schwarz">}</span><span class="schwarz"><br/></span>      <span class="schwarz">});</span><span class="schwarz"><br/></span> <br/>      socket<span class="schwarz">.on(</span><span class="hellblau">'drain'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>        client<span class="schwarz">.resume();</span><span class="schwarz"><br/></span>      <span class="schwarz">});</span><span class="schwarz"><br/></span>    <span class="schwarz">}</span><span class="schwarz"><br/></span>  <span class="schwarz">).listen(8181,</span><span class="schwarz"> </span><span class="hellblau">'127.0.0.1'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.13</b>    
            Flow Control in Sockets</p>
            <p class="standard">In <span class="crossreference "><a href="20_003.html#l20.13">Listing 20.13</a></span>, two streams are combined with each other. First, a readable stream is created as a client on TCP port <samp class="listingcharacter listingcharacter">8080</samp>. A TCP server<a class="indexanchor" id="i20_49"/> on port <samp class="listingcharacter listingcharacter">8181</samp> is then created as a writable stream in the callback function of the <samp class="listingcharacter listingcharacter">connect</samp> event. Once data arrives at port <samp class="listingcharacter listingcharacter">8080</samp>, it can be processed and eventually forwarded to the clients that have connected to the server on port <samp class="listingcharacter listingcharacter">8181</samp>. After each write action, a check is made to see if the data was successfully written to the stream. If it wasn’t, and the data has been cached in memory instead, the reading stream is paused at port <samp class="listingcharacter listingcharacter">8080</samp>. As soon as the <samp class="listingcharacter listingcharacter">drain</samp> event gets triggered, which signals that it’s possible to write to the stream again, the readable data stream continues. In this way, you prevent the write buffer<a class="indexanchor" id="i20_50"/> from overflowing and thus control the data flow in a very simple way. With Node.js 0.10, the stream API that underlies all socket servers has been revised. Although the methods described here still work, you should use the <samp class="listingcharacter listingcharacter">readable</samp> event instead of the <samp class="listingcharacter listingcharacter">data</samp> event, and then use the <samp class="listingcharacter listingcharacter">read</samp> method to read the data.</p>
            <p class="standard">As now the two methods <samp class="listingcharacter listingcharacter">pause</samp> and <samp class="listingcharacter listingcharacter">resume</samp> are omitted too, you need a new means of controlling the flow. For this purpose, you can simply call the <samp class="listingcharacter listingcharacter">read</samp> method as many times as you can handle the data you receive. This method accepts an integer as a value, which specifies how many bytes at least must be present in the read buffer to be output. If no data is available or less than specified, <samp class="listingcharacter listingcharacter">read</samp> returns the value <samp class="listingcharacter listingcharacter">null</samp>. For the streams presented here, a number of abstract interfaces exist within Node.js, which will be described in the following sections.</p>
        
        
            <h3 class="t3" id="h20.3.4">20.3.4    <a id="p609"/>Duplex<a class="indexanchor" id="i20_51"/></h3>
            <p class="standard">You’ve already seen that you can both write to and read from a TCP stream. In Node.js, this type of stream is referred to as a duplex stream. In addition to providing the <samp class="listingcharacter listingcharacter">read</samp> method, a duplex stream also allows for write operations using the <samp class="listingcharacter listingcharacter">write</samp> method. If you want to implement your own duplex stream, you must override the <samp class="listingcharacter listingcharacter">_read</samp> and <samp class="listingcharacter listingcharacter">_write</samp> methods, which are responsible for reading and writing, respectively. If you want to connect two streams to each other as shown in <span class="crossreference "><a href="20_003.html#l20.13">Listing 20.13</a></span>, you can use the pipes concept.</p>
        
        
            <h3 class="t3" id="h20.3.5">20.3.5    Pipe<a class="indexanchor" id="i20_52"/></h3>
            <p class="standard">In Node.js streams, a pipe refers to the connection of a readable stream to a writable stream. The <samp class="listingcharacter listingcharacter">pipe</samp> method belongs to the readable streams. It accepts an instance of a writable stream and an object with configuration directives. You can specify <samp class="listingcharacter listingcharacter">close: false</samp> as the configuration here. This configuration ensures that the writable data stream isn’t automatically terminated as soon as the readable data stream has ended. This allows you to write data to the data stream even after the readable data stream has ended. In the simplest case, such a pipe looks like the one shown in <span class="crossreference "><a href="20_003.html#l20.14">Listing 20.14</a></span>.</p>
            <div class="listing " id="l20.14"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> connect </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> host </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="hellblau">'127.0.0.1'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> writable </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">connect({</span><span class="schwarz"> host</span><span class="schwarz">,</span><span class="schwarz"> port</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="schwarz">8181</span><span class="schwarz"> </span><span class="schwarz">},</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">const</span><span class="schwarz"> readable </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">connect({</span><span class="schwarz"> host</span><span class="schwarz">,</span><span class="schwarz"> port</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="schwarz">8080</span><span class="schwarz"> </span><span class="schwarz">},</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    readable<span class="schwarz">.pipe(</span><span class="schwarz">writable</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.14</b>    
            Simple Pipe</p>
            <p class="standard">When implementing a pipe in your application, like the one in <span class="crossreference "><a href="20_003.html#l20.14">Listing 20.14</a></span>, you must first open the writable data stream, that is, the target of the pipe. Once the connection has been established, you can open the readable data stream within the callback function. In the callback function of the <samp class="listingcharacter listingcharacter">connect</samp> event, you now use the <samp class="listingcharacter listingcharacter">pipe</samp> method to connect both data streams. As soon as data is available on the readable stream, it’s written directly to the writable stream.</p>
            <p class="standard">You should note that accessing the data isn’t easy. If you’ve connected<a class="indexanchor" id="i20_53"/> the data streams via <samp class="listingcharacter listingcharacter">pipe</samp>, you can no longer retrieve the data via <samp class="listingcharacter listingcharacter">read</samp>. Depending on where you place the call of the <samp class="listingcharacter listingcharacter">read</samp> method, the data is either caught before it’s written to the other stream, or the data is forwarded and removed from the buffer before you attempt to read it via <samp class="listingcharacter listingcharacter">read</samp>. If you want to make sure that you can process the data and forward it to <a id="p610"/>another stream at the same time, you have to take care of that yourself. This means you can’t use the <samp class="listingcharacter listingcharacter">pipe</samp> method in this case, but must read the data from the readable data stream via <samp class="listingcharacter listingcharacter">read</samp> and write it to the writable data stream by calling <samp class="listingcharacter listingcharacter">write</samp>.</p>
            <p class="standard">In addition to network-based TCP sockets, there is also another way of exchanging data over the network between two applications: UDP.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>