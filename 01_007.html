<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Basic Principles" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Basic Principles" name="description"/>
            <meta content="en" name="language"/>
            <title>Basic Principles</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h1.7">1.7    Libraries<a class="indexanchor" id="i01_115"/> around the Engine</h2>
        <p class="standard">The JavaScript engine alone doesn’t make a platform yet. For Node.js to handle all requirements such as event handling, I/O, or support functions such as Domain Name System (DNS) resolution<a class="indexanchor" id="i01_116"/> or encryption, additional functionality is required. This is <a id="p48"/>implemented with the help of additional libraries. For many tasks that a platform such as Node.js has to deal with, ready-made and established solutions already exist. For this reason, Dahl decided to build the Node.js platform on top of a set of external libraries and fill in the gaps he felt weren’t adequately covered by any existing solution with his own implementations. The advantage of this strategy is that you don’t have to reinvent the solutions for standard problems; you can fall back on tried and tested libraries.</p>
        <p class="standard">A prominent example that is also built on this strategy is the Unix operating system. In this context, developers should stick to the following principle: focus only on the actual problem, solve it as well as possible, and use existing libraries for everything else. Most command-line programs in the Unix area implement this philosophy. Once a solution has established itself, it can be used in other applications for similar problems. This in turn has the advantage that improvements in the algorithm only have to be made at one central point. The same applies to bug fixes. If an error occurs in DNS resolution, it’s fixed once, and the solution works in all places where the library is used. But that also leads to the flip side of the coin: the libraries on which the platform is built must exist. Node.js solves this problem in that it’s built on only a small set of libraries that must be provided by the operating system. But these dependencies rather consist of basic functions such as the GNU Compiler Collection (GCC) runtime library<a class="indexanchor" id="i01_117"/> or the standard C library<a class="indexanchor" id="i01_118"/>. The remaining dependencies, such as <samp class="listingcharacter listingcharacter">zlib</samp> or <samp class="listingcharacter listingcharacter">http_parser</samp>, are included in the source code.</p>
        
            <h3 class="t3" id="h1.7.1">1.7.1    Event Loop<a class="indexanchor" id="i01_119"/></h3>
            <p class="standard">Client-side JavaScript contains many elements of an event-driven architecture. Most user interactions cause events that are responded to with appropriate function calls. By using various features such as first-class functions and anonymous functions in JavaScript, you can implement entire applications based on an event-driven architecture<a class="indexanchor" id="i01_120"/><a class="indexanchor" id="i01_121"/>. The term <span class="italic">event-driven</span> means that objects don’t communicate directly with each other via function calls; instead, events are used for this communication. Event-driven programming is therefore primarily used to control the program flow. In contrast to the classical approach, where the source code is run through linearly, here functions are executed when certain events occur. A small example in <span class="crossreference "><a href="01_007.html#l1.2">Listing 1.2</a></span> illustrates this approach.</p>
            <div class="listing " id="l1.2"><pre>myObj<span class="schwarz">.on(</span><span class="hellblau">'myEvent'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">data</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"><br/></span>myObj<span class="schwarz">.emit(</span><span class="hellblau">'myEvent'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'Hello World'</span><span class="schwarz">);</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 1.2</b>    
            Event-Driven Development in Node.js</p>
            <p class="standard">You can use the <samp class="listingcharacter listingcharacter">on</samp> method of an object that you derive from <samp class="listingcharacter listingcharacter">events.EventEmitter</samp>, a component of the Node.js platform, to define which function you want to use to <a id="p49"/>respond to each event. This pattern is referred to as a publish-subscribe pattern<a class="indexanchor" id="i01_122"/>. Objects can thus register with an event emitter and then be notified when the event occurs. The first argument of the <samp class="listingcharacter listingcharacter">on</samp> method is the name of the event in the form of a string to respond to. The second argument consists of a callback function that is implemented as an arrow function in this case<a class="indexanchor" id="i01_123"/>, which is executed once the event occurs. Thus, the function call of the <samp class="listingcharacter listingcharacter">on</samp> method does nothing more than register the callback function the first time it’s executed. Later in the script, the <samp class="listingcharacter listingcharacter">emit</samp> method is called on <samp class="listingcharacter listingcharacter">myObj</samp>. This ensures that all callback functions registered by the <samp class="listingcharacter listingcharacter">on</samp> method are executed.</p>
            <p class="standard">What works in this example with a custom object is used by Node.js to perform a variety of asynchronous<a class="indexanchor" id="i01_124"/> tasks. However, the callback functions aren’t run in parallel, but sequentially. The single-threaded approach of Node.js creates the problem that only one operation can be executed at a time. Time-consuming read or write operations in particular would block the entire execution of the application. For this reason, all read and write operations are outsourced using the event loop. This allows the available thread to be exploited by the application’s code. Once a request is made to an external resource in the source code, it’s passed to the event loop. A callback is registered for the request that forwards the request to the operating system; Node.js then regains control and can continue executing the application. Once the external operation is complete, the result is passed back to the event loop. An event occurs and the event loop ensures that the associated callback functions are executed. <span class="crossreference "><a href="01_007.html#f1.4">Figure 1.4</a></span> shows how the event loop works.</p>
            <div class="imagebox figure-type"><a href="img-f1.4.html" id="f1.4"><img alt="Event Loop" id="img-f1.4" src="bilderklein/klein01_004.png"/></a></div>
            <p class="caption "><b>Figure 1.4</b>    
            Event Loop</p>
            <p class="standard">The original event loop used in Node.js is based on <samp class="listingcharacter listingcharacter">libev</samp><a class="indexanchor" id="i01_125"/>, a library written in C that stands for high performance and a wide range of features. <samp class="listingcharacter listingcharacter">libev</samp> is based on the approaches of <samp class="listingcharacter listingcharacter">libevent</samp><a class="indexanchor" id="i01_126"/> but has a higher performance rate, as evidenced by various benchmarks. Even an improved version of <samp class="listingcharacter listingcharacter">libevent</samp>—<samp class="listingcharacter listingcharacter">libevent2</samp><a class="indexanchor" id="i01_127"/>—doesn’t match the performance of <samp class="listingcharacter listingcharacter">libev</samp>. However, for compatibility reasons, the event loop was abstracted to achieve better portability to other platforms.</p>
        
        
            <h3 class="t3" id="h1.7.2">1.7.2    <a id="p50"/>Input and Output<a class="indexanchor" id="i01_128"/><a class="indexanchor" id="i01_129"/></h3>
            <p class="standard">The event loop alone in combination with the V8 engine allows the execution of JavaScript, but there is still no possibility of interacting with the operating system directly in the form of read or write operations<a class="indexanchor" id="i01_130"/><a class="indexanchor" id="i01_131"/> on the file system<a class="indexanchor" id="i01_132"/>. In the implementation of server-side applications, accesses to the file system play an important role. For example, the configuration of an application is often outsourced to a separate configuration file. This configuration must be read by the application from the file system. However, templates, which are dynamically filled with values and then sent to the client, are also usually available as separate files. Both reading and writing information to files is often a requirement for a server-side JavaScript application. Logging within an application is another common area of usage of write accesses to the file system. Here, different types of events within the application are logged to a log file. Depending on where the application is executed, only fatal errors, warnings, or even runtime information is written. Write accesses are also used for persisting information. During runtime of an application, usually through the interaction of users and various computations, information is generated that needs to be captured for later reuse.</p>
            <p class="standard">Node.js uses the C library <samp class="listingcharacter listingcharacter">libeio</samp><a class="indexanchor" id="i01_133"/> for these tasks. It ensures that the write and read operations can take place asynchronously, and thus the library works very closely with the event loop. However, the features of <samp class="listingcharacter listingcharacter">libeio</samp> aren’t limited to write and read access to the file system; rather, they offer considerably more possibilities to interact with the file system. These options range from reading file information (e.g., size, creation date, or access date) to managing directories (i.e., creating or removing them) to modifying access rights. Similar to the event loop, during the course of its development, this library was separated from the actual application by an abstraction layer.</p>
            <p class="standard">To access the file system, Node.js provides its own module, the file system module. This module enables you to address the interfaces of <samp class="listingcharacter listingcharacter">libeio</samp> and thus represents a very lightweight wrapper around <samp class="listingcharacter listingcharacter">libeio</samp>.</p>
        
        
            <h3 class="t3" id="h1.7.3">1.7.3    libuv<a class="indexanchor" id="i01_134"/></h3>
            <p class="standard">The two libraries you’ve encountered so far are related to Linux. However, Node.js was supposed to become a platform independent of the operating system. For this reason, the <samp class="listingcharacter listingcharacter">libuv</samp> library was introduced in version 0.6 of Node.js. This library is primarily used to abstract differences between different operating systems. Consequently, using <samp class="listingcharacter listingcharacter">libuv</samp> makes it possible for Node.js to run on Windows<a class="indexanchor" id="i01_135"/> systems as well. The structure without <samp class="listingcharacter listingcharacter">libuv</samp>, as it was used in Node.js up to version 0.6, looks like this: the core is the V8 engine; it’s supplemented by <samp class="listingcharacter listingcharacter">libev</samp> and <samp class="listingcharacter listingcharacter">libeio</samp> with the event loop and the asynchronous file system access. With <samp class="listingcharacter listingcharacter">libuv</samp>, these two libraries are no longer directly integrated into the platform, but are abstracted.</p>
            <p class="standard">For Node.js to work on Windows, it’s necessary to provide the core components<a class="indexanchor" id="i01_136"/> for Windows platforms. The V8 engine isn’t a problem here; it has been working in the Chrome browser<a id="p51"/> for many years on Windows without any problems. However, it gets more difficult with the event loop and asynchronous file system operations. Some components of <samp class="listingcharacter listingcharacter">libev</samp> would need to be rewritten when running on Windows. In addition, <samp class="listingcharacter listingcharacter">libev</samp> is based on native implementations of the operating system of the <samp class="listingcharacter listingcharacter">select</samp> function, but, on Windows, a variant optimized for the operating system is available in the form of <samp class="listingcharacter listingcharacter">IOCP</samp><a class="indexanchor" id="i01_137"/>. To avoid having to create different versions of Node.js for the different operating systems, the developers decided to include an abstraction layer with <samp class="listingcharacter listingcharacter">libuv</samp> that allows <samp class="listingcharacter listingcharacter">libev</samp> to be used for Linux systems and <samp class="listingcharacter listingcharacter">IOCP</samp> for Windows. With <samp class="listingcharacter listingcharacter">libuv</samp>, some core concepts of Node.js have been adapted. For example, we no longer speak of events, but of operations. An operation is passed to the <samp class="listingcharacter listingcharacter">libuv</samp> component; within <samp class="listingcharacter listingcharacter">libuv</samp>, the operation is passed to the underlying infrastructure, that is, <samp class="listingcharacter listingcharacter">libev</samp> or <samp class="listingcharacter listingcharacter">IOCP</samp>, respectively. Thus, the Node.js interface remains unchanged regardless of the operating system used.</p>
            <p class="standard"><samp class="listingcharacter listingcharacter">libuv</samp> is responsible for managing all asynchronous I/O operations<a class="indexanchor" id="i01_138"/>. This means that all access to the file system, whether read or write access, is performed via <samp class="listingcharacter listingcharacter">libuv</samp>’s interfaces. For this purpose, <samp class="listingcharacter listingcharacter">libuv</samp> provides the <samp class="listingcharacter listingcharacter">uv_fs_</samp> functions, as well as timers, that is, time-dependent calls, and asynchronous Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) connections run via <samp class="listingcharacter listingcharacter">libuv</samp>. In addition to these basic functionalities, <samp class="listingcharacter listingcharacter">libuv</samp> manages complex features such as creating and spawning child processes and thread pool<a class="indexanchor" id="i01_139"/> scheduling, an abstraction that allows tasks to be completed in separate threads and callbacks to be bound to them. Using an abstraction layer such as <samp class="listingcharacter listingcharacter">libuv</samp> is an important building block for the wider adoption of Node.js and makes the platform a little less dependent on the system.</p>
        
        
            <h3 class="t3" id="h1.7.4">1.7.4    Domain Name System<a class="indexanchor" id="i01_140"/></h3>
            <p class="standard">The roots of Node.js can be found on the internet. When you’re on the internet, you’ll quickly encounter the problem of name resolution. Actually, all servers on the internet are addressed by their IP address. In Internet Protocol version 4<a class="indexanchor" id="i01_141"/> (IPv4), the address is a 32-bit number represented in four blocks of 8 bits each. In IPv6, the addresses have a size of 128 bits and are divided into eight blocks of hexadecimal numbers. You rarely want to work directly with these cryptic addresses, especially if a dynamic assignment via Dynamic Host Configuration Protocol (DHCP) is added. The solution to this is the Domain Name System (DNS). The DNS is a service for name resolution on the web that ensures domain names are converted into IP addresses. There is also the possibility of reverse resolution, where an IP address is translated into a domain name. If you want to connect a web service or read a webpage in your Node.js application, DNS is used here as well.</p>
            <p class="standard">Internally, Node.js doesn’t handle the name resolution itself but passes the respective requests to the C-Ares library<a class="indexanchor" id="i01_142"/>. This applies to all methods of the <samp class="listingcharacter listingcharacter">dns</samp> module except for <samp class="listingcharacter listingcharacter">dns.lookup</samp>, which uses the operating system’s own <samp class="listingcharacter listingcharacter">getaddrinfo</samp> function. This exception is caused by the fact that <samp class="listingcharacter listingcharacter">getaddrinfo</samp> is more constant in its responses than the C-Ares library, which, by itself, is a lot more performant than <samp class="listingcharacter listingcharacter">getaddrinfo</samp>.</p>
        
        
            <h3 class="t3" id="h1.7.5">1.7.5    <a id="p52"/>Crypto<a class="indexanchor" id="i01_143"/></h3>
            <p class="standard">The crypto component of the Node.js platform provides you with several encryption options for development<a class="indexanchor" id="i01_144"/> purposes. This component is based on OpenSSL<a class="indexanchor" id="i01_145"/>. This means that this software must be installed on your system if you want to encrypt data. The <samp class="listingcharacter listingcharacter">crypto</samp> module allows you to encrypt data with different algorithms as well as create digital signatures within your application. The entire system is based on private and public keys. The private key, as the name implies, is for you and your application only. The public key is available to your communication partners. If content is to be encrypted, this is done with the public key. The data can then only be decrypted with your private key. The same applies to the digital signature of data. Here, your private key is used to generate such a signature. The recipient of a message can then use the signature and your public key to determine whether the message originated from you and hasn’t been changed.</p>
        
        
            <h3 class="t3" id="h1.7.6">1.7.6    Zlib<a class="indexanchor" id="i01_146"/></h3>
            <p class="standard">When creating web applications, as a developer, you need to take into consideration the resources of your users and your own server environment. For example, the available bandwidth or free memory for data can be a limitation. To address such cases, the Node.js platform contains the <samp class="listingcharacter listingcharacter">zlib</samp> component. With its help, you can compress data and decompress it again when you want to process it. For data compression,<a class="indexanchor" id="i01_147"/> you can use two algorithms, Deflate<a class="indexanchor" id="i01_148"/> and Gzip<a class="indexanchor" id="i01_149"/>. Node.js treats the data that serves as input to the algorithms as streams.</p>
            <p class="standard">Node.js doesn’t implement the compression algorithms itself, but instead uses the established <samp class="listingcharacter listingcharacter">zlib</samp> and passes the requests on in each case. The <samp class="listingcharacter listingcharacter">zlib</samp> module of Node.js simply provides a lightweight wrapper for the underlying Gzip, Deflate/Inflate, and Brotli algorithmns and ensures that I/O streams are handled correctly.</p>
        
        
            <h3 class="t3" id="h1.7.7">1.7.7    HTTP Parser<a class="indexanchor" id="i01_150"/></h3>
            <p class="standard">As a platform for web applications, Node.js must be able to handle not only streams, compressed data, and encryption but also HTTP. Because parsing HTTP<a class="indexanchor" id="i01_151"/> is a laborious procedure, the HTTP parser handling this task has been outsourced to a separate project and is now included by the Node.js platform. Like the other external libraries, the HTTP parser is written in C and serves as a high-performance tool that reads both HTTP requests and responses. As a developer, this means you can use the HTTP parser to read, for example, the various information in the HTTP header<a class="indexanchor" id="i01_152"/> or the text of the message itself.</p>
            <p class="standard">The primary goal of developing Node.js is to provide a performant platform for web applications. To meet this requirement, Node.js is built on a modular structure. This allows the inclusion of external libraries such as the previously described <samp class="listingcharacter listingcharacter">libuv</samp> or the <a id="p53"/>HTTP parser. The modular approach continues through the internal modules of the Node.js platform and extends to the extensions you create for your own application. </p>
            <p class="standard">Throughout this book, you’ll learn about the different capabilities and technologies that the Node.js platform provides for developing your own applications. We’ll start with an introduction to the module system of Node.js.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>