<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="GraphQL" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - GraphQL" name="description"/>
            <meta content="en" name="language"/>
            <title>GraphQL</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h11.4">11.4    Reading Data via the Interface<a class="indexanchor" id="i11_17"/></h2>
        <p class="standard">To obtain read access to the GraphQL interface, you must first extend the schema<a class="indexanchor" id="i11_18"/>. You need a new data type called <samp class="listingcharacter listingcharacter">movie</samp> that maps the structure of a record. Then, you must define a <samp class="listingcharacter listingcharacter">movie</samp> field that you can query. <span class="crossreference "><a href="11_004.html#l11.5">Listing 11.5</a></span> shows the new version of the schema.</p>
        <div class="listing " id="l11.5"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> buildSchema </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'graphql'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> expressGraphql </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express-graphql'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> schema </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">buildSchema(</span><span class="violett">`</span><br/>  <span class="bold"><samp class="listingcharacter listingcharacter">type Movie {<br/>    id: Int!<br/><a id="p343"/>    title: String!<br/>    year: Int<br/>    public: Int<br/>    user: Int<br/>  }<br/> </samp></span><br/>  type Query {<br/>    greet: String<br/>    <span class="bold"><samp class="listingcharacter listingcharacter">movie: [Movie]</samp></span><br/>  }<br/>`<span class="schwarz">);</span><br/> <br/><span class="rot">const</span><span class="schwarz"> rootValue </span><span class="dunkelblau">=</span><span class="schwarz"> {...};</span><br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">default</span><span class="schwarz"> expressGraphql.graphqlHTTP({...} </span><span class="schwarz"/></pre></div>
        <p class="caption "><b>Listing 11.5</b>    
            Extending the Schema with the "Movie" Type</p>
        <p class="standard">As you’ve already seen, GraphQL has its own type system<a class="indexanchor" id="i11_19"/>, which is quite similar to the one you already know from TypeScript—but there are some differences. For example, GraphQL distinguishes between the number types <samp class="listingcharacter listingcharacter">Int</samp><a class="indexanchor" id="i11_20"/> and <samp class="listingcharacter listingcharacter">Float</samp><a class="indexanchor" id="i11_21"/>, that is, between integers and floating point numbers. Other aspects are similar to those in TypeScript, such as the <samp class="listingcharacter listingcharacter">string</samp><a class="indexanchor" id="i11_22"/> and <samp class="listingcharacter listingcharacter">Boolean</samp><a class="indexanchor" id="i11_23"/> types. GraphQL also provides for the <samp class="listingcharacter listingcharacter">ID</samp> type for unique identifiers such as the <samp class="listingcharacter listingcharacter">id</samp> field. The problem with this data type is that it’s interpreted as a <samp class="listingcharacter listingcharacter">string</samp>, and a numeric ID would thus be converted into a character string, which is why we use the <samp class="listingcharacter listingcharacter">Int</samp> type for our example. The exclamation mark after a type indicates that this is a required field.</p>
        <p class="standard">The extension of the schema alone doesn’t help you yet. Any change to the schema usually requires an adjustment to the resolver functions as well. <span class="crossreference "><a href="11_004.html#l11.6">Listing 11.6</a></span> shows how you should extend the <samp class="listingcharacter listingcharacter">rootValue</samp><a class="indexanchor" id="i11_24"/> object that contains the resolvers.</p>
        <div class="listing " id="l11.6"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> buildSchema </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'graphql'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> expressGraphql </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express-graphql'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="rot">import</span><span class="schwarz"> { getAll } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./movie/model.js'</span><span class="schwarz">;</span><br/> </samp></span><br/><span class="rot">const</span><span class="schwarz"> schema </span><span class="dunkelblau">=</span><span class="schwarz"> buildSchema(</span><span class="violett">`...`</span><span class="schwarz">);</span><br/> <br/><span class="rot">const</span><span class="schwarz"> rootValue </span><span class="dunkelblau">=</span><span class="schwarz"> {</span><br/>  greet() {<br/>    <span class="rot">return</span><span class="schwarz"> </span><span class="hellblau">'Hello GraphQL'</span><span class="schwarz">;</span><br/>  },<br/>  <span class="bold"><samp class="listingcharacter listingcharacter">movie() {<br/>    <span class="rot">return</span><span class="schwarz"> getAll({ userId: 1 });</span><br/>  },</samp></span><br/><a id="p344"/>};<br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">default</span><span class="schwarz"> expressGraphql.graphqlHTTP({...} </span><span class="schwarz"/></pre></div>
        <p class="caption "><b>Listing 11.6</b>    
            Extending the Resolver Functions (graphql.js)</p>
        <p class="standard">With this extension, you benefit from the fact that the application is already fully functional with its REST interface and that the GraphQL interface is merely an add-on on top of the application’s business logic. So, you can reuse all the routines you implemented for the REST interface almost unchanged at this point. Note that you currently haven’t implemented any authentication features, so you still need to define the ID of the user, in this case, the value <samp class="listingcharacter listingcharacter">1</samp>, as fixed when calling the <samp class="listingcharacter listingcharacter">getAll</samp> function. With these adjustments, after restarting the application, you can again query your interface with GraphiQL and see the results from the database, as shown in <span class="crossreference "><a href="11_004.html#f11.2">Figure 11.2</a></span>.</p>
        <div class="imagebox figure-type"><a href="img-f11.2.html" id="f11.2"><img alt="GraphQL Query of the Data from the Database" id="img-f11.2" src="bilderklein/klein11_002.png"/></a></div>
        <p class="caption "><b>Figure 11.2</b>    
            GraphQL Query of the Data from the Database</p>
        <p class="standard">At this point, two things are worth noting. First, not only does GraphQL support synchronous operations but also asynchronous operations based on promises, as in the case of the database query. Second, this example also shows clearly how you can affect the structure of the response via the query. In the query, you specify the properties of the <samp class="listingcharacter listingcharacter">movie</samp> type you want to get. For example, if you aren’t interested in the <samp class="listingcharacter listingcharacter">year</samp> property, you don’t specify it in the request, so the server won’t send the information. In this case, with the very limited number of data records in the database, this feature doesn’t play a particularly important role yet. However, suppose you have an interface <a id="p345"/>with a very large amount of data or very extensive types—then the limitation of the response will definitely come into play. In addition to affecting the structure, you can also parameterize your interface and thus implement a filter, for example.</p>
        
            <h3 class="t3" id="h11.4.1">11.4.1    Parameterizing Queries<a class="indexanchor" id="i11_25"/></h3>
            <p class="standard">For the GraphQL interface to have a scope of features similar to the REST interface, the next step is to implement the option to read a single data record based on its ID. You have several options to implement the feature. For example, you can define a new query field that returns a movie record. Alternatively, you can extend the existing <samp class="listingcharacter listingcharacter">movie</samp> field to support a parameter. This is rather useful because it makes the existing interface more flexible. However, the drawback here is that you also get an array as a result, even if you have only one data record. In <span class="crossreference "><a href="11_004.html#l11.7">Listing 11.7</a></span>, take a look at the schema.</p>
            <div class="listing " id="l11.7"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> buildSchema </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'graphql'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> expressGraphql </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express-graphql'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> getAll </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./movie/model.js'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> schema </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">buildSchema(</span><span class="violett">`</span><br/>  type Movie {<br/>    id: Int!<br/>    title: String!<br/>    year: Int<br/>    public: Int<br/>    user: Int<br/>  }<br/> <br/>  type Query {<br/>    greet: String<br/>    <span class="bold"><samp class="listingcharacter listingcharacter">movie(id: Int): [Movie]</samp></span><br/>  }<br/>`<span class="schwarz">);</span><br/> <br/><span class="rot">const</span><span class="schwarz"> rootValue </span><span class="dunkelblau">=</span><span class="schwarz"> {...};</span><br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">default</span><span class="schwarz"> expressGraphql.graphqlHTTP({...} </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 11.7</b>    
            Extending the Schema with Parameters (graphql.js)</p>
            <p class="standard">You can introduce parameters for a query by writing a field similar to a TypeScript method, as in the example. First, you specify the name, in this case, <samp class="listingcharacter listingcharacter">movie</samp>. Then the parameter list follows in parentheses with the name of the parameter followed by the type. If you add an exclamation mark to the type, you make it a mandatory parameter<a class="indexanchor" id="i11_26"/>. <a id="p346"/>After the parameter list, you must specify the return type, in our case, a <samp class="listingcharacter listingcharacter">movie</samp> array. This schema element must be understood and supported by the resolver on the other side. <span class="crossreference "><a href="11_004.html#l11.8">Listing 11.8</a></span> contains the corresponding adjustment.</p>
            <div class="listing " id="l11.8"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> buildSchema </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'graphql'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> expressGraphql </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express-graphql'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> getAll </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./movie/model.js'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> schema </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">buildSchema(</span><span class="violett">`...`</span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> rootValue </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="schwarz">greet()</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">return</span><span class="schwarz"> </span><span class="hellblau">'Hello GraphQL'</span><span class="schwarz">;</span><span class="schwarz"><br/></span>  <span class="schwarz">},</span><span class="schwarz"><br/></span>  <span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="rot">async</span><span class="schwarz"> movie({ id }) {</span><br/>    <span class="rot">const</span><span class="schwarz"> movies </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> getAll({ userId: 1 });</span><br/>    <span class="rot">if</span><span class="schwarz"> (id) {</span><br/>      <span class="rot">return</span><span class="schwarz"> movies.filter((movie) </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> movie.id </span><span class="dunkelblau">===</span><span class="schwarz"> id);</span><br/>    }<br/>    <span class="rot">return</span><span class="schwarz"> movies;</span><br/>  },</samp></span><br/>};<br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">default</span><span class="schwarz"> expressGraphql.graphqlHTTP({...} </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 11.8</b>    
            Resolver Function for Reading a Data Record (graphql.js)</p>
            <p class="standard">As you can see from the implementation, you get access to the variables of the request via an object in the parameter list. You access the <samp class="listingcharacter listingcharacter">id</samp> directly via a destructuring<a class="indexanchor" id="i11_27"/> statement and can then use the information. Note that <samp class="listingcharacter listingcharacter">id</samp> is an optional variable that can also have no value. In this case, you must return all data records. The advantage of this is that the previous interface continues to work, and you don’t need to adapt the code of already existing clients.</p>
            <p class="standard">You have several options for implementing the requirements. You can start with the list of all records, as in the example, and filter them within the application. Alternatively, you can use the <samp class="listingcharacter listingcharacter">get</samp> function of the model and return the result as an array. If you have a larger amount of data, the second option is more suitable because, in this case, you outsource most of the filtering work to the database. For this example, the actual implementation plays a subordinate role. <span class="crossreference "><a href="11_004.html#f11.3">Figure 11.3</a></span> shows an example of a parameterized query. Here you specify the field, followed by a pair of parentheses enclosing the variable and its value. This is followed, as usual, by the intended structure of the response.</p>
            <div class="imagebox figure-type"><a href="img-f11.3.html" id="f11.3"><img alt="Querying a Data Record with GraphiQL" id="img-f11.3" src="bilderklein/klein11_003.png"/></a></div>
            <p class="caption "><b>Figure 11.3</b>    
            <a id="p347"/>Querying a Data Record with GraphiQL</p>
            <p class="standard">Based on this implementation, you can now implement any other filters to further enhance the flexibility of your interface. In this context, you should always remember that you need to adjust both the schema and the resolver function.</p>
            <p class="standard">In addition to the read accesses, you now have to take care of the write operations, so that you can read data records as well as create, manipulate, and delete them again.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>