<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Socket Server" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Socket Server" name="description"/>
            <meta content="en" name="language"/>
            <title>Socket Server</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main"><h1 class="t1" id="h20">20    <a id="p595"/>Socket Server</h1><p class="introductorynote indent_chapter_double">Just as iron rusts out of use and stagnant water spoils or freezes in the cold, so the mind degenerates without exercise.<br/>—Leonardo da Vinci</p><p class="standard">This<a class="indexanchor" id="i20_00"/> chapter describes the concept of sockets in Node.js. Sockets are mainly used for the communication<a class="indexanchor" id="i20_01"/> between applications. It isn’t mandatory for applications to run on the same system. In this chapter, you’ll learn how you can create both servers and clients for the various sockets.</p><p class="standard"><span class="italic">Sockets</span> in Node.js are nothing more than data streams<a class="indexanchor" id="i20_02"/> and as such are based on the <samp class="listingcharacter listingcharacter">stream</samp> module. As you already know from <span class="crossreference "><a href="18_001.html#h18">Chapter 18</a></span>, this module is an abstraction layer that provides a unified interface to the various data streams. You can use a data stream to send or receive data to or from a remote system. All communication or handling of communication within your application is asynchronous. You’ve already met a very popular representative of data streams—the <samp class="listingcharacter listingcharacter">http</samp> module. As you can see in <span class="crossreference "><a href="20_001.html#f20.1">Figure 20.1</a></span>, you’re now moving down one layer in the Open Systems Interconnection (OSI) layer model<a class="indexanchor" id="i20_03"/>, namely from layers five to seven, where HTTP<a class="indexanchor" id="i20_04"/> is located, to the transport layer with its Transmission Control Protocol (TCP)<a class="indexanchor" id="i20_05"/> and User Datagram Protocol (UDP)<a class="indexanchor" id="i20_06"/>. You can find more information on this topic at <span class="url"><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">https://en.wikipedia.org/wiki/Internet_protocol_suite</a></span>.</p><p class="standard">Because HTTP is located on a higher communication layer, you should follow some rules when implementing servers and clients. For example, HTTP provides you with a set of methods for communication. You can address the individual resources on your server via URLs. To control the communication, you can use the information that’s sent in the HTTP header. The server generates a response based on the information that’s sent with the client’s request. This response consists of a header with various fields and a status code as well as the message body used to send the actual payload of the response. At the TCP level, communication is simpler. To implement clients and servers, Node.js provides the <samp class="listingcharacter listingcharacter">net</samp> module. This module is based on the interfaces of the <samp class="listingcharacter listingcharacter">stream</samp> module. If you choose this type of connection between two applications, you can use sockets for communication in addition to TCP as the communication protocol<a class="indexanchor" id="i20_07"/>. When using sockets, you communicate on a file system basis between two applications. In this chapter, you’ll learn about the different types of sockets you can use with Node.js. To start with, you implement two applications that communicate locally over a Unix socket. Having implemented that, you move on to connecting the applications with TCP and UDP, respectively.</p><div class="imagebox figure-type"><a href="img-f20.1.html" id="f20.1"><img alt="OSI Layer Model" id="img-f20.1" src="bilderklein/klein20_001.png"/></a></div><p class="caption "><b>Figure 20.1</b>    
            <a id="p596"/>OSI Layer Model</p>
        <h2 class="t2" id="h20.1">20.1    Unix Sockets<a class="indexanchor" id="i20_08"/></h2>
        <p class="standard">The simplest way to have two independent applications talk to each other is to use file-based sockets. In this case, you don’t need a network interface through which you send and receive information. Another advantage of file system-based<a class="indexanchor" id="i20_09"/> communication is that it eliminates the overhead associated with multiple network layers. The Unix sockets used in this section aren’t available on Windows systems. The Windows Subsystem for Linux (WSL) is an exception here. Because this is a full-fledged Linux system, you can also work with Unix sockets on Windows. If you develop on a native Windows system, you can use the Windows pipes<a class="indexanchor" id="i20_10"/> presented in <span class="crossreference "><a href="20_002.html#h20.2">Section 20.2</a></span> instead. <span class="crossreference "><a href="20_001.html#l20.1">Listing 20.1</a></span> shows an example of a server implementation.</p>
        <div class="listing " id="l20.1"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> server </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createServer((</span><span class="schwarz">connection</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  connection<span class="schwarz">.on(</span><span class="hellblau">'readable'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">connection</span><span class="schwarz">.read().toString());</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span> <br/>  connection<span class="schwarz">.on(</span><span class="hellblau">'end'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span><a id="p597"/>    <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'connection ended'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"><br/></span> <br/>server<span class="schwarz">.listen(</span><span class="hellblau">'/tmp/nodejs.sock'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Server listening on /tmp/nodejs.sock'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
        <p class="caption "><b>Listing 20.1</b>    
            Unix Socket Server (server.js)</p>
        <p class="standard">Using the <samp class="listingcharacter listingcharacter">createServer</samp> function, you set the stage for communicating with a client by creating a concrete server instance. At this point, this server is still independent of the communication variant used. This means you can use both TCP and Unix sockets here. Calling the <samp class="listingcharacter listingcharacter">listen</samp> method on the server object first turns the general <samp class="listingcharacter listingcharacter">net</samp> server into a Unix socket server by specifying the name of the socket file<a class="indexanchor" id="i20_11"/>. As a second argument, both methods accept a callback function that is bound to a specific event. In the <samp class="listingcharacter listingcharacter">createServer</samp> method, the callback function is bound to the <samp class="listingcharacter listingcharacter">connection</samp> event. This event gets triggered as soon as a client connects to the server. The callback function you pass to the <samp class="listingcharacter listingcharacter">listen</samp> method is bound to the <samp class="listingcharacter listingcharacter">listening</samp> event, which gets triggered when the server is ready for incoming connections.</p>
        <p class="standard">In the next step, you now implement a client<a class="indexanchor" id="i20_12"/> that is able to connect and communicate with the previously generated server. <span class="crossreference "><a href="20_001.html#l20.2">Listing 20.2</a></span> shows you how to proceed in this context.</p>
        <div class="listing " id="l20.2"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> connect </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> client </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">connect(</span><span class="hellblau">'/tmp/nodejs.sock'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'connected to the server'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  client<span class="schwarz">.write(</span><span class="hellblau">'Hello Server'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
        <p class="caption "><b>Listing 20.2</b>    
            Unix Socket Client (client.js)</p>
        <p class="standard">Similar to creating the server, you need to create a concrete instance of the client. To do that, you can use the <samp class="listingcharacter listingcharacter">connect</samp> function<a class="indexanchor" id="i20_13"/>. As a first argument, this method receives the destination of the client. In this case, that’s the name of the socket file as a character string. The second argument is the callback function that will be executed once the connection is established. The callback function is bound internally to the <samp class="listingcharacter listingcharacter">connect</samp> event.</p>
        <p class="standard">To test the client-server interaction, you store the server code in a file named <span class="italic">server.js</span> and store the client code in a file named <span class="italic">client.js</span>. In the first step, you start the server process and receive the output <samp class="listingcharacter listingcharacter">Server listening on /tmp/nodejs.sock</samp><a class="indexanchor" id="i20_14"/> on the command line. This output signals that the server is ready to respond to incoming connections. When you now run the client on a separate command line in parallel with the server, <a id="p598"/>you’ll get the output <samp class="listingcharacter listingcharacter">connected to the server</samp> on the client side and get <samp class="listingcharacter listingcharacter">Hello Server</samp> on the server side. The client sends this character string to the server via the socket using the <samp class="listingcharacter listingcharacter">write</samp> method. This in turn responds to <samp class="listingcharacter listingcharacter">readable</samp> events in the callback function bound to the <samp class="listingcharacter listingcharacter">connection</samp> event. The event is triggered as soon as there is readable data on the stream. By calling the <samp class="listingcharacter listingcharacter">read</samp> method, you can access the character string as a <samp class="listingcharacter listingcharacter">buffer</samp> object and output it to the console. To get a string directly as a return of the <samp class="listingcharacter listingcharacter">read</samp> method, you first need to set the correct character encoding<a class="indexanchor" id="i20_15"/> on the connection using the <samp class="listingcharacter listingcharacter">setEncoding</samp> method before.</p>
        <p class="standard"><span class="crossreference "><a href="20_001.html#f20.2">Figure 20.2</a></span> illustrates the relationship between client and server and the communication between them.</p>
        <div class="imagebox figure-type"><a href="img-f20.2.html" id="f20.2"><img alt="Socket Communication" id="img-f20.2" src="bilderklein/klein20_002.png"/></a></div>
        <p class="caption "><b>Figure 20.2</b>    
            Socket Communication</p>
        
            <h3 class="t3" id="h20.1.1">20.1.1    Accessing the Socket<a class="indexanchor" id="i20_16"/></h3>
            <p class="standard">One advantage of using Unix sockets for the communication between two local applications is that you have complete control over the access to that socket. This means that no access can be made to the socket from outside the system and that you also have complete control over the socket on your system and can manage the access to it. Unix sockets are represented as a file in the file system. You can see this if you run a directory listing on the directory where the socket is located, as shown in <span class="crossreference "><a href="20_001.html#l20.3">Listing 20.3</a></span>.</p>
            <div class="listing " id="l20.3"><pre><span class="bold"><samp class="listingcharacter listingcharacter">$ ls -l /tmp/nodejs.sock </samp></span><br/>srwxr-xr-x  1 nodejs  nodejs 0 Aug  22 08:55 /tmp/nodejs.sock </pre></div>
            <p class="caption "><b>Listing 20.3</b>    
            Directory Listing on the Socket</p>
            <p class="standard">As you can see in <span class="crossreference "><a href="20_001.html#l20.3">Listing 20.3</a></span>, in this case, any user of the system has read access to <span class="italic">/tmp/nodejs.sock</span> and can execute it. If you now adjust the file system permissions<a class="indexanchor" id="i20_17"/> in such a <a id="p599"/>way that only the <samp class="listingcharacter listingcharacter">nodejs</samp> user can access the socket, this means that only those applications running with this user can access this socket. <span class="crossreference "><a href="20_001.html#l20.4">Listing 20.4</a></span> shows how you can adjust access to this socket from within your application.</p>
            <div class="listing " id="l20.4"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="rot">import</span><span class="schwarz"> { chmod } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'fs'</span><span class="schwarz">;</span><br/> </samp></span><br/><span class="rot">const</span><span class="schwarz"> server </span><span class="dunkelblau">=</span><span class="schwarz"> createServer((connection) </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  connection.on(<span class="hellblau">'readable'</span><span class="schwarz">, (data) </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>    <span class="magenta">console</span><span class="schwarz">.log(connection.read().toString());</span><br/>  });<br/> <br/>  connection.on(<span class="hellblau">'end'</span><span class="schwarz">, () </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>    <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'connection ended'</span><span class="schwarz">);</span><br/>  });<br/>});<br/> <br/>server.listen(<span class="hellblau">'/tmp/nodejs.sock'</span><span class="schwarz">, () </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="bold"><samp class="listingcharacter listingcharacter">chmod(<span class="hellblau">'/tmp/nodejs.sock'</span><span class="schwarz">, 0o700, () </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span></samp></span><br/>    <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Server listening on /tmp/nodejs.sock'</span><span class="schwarz">);</span><br/>  <span class="bold"><samp class="listingcharacter listingcharacter">});</samp></span><br/>}); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 20.4</b>    
            Restricting Permissions for the Socket (server.js)</p>
            <p class="standard">The socket server from <span class="crossreference "><a href="20_001.html#l20.1">Listing 20.1</a></span> serves as a basis for <span class="crossreference "><a href="20_001.html#l20.4">Listing 20.4</a></span>. In this example, the permissions are adjusted using the <samp class="listingcharacter listingcharacter">chmod</samp> method of the <samp class="listingcharacter listingcharacter">fs</samp> module. The correct location where you should make the adjustments is the callback function of the <samp class="listingcharacter listingcharacter">listening</samp> event. At this point, you can be sure that the socket exists and that you have access to it. The second requirement in addition to the existence of the socket is that you import the <samp class="listingcharacter listingcharacter">chmod</samp> function from the <samp class="listingcharacter listingcharacter">fs</samp> module. If both requirements are met, you can set the permissions to the value <samp class="listingcharacter listingcharacter">0o700</samp>, which stands for read, write, and execute access for the owner of the socket. If you now run the server with the <samp class="listingcharacter listingcharacter">nodejs</samp> user, only this user can access the socket. To illustrate the effect of the change, you should now run the client with a different user. The result you’ll then get is shown in <span class="crossreference "><a href="20_001.html#l20.5">Listing 20.5</a></span>.</p>
            <div class="listing " id="l20.5"><pre>$ <span class="bold"><samp class="listingcharacter listingcharacter">node client.js </samp></span><br/>events.js:167<br/>      throw er; // Unhandled 'error' event<br/>      ^<br/><br/>Error: connect EACCES /tmp/nodejs.sock<br/>    at PipeConnectWrap.afterConnect [as oncomplete] (net.js:1161:14)<br/>Emitted 'error' event at:<br/><a id="p600"/>    at emitErrorNT (internal/streams/destroy.js:92:8)<br/>    at emitErrorAndCloseNT (internal/streams/destroy.js:59:3)<br/>    at process._tickCallback (internal/process/next_tick.js:174:19) </pre></div>
            <p class="caption "><b>Listing 20.5</b>    
            Error Message for Unauthorized Access to the Socket</p>
            <p class="standard">During development, you should keep in mind that the socket file isn’t automatically deleted when the server gets stopped. If you stop the server and start it again, you get the error message, <samp class="listingcharacter listingcharacter">Error: listen EADDRINUSE /tmp/nodejs.sock</samp>.<a class="indexanchor" id="i20_18"/> The <samp class="listingcharacter listingcharacter">listen</samp> method of the server allows you to create the socket file. As soon as you try to create the socket file a second time, the error gets triggered. To start the server again, you must delete the created socket file. After that, you can launch the application. Within your application, you can close the socket connection by calling the <samp class="listingcharacter listingcharacter">close</samp> method of the server object. This will automatically cause the socket file to be deleted as well.</p>
            <p class="standard">In the following sections, you’ll extend both the client and the server in such a way that they can communicate with each other, allowing you to take advantage of an existing communication channel between both endpoints of the communication link.</p>
        
        
            <h3 class="t3" id="h20.1.2">20.1.2    Bidirectional Communication<a class="indexanchor" id="i20_19"/></h3>
            <p class="standard">The terms client and server are somewhat misleading because both entities are in some sense equal in communication. The server is responsible for creating the socket, while the client connects to the socket. After that, both can read and write data. To demonstrate this, you’ll now implement an application that generates random numbers on the client side and then sends them to a server. The server, in turn, totals the numbers and sends a subtotal back to the client for every 10th package. <span class="crossreference "><a href="20_001.html#l20.6">Listing 20.6</a></span> shows the implementation on the server side.</p>
            <div class="listing " id="l20.6"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> server </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createServer((</span><span class="schwarz">conn</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">let</span><span class="schwarz"> sum </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">0;</span><span class="schwarz"><br/></span>  <span class="rot">let</span><span class="schwarz"> count </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">0;</span><span class="schwarz"><br/></span> <br/>  conn<span class="schwarz">.on(</span><span class="hellblau">'readable'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    sum <span class="dunkelblau">+=</span><span class="schwarz"> </span><span class="schwarz">parseInt(</span><span class="schwarz">conn</span><span class="schwarz">.read().toString(),</span><span class="schwarz"> </span><span class="schwarz">10);</span><span class="schwarz"><br/></span>    count <span class="dunkelblau">+=</span><span class="schwarz"> </span><span class="schwarz">1;</span><span class="schwarz"><br/></span> <br/>    <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">count </span><span class="dunkelblau">&gt;=</span><span class="schwarz"> </span><span class="schwarz">10)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      count <span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">0;</span><span class="schwarz"><br/></span>      conn<span class="schwarz">.write(</span><span class="schwarz">sum</span><span class="schwarz">.toString());</span><span class="schwarz"><br/></span>    <span class="schwarz">}</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"><br/></span><a id="p601"/> <br/>server<span class="schwarz">.listen(</span><span class="hellblau">'/tmp/nodejs.sock'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Server listening on /tmp/nodejs.sock'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.6</b>    
            Bidirectional Communication (server.js)</p>
            <p class="standard">The basis for the server-side implementation is the source code shown earlier in <span class="crossreference "><a href="20_001.html#l20.1">Listing 20.1</a></span>. Inside the callback function that you bind to the <samp class="listingcharacter listingcharacter">readable</samp> event, you read the data that’s sent from the client, sum it up, and keep an internal counter that tells you when the 10th package has been received and you need to return the current subtotal to the client. The object you receive as an argument in this callback function is an instance of the <samp class="listingcharacter listingcharacter">net.Socket</samp><a class="indexanchor" id="i20_20"/> class, which represents the socket connection to the client. On this object, you can call the <samp class="listingcharacter listingcharacter">write</samp> method to send the data to the client. When sending the data, you should keep in mind that you’re only allowed to write either a string or a <samp class="listingcharacter listingcharacter">buffer</samp> object<a class="indexanchor" id="i20_21"/> because if you try to send an integer, you’ll receive an error message, and your application will abort. The counterpart to the server implementation is the socket client, which you can see in <span class="crossreference "><a href="20_001.html#l20.7">Listing 20.7</a></span>.</p>
            <div class="listing " id="l20.7"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> connect </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'net'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> client </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">connect(</span><span class="hellblau">'/tmp/nodejs.sock'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">let</span><span class="schwarz"> count </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">0;</span><span class="schwarz"><br/></span>  <span class="rot">let</span><span class="schwarz"> number </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">0;</span><span class="schwarz"><br/></span>  <span class="rot">let</span><span class="schwarz"> interval </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">setInterval(()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">count </span><span class="dunkelblau">&lt;</span><span class="schwarz"> </span><span class="schwarz">100)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      number <span class="dunkelblau">=</span><span class="schwarz"> Math</span><span class="schwarz">.ceil(</span><span class="schwarz">Math</span><span class="schwarz">.random()</span><span class="schwarz"> </span><span class="dunkelblau">*</span><span class="schwarz"> </span><span class="schwarz">100);</span><span class="schwarz"><br/></span>      <span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">number</span><span class="schwarz">);</span><span class="schwarz"><br/></span>      client<span class="schwarz">.write(</span><span class="schwarz">number</span><span class="schwarz">.toString());</span><span class="schwarz"><br/></span>      count <span class="dunkelblau">+=</span><span class="schwarz"> </span><span class="schwarz">1;</span><span class="schwarz"><br/></span>    <span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">else</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      <span class="schwarz">clearInterval(</span><span class="schwarz">interval</span><span class="schwarz">);</span><span class="schwarz"><br/></span>      client<span class="schwarz">.end();</span><span class="schwarz"><br/></span>    <span class="schwarz">}</span><span class="schwarz"><br/></span>  <span class="schwarz">},</span><span class="schwarz"> </span><span class="schwarz">500);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"><br/></span> <br/>client<span class="schwarz">.on(</span><span class="hellblau">'readable'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'subtotal: '</span><span class="schwarz"> </span><span class="dunkelblau">+</span><span class="schwarz"> client</span><span class="schwarz">.read().toString());</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.7</b>    
            Bidirectional Communication (client.js)</p>
            <p class="standard">Using the <samp class="listingcharacter listingcharacter">connect</samp> method, the client connects to the socket that was previously created by the server. Within the callback function, you send a number between 0 and 100 <a id="p602"/>through the socket to the server every 500 milliseconds. After 100 numbers, the interval is cleared with a call of the <samp class="listingcharacter listingcharacter">clearInterval</samp> method, and no more numbers are sent to the server. The connection is terminated with a call of the <samp class="listingcharacter listingcharacter">end</samp> method.</p>
            <p class="standard">As you can see in <span class="crossreference "><a href="20_001.html#f20.3">Figure 20.3</a></span>, the output consists of 10 consecutive random numbers followed by a line showing the subtotal of the numbers that have been output up until this point. This sequence is repeated 10 times in total. The client script terminates as soon as all 100 numbers have been totaled. The server, however, keeps running. As is the case with an HTTP server, a server based on Unix sockets allows multiple clients<a class="indexanchor" id="i20_22"/> to connect to the server simultaneously. Specifically, this means you can start multiple clients on the same socket. However, the clients only communicate directly with the server and not with each other.</p>
            <div class="imagebox figure-type"><a href="img-f20.3.html" id="f20.3"><img alt="Result of the Communication between Client and Server" id="img-f20.3" src="bilderklein/klein20_003.png"/></a></div>
            <p class="caption "><b>Figure 20.3</b>    
            Result of the Communication between Client and Server</p>
            <p class="standard">If you use sockets for file system-based communication in your application, you don’t need to do without them on Windows systems either. Instead of Unix sockets, Windows uses Windows pipes.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>