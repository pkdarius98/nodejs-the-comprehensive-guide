<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Performance" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Performance" name="description"/>
            <meta content="en" name="language"/>
            <title>Performance</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h26.2">26.2    <a id="p734"/>CPU<a class="indexanchor" id="i26_08"/></h2>
        <p class="standard">Node.js needs the processor as a resource so that computations<a class="indexanchor" id="i26_09"/> can be performed. This can be simple things like calculating 1 + 1, but also complex operations like parsing an extensive JavaScript Object Notation (JSON) structure. Modern systems usually have at least several processor cores to which the work can be distributed. The architecture of Node.js follows a single-process and a single-threaded approach. Everything you run in Node.js runs in one process and potentially blocks each other. You can solve this problem using the <samp class="listingcharacter listingcharacter">child_process</samp><a class="indexanchor" id="i26_10"/> and <samp class="listingcharacter listingcharacter">worker_threads</samp><a class="indexanchor" id="i26_11"/> modules. <span class="crossreference "><a href="16_001.html#h16">Chapter 16</a></span> describes how this exactly works.</p>
        <p class="standard">The asynchronous input and output approach allows Node.js to swap out to the operating system all operations that aren’t directly processed by the core of the platform. This includes, for example, network communication and the majority of file system operations. This means that even reading a very large file won’t block your process. But then the processing of the results poses another obstacle. The distinction between the parts of an operation that can be outsourced and the parts that take place within the platform is very important here.</p>
        
            <h3 class="t3" id="h26.2.1">26.2.1    CPU-Blocking Operations<a class="indexanchor" id="i26_12"/></h3>
            <p class="standard">Despite all the platform optimizations, you can easily utilize a CPU core up to 100% capacity with Node.js by writing <samp class="listingcharacter listingcharacter">while(true)</samp>. This type of infinite loop<a class="indexanchor" id="i26_13"/> ensures that the process is completely blocked and can’t perform any further operations.</p>
            <p class="standard">In <span class="crossreference "><a href="26_002.html#l26.1">Listing 26.1</a></span>, you can see a slightly more elegant variant of wasting processor time. This code example shows a kind of blocking time-out function. The <samp class="listingcharacter listingcharacter">sleep</samp> function accepts a numerical value in terms of seconds to be waited for. Then you take the start value and start an endless loop. For each loop pass, you check whether the termination condition is met. If this is the case, the infinite loop is exited; otherwise, the next loop pass will follow. The output of the example is first the <samp class="listingcharacter listingcharacter">Before Sleep</samp> string, then 10 seconds pass, followed by the output <samp class="listingcharacter listingcharacter">After Sleep</samp>, and the script terminates.</p>
            <div class="listing " id="l26.1"><pre><span class="rot">function</span><span class="schwarz"> </span><span class="schwarz">sleep(</span><span class="schwarz">delayInSec</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">const</span><span class="schwarz"> start </span><span class="dunkelblau">=</span><span class="schwarz"> Date</span><span class="schwarz">.now();</span><span class="schwarz"><br/></span> <br/>  <span class="rot">while</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="rot">true</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">Date</span><span class="schwarz">.now()</span><span class="schwarz"> </span><span class="dunkelblau">-</span><span class="schwarz"> start </span><span class="dunkelblau">&gt;=</span><span class="schwarz"> delayInSec </span><span class="dunkelblau">*</span><span class="schwarz"> </span><span class="schwarz">1000)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      <span class="rot">break</span><span class="schwarz">;</span><span class="schwarz"><br/></span>    <span class="schwarz">}</span><span class="schwarz"><br/></span>  <span class="schwarz">}</span><span class="schwarz"><br/></span><span class="schwarz">}</span><span class="schwarz"><br/></span> <br/><span class="magenta"><a id="p735"/>console</span><span class="schwarz">.log(</span><span class="hellblau">'Before Sleep'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">sleep(10);</span><span class="schwarz"><br/></span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'After Sleep'</span><span class="schwarz">);</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 26.1</b>    
            Infinite Loop with Termination Condition</p>
        
        
            <h3 class="t3" id="h26.2.2">26.2.2    Measuring the CPU Load<a class="indexanchor" id="i26_14"/></h3>
            <p class="standard">The simplest way to measure the impact of a process on your system’s processor is to use the onboard tools of your operating system. On Windows, for example, this is the Task Manager<a class="indexanchor" id="i26_15"/>, and on macOS, it’s the Activity Monitor<a class="indexanchor" id="i26_16"/>. These tools show you whether or not your system is currently under load. These tools also allow you to sort the currently running processes by CPU utilization, so that the most resource-intensive processes are displayed at the top of the list. If your Node.js application is among the first hits here, this is a first indicator of a performance problem.</p>
            <p class="standard">Command-line tools such as <samp class="listingcharacter listingcharacter">htop</samp><a class="indexanchor" id="i26_17"/> go one step further, providing you with significantly more information about the individual processes. For example, if you run the script from <span class="crossreference "><a href="26_002.html#l26.1">Listing 26.1</a></span> and run <samp class="listingcharacter listingcharacter">htop</samp> in parallel, you get a view like the one shown in <span class="crossreference "><a href="26_002.html#f26.1">Figure 26.1</a></span>.</p>
            <p class="standard"><samp class="listingcharacter listingcharacter">htop</samp> enables you to search for specific processes or filter the process list. In this case, the list is filtered by the term <span class="italic">index.js</span> and shows only our application process. Here you can see that the value in the <span class="screenelement">CPU%</span> column is at <span class="screenelement">99.3%</span>, which means that a processor core is almost completely utilized.</p>
            <div class="imagebox figure-type"><a href="img-f26.1.html" id="f26.1"><img alt="Output of “htop” for a CPU-Intensive Node.js Application" id="img-f26.1" src="bilderklein/klein26_001.png"/></a></div>
            <p class="caption "><b>Figure 26.1</b>    
            Output of “htop” for a CPU-Intensive Node.js Application</p>
            <p class="standard">As already mentioned, these tools only provide you with a first impression of the overall application. Once you’ve identified a problem here, you need to take a step further <a id="p736"/>and take a look inside your application. For this purpose, you can use the Chrome DevTools<a class="indexanchor" id="i26_18"/> profiler<a class="indexanchor" id="i26_19"/>.</p>
        
        
            <h3 class="t3" id="h26.2.3">26.2.3    CPU Profiling with Chrome DevTools</h3>
            <p class="standard">To profile your application, you must open it in debug mode, that is, that is, using the <samp class="listingcharacter listingcharacter">--inspect</samp><a class="indexanchor" id="i26_20"/> option or <samp class="listingcharacter listingcharacter">--inspect-brk</samp><a class="indexanchor" id="i26_21"/> command-line option. Both options ensure that you can connect to your application via Chrome DevTools and the debugger protocol. If you use <samp class="listingcharacter listingcharacter">--inspect-brk</samp>, your application won’t be executed directly but will be halted before the first statement. This is different if you use <samp class="listingcharacter listingcharacter">--inspect</samp>. For our example, you start your application using <samp class="listingcharacter listingcharacter">--inspect-brk</samp>, open your local Chrome browser, and enter “chrome://inspect” in the address bar. There you’ll find the <span class="screenelement">Remote Targets</span> heading under <span class="screenelement">Devices</span>, which is where your Node.js application is listed. When you click on the <span class="screenelement">inspect</span> link, DevTools will open, and you’ll see your application in a paused state. Up to this point, you already know the process from <span class="crossreference "><a href="03_001.html#h3">Chapter 3</a></span>. Now, however, you must switch from the <span class="screenelement">Sources</span> tab to the <span class="screenelement">Profiler</span> tab and click the <span class="screenelement">Start</span> button there. This will ensure that your application is running. You should now wait about 5–10 seconds before clicking the <span class="screenelement">Stop</span> button to stop recording. As a result, you’ll see a tabular listing like the one shown in <span class="crossreference "><a href="26_002.html#f26.2">Figure 26.2</a></span>.</p>
            <div class="imagebox figure-type"><a href="img-f26.2.html" id="f26.2"><img alt="CPU Profiling with Chrome DevTools" id="img-f26.2" src="bilderklein/klein26_002.png"/></a></div>
            <p class="caption "><b>Figure 26.2</b>    
            CPU Profiling with Chrome DevTools</p>
            <p class="standard">This list shows you how much time a function has consumed by itself or as part of the total of all functions called by it. You also get the name of the function and a reference to the source code. As you can see here, our <samp class="listingcharacter listingcharacter">sleep</samp> function is the undisputed leader when it comes to CPU consumption<a class="indexanchor" id="i26_22"/>. Unfortunately, the situation is rarely that clear-cut in reality, so you usually have to invest some time here to find optimization potential.</p>
            <p class="standard">In some situations, the tabular overview isn’t very informative for concrete problems. In such a case, you can switch to the <span class="screenelement">Sources</span> tab and see how much time the application <a id="p737"/>took to process certain lines. To help you observe this in our example, you should add a <samp class="listingcharacter listingcharacter">debugger</samp> statement like the one in <span class="crossreference "><a href="26_002.html#l26.2">Listing 26.2</a></span> as the last line.</p>
            <div class="listing " id="l26.2"><pre><span class="rot">function</span><span class="schwarz"> </span><span class="schwarz">sleep(</span><span class="schwarz">delayInSec</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">const</span><span class="schwarz"> start </span><span class="dunkelblau">=</span><span class="schwarz"> Date</span><span class="schwarz">.now();</span><span class="schwarz"><br/></span> <br/>  <span class="rot">while</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="rot">true</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">Date</span><span class="schwarz">.now()</span><span class="schwarz"> </span><span class="dunkelblau">-</span><span class="schwarz"> start </span><span class="dunkelblau">&gt;=</span><span class="schwarz"> delayInSec </span><span class="dunkelblau">*</span><span class="schwarz"> </span><span class="schwarz">1000)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      <span class="rot">break</span><span class="schwarz">;</span><span class="schwarz"><br/></span>    <span class="schwarz">}</span><span class="schwarz"><br/></span>  <span class="schwarz">}</span><span class="schwarz"><br/></span><span class="schwarz">}</span><span class="schwarz"><br/></span> <br/><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Before Sleep'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">sleep(10);</span><span class="schwarz"><br/></span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'After Sleep'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="rot">debugger</span><span class="schwarz">;</span></samp></span> <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 26.2</b>    
            “debugger” Statement in the “sleep” Script</p>
            <p class="standard">If you’ve saved this source code in a file named <span class="italic">index.js</span>, you can execute it again via the <samp class="listingcharacter listingcharacter">node --inspect-brk index.js</samp> command. Then you return to the <span class="screenelement">Profiler</span> tab and start the recording<a class="indexanchor" id="i26_23"/> by clicking the <span class="screenelement">Start</span> button. Wait a few seconds, stop the recording by clicking the <span class="screenelement">Stop</span> button, and then go to the <span class="screenelement">Sources</span> tab again. After a short wait, the debugger stops at the breakpoint, that is, the <samp class="listingcharacter listingcharacter">debugger</samp> statement, and you can see how much time your application has spent in the various lines during the recording. <span class="crossreference "><a href="26_002.html#f26.3">Figure 26.3</a></span> shows an example.</p>
            <div class="imagebox figure-type"><a href="img-f26.3.html" id="f26.3"><img alt="Display of Execution Time in DevTools" id="img-f26.3" src="bilderklein/klein26_003.png"/></a></div>
            <p class="caption "><b>Figure 26.3</b>    
            Display of Execution Time in DevTools</p>
            <p class="standard">The time specification at the beginning of the line shows that you’ve spent most of the time, exactly 5789.5 milliseconds, executing the <samp class="listingcharacter listingcharacter">if</samp> statement.</p>
            <div class="box box_standard">
                <h6 class="boxheading"><a id="p738"/>Note</h6>
                <p class="standard first last">The <samp class="listingcharacter listingcharacter">debugger</samp><a class="indexanchor" id="i26_24"/> statement is important, by the way, as it makes sure that the Node.js process doesn’t terminate before you’ve had a chance to look at the source code. As soon as the process is terminated, the file is also no longer available for viewing.</p>
            </div>
        
        
            <h3 class="t3" id="h26.2.4">26.2.4    Alternatives to the Profiler: console.time<a class="indexanchor" id="i26_25"/></h3>
            <p class="standard">When it comes to measuring execution times<a class="indexanchor" id="i26_26"/>, Node.js offers you a whole range of other tools in addition to the profiler. The simplest one is a feature of the <samp class="listingcharacter listingcharacter">console</samp> object. You can use two methods, <samp class="listingcharacter listingcharacter">console.time</samp> and <samp class="listingcharacter listingcharacter">console.timeEnd</samp>, to measure the runtime of your application between the two calls. Let’s test this directly with our <samp class="listingcharacter listingcharacter">sleep</samp> function. To do this, add a call of <samp class="listingcharacter listingcharacter">console.time</samp> before the <samp class="listingcharacter listingcharacter">sleep</samp> call and a call of <samp class="listingcharacter listingcharacter">console.timeEnd</samp> after it, as shown in <span class="crossreference "><a href="26_002.html#l26.3">Listing 26.3</a></span>.</p>
            <div class="listing " id="l26.3"><pre><span class="rot">function</span><span class="schwarz"> </span><span class="schwarz">sleep(</span><span class="schwarz">delayInSec</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">const</span><span class="schwarz"> start </span><span class="dunkelblau">=</span><span class="schwarz"> Date</span><span class="schwarz">.now();</span><span class="schwarz"><br/></span> <br/>  <span class="rot">while</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="rot">true</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">Date</span><span class="schwarz">.now()</span><span class="schwarz"> </span><span class="dunkelblau">-</span><span class="schwarz"> start </span><span class="dunkelblau">&gt;=</span><span class="schwarz"> delayInSec </span><span class="dunkelblau">*</span><span class="schwarz"> </span><span class="schwarz">1000)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      <span class="rot">break</span><span class="schwarz">;</span><span class="schwarz"><br/></span>    <span class="schwarz">}</span><span class="schwarz"><br/></span>  <span class="schwarz">}</span><span class="schwarz"><br/></span><span class="schwarz">}</span><span class="schwarz"><br/></span> <br/><span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="magenta">console</span><span class="schwarz">.time(</span><span class="hellblau">'sleep'</span><span class="schwarz">);</span></samp></span><br/>sleep(10);<br/><span class="bold"><samp class="listingcharacter listingcharacter"><span class="magenta">console</span><span class="schwarz">.timeEnd(</span><span class="hellblau">'sleep'</span><span class="schwarz">);</span></samp></span><span class="gruen"> // Output: sleep: 10.000s</span><span class="schwarz"> </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 26.3</b>    
            Using the “console.time” Methods</p>
            <p class="standard">To perform a measurement, you first call the <samp class="listingcharacter listingcharacter">console.time</samp> method with any character string as its label. Then you perform the operations you want to measure; in our case, this is the <samp class="listingcharacter listingcharacter">sleep</samp> function with the value <samp class="listingcharacter listingcharacter">10</samp>. To finish the measurement, you call the <samp class="listingcharacter listingcharacter">console.timeEnd</samp> method with the same label you used for <samp class="listingcharacter listingcharacter">console.time</samp>. The value of the measurement is output directly on the command line together with the label in milliseconds. And this is precisely where the problem lies. If you want to perform measurements in production operation, it isn’t very useful to log all information on the console. In addition, calling the <samp class="listingcharacter listingcharacter">console</samp> methods themselves requires resources, although these may be neglected. For quick experiments and simple measurements, you can easily use the <samp class="listingcharacter listingcharacter">console</samp> methods; for measurements in a production environment, you should turn to the performance-hooks interface of Node.js.</p>
        
        
            <h3 class="t3" id="h26.2.5">26.2.5    <a id="p739"/>Alternatives to the Profiler: Performance-Hooks<a class="indexanchor" id="i26_27"/> Interface</h3>
            <p class="standard">Version 8.5 introduced the <samp class="listingcharacter listingcharacter">perf_hooks</samp> module<a class="indexanchor" id="i26_28"/>, a new extension to Node.js that allows you to perform time measurements for all aspects of your application. As with the <samp class="listingcharacter listingcharacter">console.time</samp> methods, you only need to set markers at the right locations for this and can then perform measurements. Unlike the <samp class="listingcharacter listingcharacter">console.time</samp> methods, you can control the behavior and processing of the measurements much better and, for example, redirect the output to a file or disable the measurements<a class="indexanchor" id="i26_29"/>.</p>
            <p class="standard">For the next example, we want to measure the execution of the <samp class="listingcharacter listingcharacter">sleep</samp> function again. However, the output will be saved to a file named <span class="italic">time.log</span>, and the measurement will be dependent on an environment variable. For the example to work, you need a <span class="italic">package.json</span> file, which you can generate via <samp class="listingcharacter listingcharacter">npm init -y</samp>. You also need to install the <samp class="listingcharacter listingcharacter">cross-env</samp> package via the <samp class="listingcharacter listingcharacter">npm install --save-dev cross-env</samp> command. This package ensures that you can set environment variables<a class="indexanchor" id="i26_30"/> independently of your system. You use the package to set the <samp class="listingcharacter listingcharacter">MEASURE</samp> variable in the startup script to the value <samp class="listingcharacter listingcharacter">true</samp>. <span class="crossreference "><a href="26_002.html#l26.4">Listing 26.4</a></span> shows the corresponding <span class="italic">package.json</span> file.</p>
            <div class="listing " id="l26.4"><pre><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="hellblau">"name"</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">"node-book"</span><span class="schwarz">,</span><span class="schwarz"><br/></span>  <span class="hellblau">"version"</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">"1.0.0"</span><span class="schwarz">,</span><span class="schwarz"><br/></span>  <span class="hellblau">"description"</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">""</span><span class="schwarz">,</span><span class="schwarz"><br/></span>  <span class="hellblau">"main"</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">"index.js"</span><span class="schwarz">,</span><span class="schwarz"><br/></span>  <span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="hellblau">"private"</span><span class="schwarz">: </span><span class="rot">true</span><span class="schwarz">,</span><br/>  <span class="hellblau">"type"</span><span class="schwarz">: </span><span class="hellblau">"module"</span><span class="schwarz">,</span><br/>  <span class="hellblau">"scripts"</span><span class="schwarz">: {</span><br/>    <span class="hellblau">"start"</span><span class="schwarz">: </span><span class="hellblau">"cross-env MEASURE=true node index.js"</span><span class="schwarz"><br/></span>  },</samp></span><br/>  <span class="hellblau">"keywords"</span><span class="schwarz">: [],</span><br/>  <span class="hellblau">"author"</span><span class="schwarz">: </span><span class="hellblau">""</span><span class="schwarz">,</span><br/>  <span class="hellblau">"license"</span><span class="schwarz">: </span><span class="hellblau">"ISC"</span><span class="schwarz">,</span><br/>  <span class="bold"><samp class="listingcharacter listingcharacter"><span class="hellblau">"dependencies"</span><span class="schwarz">: {</span><br/>    <span class="hellblau">"cross-env"</span><span class="schwarz">: </span><span class="hellblau">"^7.0.3"</span><span class="schwarz"><br/></span>  }</samp></span><br/>} <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 26.4</b>    
            “package.json” with “cross-env” Integration</p>
            <p class="standard">Based on this, you can now start integrating the <samp class="listingcharacter listingcharacter">perf_hooks</samp> module into your application. The integration process consists of four steps: define a <samp class="listingcharacter listingcharacter">PerformanceObserver</samp><a class="indexanchor" id="i26_31"/>, activate it, set markers in your code, and perform the measurement.</p>
            <p class="standard">In the code example in <span class="crossreference "><a href="26_002.html#l26.5">Listing 26.5</a></span>, you can see that the processing of a measurement is decoupled from the actual measurement process. The first two steps, that is, the definition of the <samp class="listingcharacter listingcharacter">PerformanceObserver</samp> and its activation, depend on the value of the environment variable <samp class="listingcharacter listingcharacter">MEASURE</samp>. In the <samp class="listingcharacter listingcharacter">start</samp> script of <span class="italic">package.json</span>, you’ve set this value to <samp class="listingcharacter listingcharacter"><a id="p740"/>true</samp>, which means that the condition is true, and the code block is executed. When you run the application via <samp class="listingcharacter listingcharacter">node index.js</samp>, this isn’t the case, and the script doesn’t write a new entry to the <span class="italic">time.log</span> file.</p>
            <div class="listing " id="l26.5"><pre><span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="rot">import</span><span class="schwarz"> { PerformanceObserver, performance } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'perf_hooks'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { appendFile } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'fs/promises'</span><span class="schwarz">;</span><br/> <br/><span class="rot">if</span><span class="schwarz"> (process.env.MEASURE) {</span><br/>  <span class="rot">const</span><span class="schwarz"> obs </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">new </span><span class="schwarz">PerformanceObserver((items) </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>    <span class="rot">const</span><span class="schwarz"> entries </span><span class="dunkelblau">=</span><span class="schwarz"> items.getEntries();</span><br/>    entries.forEach(({ name, duration }) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>      appendFile(<span class="hellblau">'time.log'</span><span class="schwarz">, </span><span class="violett">`${name}: ${duration}\n`</span><span class="schwarz">);</span><br/>    });<br/>  });<br/>  obs.observe({ entryTypes: [<span class="hellblau">'measure'</span><span class="schwarz">] });</span><br/>}<br/> </samp></span><br/><span class="rot">function</span><span class="schwarz"> sleep(delayInSec) {</span><br/>  <span class="rot">const</span><span class="schwarz"> start </span><span class="dunkelblau">=</span><span class="schwarz"> Date.now();</span><br/> <br/>  <span class="rot">while</span><span class="schwarz"> (</span><span class="rot">true</span><span class="schwarz">) {</span><br/>    <span class="rot">if</span><span class="schwarz"> (Date.now() </span><span class="dunkelblau">-</span><span class="schwarz"> start </span><span class="dunkelblau">&gt;=</span><span class="schwarz"> delayInSec </span><span class="dunkelblau">*</span><span class="schwarz"> 1000) {</span><br/>      <span class="rot">break</span><span class="schwarz">;</span><br/>    }<br/>  }<br/>}<br/> <br/><span class="bold"><samp class="listingcharacter listingcharacter">performance.mark(<span class="hellblau">'sleep start'</span><span class="schwarz">);</span></samp></span><br/>sleep(10);<br/><span class="bold"><samp class="listingcharacter listingcharacter">performance.mark(<span class="hellblau">'sleep end'</span><span class="schwarz">);</span><br/>performance.measure(<span class="hellblau">'sleep: '</span><span class="schwarz">, </span><span class="hellblau">'sleep start'</span><span class="schwarz">, </span><span class="hellblau">'sleep end'</span><span class="schwarz">);</span></samp></span> <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 26.5</b>    
            Integrating the “perf_hooks” Module</p>
            <p class="standard">The callback function you pass to the <samp class="listingcharacter listingcharacter">PerformanceObserver</samp> when it’s instantiated is assigned an <samp class="listingcharacter listingcharacter">items</samp> object whose <samp class="listingcharacter listingcharacter">getEntries</samp><a class="indexanchor" id="i26_32"/> method allows you to access an array of measurements. Each entry contains the name, type, start time, and duration of the measurement as well as details. You log each of these entries with the <samp class="listingcharacter listingcharacter">appendFile</samp> function from the <samp class="listingcharacter listingcharacter">fs/promises</samp> module.</p>
            <p class="standard">By calling the <samp class="listingcharacter listingcharacter">observe</samp><a class="indexanchor" id="i26_33"/> method, you instruct the <samp class="listingcharacter listingcharacter">PerformanceObserver</samp> instance to handle the measurements. Regardless of the <samp class="listingcharacter listingcharacter">PerformanceObserver</samp>, you set markers in your code using the <samp class="listingcharacter listingcharacter">mark</samp> method of the <samp class="listingcharacter listingcharacter">performance</samp> object. Here, you should use meaningful names, if possible. Unlike the <samp class="listingcharacter listingcharacter">console.time</samp> methods, the names of the individual markers are independent of each other and are only related to each other when the <samp class="listingcharacter listingcharacter">measure</samp><a class="indexanchor" id="i26_34"/> method is called. Here you pass the name of the measurement, the start mark, and the <a id="p741"/>end mark. The <samp class="listingcharacter listingcharacter">perf_hooks</samp> module uses this information to calculate the values that will then be made available to you in the <samp class="listingcharacter listingcharacter">PerformanceObserver</samp>.</p>
            <p class="standard">If you run the application via the <samp class="listingcharacter listingcharacter">npm start</samp> command, a new entry is written to the <span class="italic">time.log</span> file after a short wait, or this file gets created if it doesn’t yet exist. <span class="crossreference "><a href="26_002.html#l26.6">Listing 26.6</a></span> shows an example of the contents of this file.</p>
            <div class="listing " id="l26.6"><pre><span class="violett">sleep: : 9999.051399946213</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 26.6</b>    
            Contents of the “time.log” File</p>
            <p class="standard">As you can see here, the <samp class="listingcharacter listingcharacter">perf_hooks</samp> module doesn’t use millisecond time stamps, but it’s even more accurate<a class="indexanchor" id="i26_35"/>.</p>
            <p class="standard">With the profiler, the <samp class="listingcharacter listingcharacter">console.time</samp> methods and the <samp class="listingcharacter listingcharacter">perf_hooks</samp> module, you’ve become acquainted with various options that allow you to measure the runtime of your application. In the next step, we’ll turn our attention to memory, another system resource that is relevant for your application.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>