<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Security" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Security" name="description"/>
            <meta content="en" name="language"/>
            <title>Security</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h24.4">24.4    Client Protection<a class="indexanchor" id="i24_87"/></h2>
        <p class="standard">The server is not the only thing worth protecting in a web application<a class="indexanchor" id="i24_88"/>—the client must be protected from attacks as well. Again, as with the server, the risk to your users comes from the users themselves. However, this doesn’t mean that the users of your application would put themselves at risk; rather, it means that other users may be able to modify your application or the data within your application in such a way that a danger arises from it.</p>
        <p class="standard">In this section, you’ll learn about some common attack vectors, especially in web applications, and also how to deal with such risks.</p>
        
            <h3 class="t3" id="h24.4.1">24.4.1    Cross-Site Scripting<a class="indexanchor" id="i24_89"/></h3>
            <p class="standard">Attacks against clients of a web application always exploit the fact that these users consider the web application to be trustworthy. This means they don’t expect the application to pose any danger. For this reason, the provided content doesn’t get checked for security-critical aspects or is checked very little. And it’s precisely this situation that attackers exploit in a cross-site scripting attack. <span class="italic">Cross-site scripting</span> is a kind of HTML injection<a class="indexanchor" id="i24_90"/>. This involves injecting malicious code<a class="indexanchor" id="i24_91"/> into the page, which is then executed by the users of the application.</p>
            <p class="standard"><a id="p708"/>You can generally distinguish between two types of cross-site scripting attacks. In the first case, the data containing the malicious code isn’t stored within the application. The attack data is therefore volatile and will be lost. <span class="crossreference "><a href="24_004.html#l24.26">Listing 24.26</a></span> shows an example of this.</p>
            <div class="listing " id="l24.26"><pre><span class="rot">import</span><span class="schwarz"> { createServer } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'http'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { parse } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'url'</span><span class="schwarz">;</span><br/> <br/>createServer((req, res) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="rot">const</span><span class="schwarz"> input </span><span class="dunkelblau">=</span><span class="schwarz"> parse(req.url, </span><span class="rot">true</span><span class="schwarz">).query.input;</span><br/>  res.end(<span class="violett">`&lt;html&gt;&lt;body&gt;${input}&lt;/body&gt;&lt;/html&gt;`</span><span class="schwarz">);</span><br/>}).listen(8080); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 24.26</b>    
            Vulnerability to Cross-Site Scripting in Source Code</p>
            <p class="standard">If you access this page via the URL <span class="italic">http://localhost:8080/?input=&lt;script&gt;alert('hello')&lt;/script&gt;</span>, you’ll see an alert window. If you now assume that your application is vulnerable to such attacks, it’s easy to send such crafted links to execute any JavaScript source code on your users. If, on top of that, you also use a link shortener<a class="indexanchor" id="i24_92"/>, the victims of such an attack can’t even recognize the attack via the URL.</p>
            <p class="standard">Even worse than nonpersistent cross-site scripting attacks are those that are persisted within your application. This means that the HTML injection is stored in some form and can be retrieved by all users of your application. For example, if you insert malicious code into your user name and display it to others, the JavaScript code it contains is automatically executed.</p>
            <p class="standard">For cross-site scripting attacks, a simple countermeasure exists that covers both the persistent and nonpersistent variants and can thus prevent them. As a rule, you should mask<a class="indexanchor" id="i24_93"/> special characters used in the context of HTML. This concerns especially the greater-than and the less-than signs. However, you don’t need to take care of solving this problem yourself, but can access existing software solutions. In <span class="crossreference "><a href="24_004.html#l24.27">Listing 24.27</a></span>, the <samp class="listingcharacter listingcharacter">entities</samp> npm package is used to secure the example from <span class="crossreference "><a href="24_004.html#l24.26">Listing 24.26</a></span> against cross-site scripting attacks.</p>
            <div class="listing " id="l24.27"><pre><span class="rot">import</span><span class="schwarz"> { createServer } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'http'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { parse } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'url'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> entities </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'entities'</span><span class="schwarz">;</span><br/> <br/>createServer((req, res) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="rot">const</span><span class="schwarz"> input </span><span class="dunkelblau">=</span><span class="schwarz"> parse(req.url, </span><span class="rot">true</span><span class="schwarz">).query.input;</span><br/>  res.end(<span class="violett">`&lt;html&gt;&lt;body&gt;${</span><span class="bold">entities.encode(input)</span>}&lt;/body&gt;&lt;/html&gt;`<span class="schwarz">);</span><br/>}).listen(8080); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 24.27</b>    
            Security against Cross-Site Scripting Attacks</p>
            <p class="standard"><a id="p709"/>Packages such as <samp class="listingcharacter listingcharacter">entities</samp> ensure that the potentially malicious <samp class="listingcharacter listingcharacter">&lt;script&gt;</samp> tags are encoded in such a way that they’re output as normal strings in the browser, and the JavaScript between them doesn’t get executed. This way, you can protect your users from attacks. You should always secure output to users that originates from other systems, such as users, databases, or web services.</p>
        
        
            <h3 class="t3" id="h24.4.2">24.4.2    Cross-Site Request Forgery<a class="indexanchor" id="i24_94"/></h3>
            <p class="standard">In a <span class="italic">cross-site request forgery</span> (CSRF), an attacker causes a victim to involuntarily take an action in an application. The problem arises because a user logs in to an application once and is then logged in for the duration of the session<a class="indexanchor" id="i24_95"/>. This valid session can be abused for attacks. A concrete example helps to better understand this somewhat abstract topic. Imagine you’ve implemented a web store<a class="indexanchor" id="i24_96"/>. As a convenience feature, you provide your users with the option to make purchases directly through a link. A user merely needs to click on a link or button to buy the product directly. Such a link might look something like this: <span class="italic">http://nodeshop.com/buy?item=nodeBook&amp;amount=1</span>. With this link, the customer buys a piece of the item, nodeBook. An attacker can now prepare their own page to plant such a link on a user. Once the user clicks on this link, the purchase takes place without the user being aware of it. The only requirement is that the user must be logged in to the web store. The situation gets even worse when the attacker hides the link in the <samp class="listingcharacter listingcharacter">src</samp> attribute of an image. The browser finds the <samp class="listingcharacter listingcharacter">&lt;img&gt;</samp> tag, tries to load it, and sends a request to the web store in which the purchase of the item is carried out. If the image has a height and width of zero pixels, this wouldn’t even be noticeable.</p>
            <p class="standard">Fortunately, there are means available to prevent this type of attack. The simplest variant is that you simply disable requests that come in via other domains. These are normally not possible anyway due to the browser’s same-origin policy<a class="indexanchor" id="i24_97"/>. But with cross-origin resource sharing<a class="indexanchor" id="i24_98"/> (CORS)<a class="indexanchor" id="i24_99"/>, such cross-domain requests become possible again. To reject requests from other domains, you can utilize the Origin header<a class="indexanchor" id="i24_100"/> of the incoming request. If the information in the header doesn’t match your own domain, you can reject the request.</p>
            <p class="standard">Additionally, you can secure the communication by means of tokens<a class="indexanchor" id="i24_101"/>. In this case, a three-step process takes place:</p>
            <ol>
                <li>
                    <p class="standard first-item last-item">The server sends a token to the client.</p>
                </li>
                <li>
                    <p class="standard first-item last-item">The client returns data to the server. These usually originate from a form and must contain the token.</p>
                </li>
                <li>
                    <p class="standard first-item last-item">If the token previously sent to the client doesn’t match the token returned by the client, the request gets discarded.</p>
                </li>
            </ol>
            <p class="standard">Of course, you don’t have to implement this process yourself, but can again use existing packages here. If you implement an application based on Express, you can use the <samp class="listingcharacter listingcharacter"><a id="p710"/>csurf</samp><a class="indexanchor" id="i24_102"/> package. The installation is done via the <samp class="listingcharacter listingcharacter">npm install csurf</samp> command. For <samp class="listingcharacter listingcharacter">csurf</samp> to work, you must install and enable either the cookie parser or session middleware such as <samp class="listingcharacter listingcharacter">express-session</samp>. <span class="crossreference "><a href="24_004.html#l24.28">Listing 24.28</a></span> shows how you can use <samp class="listingcharacter listingcharacter">csurf</samp>. For this example to work, you must install the <samp class="listingcharacter listingcharacter">cookie-parser</samp>, <samp class="listingcharacter listingcharacter">csurf</samp>, <samp class="listingcharacter listingcharacter">express</samp>-<samp class="listingcharacter listingcharacter">handlebars</samp>, and <samp class="listingcharacter listingcharacter">express</samp> packages.</p>
            <div class="listing " id="l24.28"><pre><span class="rot">import</span><span class="schwarz"> cookieParser </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'cookie-parser'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> bodyParser </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'body-parser'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> csurf </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'csurf'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> exphbs </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express-handlebars'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> express </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express'</span><span class="schwarz">;</span><br/> <br/><span class="rot">const</span><span class="schwarz"> csurfFunc </span><span class="dunkelblau">=</span><span class="schwarz"> csurf({ cookie: </span><span class="rot">true</span><span class="schwarz"> });</span><br/> <br/><span class="rot">const</span><span class="schwarz"> app </span><span class="dunkelblau">=</span><span class="schwarz"> express();</span><br/>app.use(cookieParser());<br/>app.engine(<span class="hellblau">'handlebars'</span><span class="schwarz">, exphbs({ defaultLayout: </span><span class="rot">false</span><span class="schwarz"> }));</span><br/>app.set(<span class="hellblau">'view engine'</span><span class="schwarz">, </span><span class="hellblau">'handlebars'</span><span class="schwarz">);</span><br/> <br/>app.get(<span class="hellblau">'/'</span><span class="schwarz">, csurfFunc, (req, res) </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  res.render(<span class="hellblau">'form'</span><span class="schwarz">, { csrfToken: req.csrfToken() });</span><br/>});<br/> <br/>app.post(<br/>  <span class="hellblau">'/form'</span><span class="schwarz">,</span><br/>  express.urlencoded({ extended: <span class="rot">false</span><span class="schwarz"> }),</span><br/>  csurfFunc,<br/>  (req, res) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>    res.send(<br/>      <span class="violett">`You just bought ${req.body.amount} pieces of ${req.body.article}`</span><span class="schwarz">,</span><br/>    );<br/>  },<br/>);<br/>app.listen(8080); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 24.28</b>    
            “csurf” in an Express.js Application (index.js)</p>
            <p class="standard">The template provides you with access to the <samp class="listingcharacter listingcharacter">csrfToken</samp> variable, which originates from the <samp class="listingcharacter listingcharacter">csurf</samp> middleware. The client must return this token as a <samp class="listingcharacter listingcharacter">hidden</samp> input field named <samp class="listingcharacter listingcharacter">_csrf</samp>. In the <samp class="listingcharacter listingcharacter">post</samp> route for the <samp class="listingcharacter listingcharacter">/form</samp> path, the <samp class="listingcharacter listingcharacter">csurf</samp> middleware then checks for the correctness of the token. If the token doesn’t match the expected value, an exception of the <samp class="listingcharacter listingcharacter">ForbiddenError</samp> type gets triggered. <span class="crossreference "><a href="24_004.html#l24.29">Listing 24.29</a></span> shows the template for the example.</p>
            <div class="listing " id="l24.29"><pre><a id="p711"/>&lt;form action="/form" method="POST"&gt;<br/>  &lt;input type="hidden" name="_csrf" value="{{csrfToken}}"&gt; Article:<br/>  &lt;input type="text" name="article"&gt; Amount:<br/>  &lt;input type="text" name="amount"&gt;<br/>  &lt;button type="submit"&gt;Buy&lt;/button&gt;<br/>&lt;/form&gt; </pre></div>
            <p class="caption "><b>Listing 24.29</b>    
            Handlebars Template for the “csurf” Example (views/form.handlebars)</p>
            <p class="standard">You should save the source code from in the <span class="italic">views</span> directory under the name <span class="italic">form.handlebars</span>. After that, you can test the example by starting the server process and then executing a request such as the one shown in <span class="crossreference "><a href="24_004.html#l24.30">Listing 24.30</a></span>. In this case, you’ll receive the following response: <samp class="listingcharacter listingcharacter">ForbiddenError: invalid csrf token</samp>.</p>
            <div class="listing " id="l24.30"><pre>curl <span class="dunkelblau">-</span><span class="schwarz">X POST </span><span class="dunkelblau">--</span><span class="schwarz">data '</span><span class="schwarz">{</span><span class="hellblau">"amount"</span><span class="schwarz">:30,</span><span class="schwarz"> </span><span class="hellblau">"article"</span><span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">"books"</span><span class="schwarz">}</span><span class="schwarz">' localhost</span><span class="schwarz">:8080</span><span class="dunkelblau">/</span><span class="schwarz">form </span></pre></div>
            <p class="caption "><b>Listing 24.30</b>    
            Invalid Request without CSRF Token</p>
            <p class="standard">As you can see, with the support of libraries, most security problems can be solved conveniently.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>