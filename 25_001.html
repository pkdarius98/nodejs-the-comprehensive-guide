<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Scalability and Deployment" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Scalability and Deployment" name="description"/>
            <meta content="en" name="language"/>
            <title>Scalability and Deployment</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main"><h1 class="t1" id="h25">25    <a id="p713"/>Scalability and Deployment</h1><p class="introductorynote indent_chapter_double">Before changing the world, it might be more important not to ruin it.<br/>—Paul Claudel</p><p class="standard">So<a class="indexanchor" id="i25_00"/><a class="indexanchor" id="i25_01"/> far, you’ve learned what options the Node.js platform provides for implementing web applications. These include a multitiered module system and a collection of high-performance libraries that allow you to run JavaScript and access the operating system. Once you’ve implemented part of your application, the question arises as to how users can test what they have seen so far to feed their feedback back into the development process. At this point at the latest, you have to deal with <span class="italic">deployment</span>, that is, how the source code of your application gets onto a system and is configured so that the application becomes usable.</p><p class="standard">In this chapter, you’ll see how you can transfer your application to the server<a class="indexanchor" id="i25_02"/>. Depending on the type of application, the degree of optimization<a class="indexanchor" id="i25_03"/>, and the available budget<a class="indexanchor" id="i25_04"/>, you can choose from a wide variety of deployment options. In the following sections, you’ll learn about different strategies from simple source code copying to automated deployment.</p><p class="standard">The second part of this chapter is dedicated to describing strategies for making sure that your system can handle the requests of your users throughout the application lifecycle. These strategies range from local optimization to load balancing across multiple systems to cloud-based solutions.</p>
        <h2 class="t2" id="h25.1">25.1    Deployment</h2>
        <p class="standard">Because there is no silver bullet for deploying an application, you’ll get to know several variants in the course of this chapter. These range from very simple solutions that merely consist of copying<a class="indexanchor" id="i25_05"/> source code to the target platform to extensive scenarios with a high degree of automation.</p>
        
            <h3 class="t3" id="h25.1.1">25.1.1    Simple Deployment</h3>
            <p class="standard">The simplest variant of deployment is to copy the source code from the system on which it’s developed to the target system. Normally, both systems, that is, the productive system and the developer system, should be separate systems. So, to copy the source code to the target system, you need a connection between the two systems.</p>
            
                <h4 class="t4" id="h25.1.1.1"><a id="p714"/>scp<a class="indexanchor" id="i25_06"/><a class="indexanchor" id="i25_07"/></h4>
                <p class="standard">Because Node.js can run on a wide range of systems, the connection options are also manifold. For example, if the target system is a Unix platform such as a Linux system, the Secure Shell (SSH) protocol is available to you. (For more information on this protocol, visit <span class="url"><a href="http://datatracker.ietf.org/wg/secsh/">http://datatracker.ietf.org/wg/secsh/</a></span>.) You can use the <samp class="listingcharacter listingcharacter">scp</samp> program to exchange source code between the two systems via a secure connection. <span class="crossreference "><a href="25_001.html#l25.1">Listing 25.1</a></span> shows an example of a corresponding command line.</p>
                <div class="listing " id="l25.1"><pre>$ scp -r /srv/node/myapp nodejs@prod.myexample.com:/srv/node </pre></div>
                <p class="caption "><b>Listing 25.1</b>    
            Deploying an Application by Copying the Source Code</p>
                <p class="standard">The command line shown in <span class="crossreference "><a href="25_001.html#l25.1">Listing 25.1</a></span> causes the <span class="italic">/srv/node/myapp</span> directory, which contains the updated source code of your application, to be copied to the <span class="italic">/srv/node</span> directory on the <span class="url"><a href="http://prod.myexample.com">prod.myexample.com</a></span> system. Authentication is required when connecting. This should be done via a key pair and not by entering a user name and password. For more information on this, you can visit <span class="url"><a href="https://help.ubuntu.com/community/SSH/OpenSSH/Keys">https://help.ubuntu.com/community/SSH/OpenSSH/Keys</a></span>, for example.<a class="indexanchor" id="i25_08"/> You should definitely make sure to include the <samp class="listingcharacter listingcharacter">-r</samp> option, or it won’t copy recursively, and you’ll receive an error message. This method doesn’t include synchronizing<a class="indexanchor" id="i25_09"/> the information. This means that new files are created correctly. Files that have a different state on the target system are simply overwritten with the new content. The disadvantage is that files which no longer exist in the new version of the source code are retained on the target system, however, and aren’t automatically deleted. You can avoid this problem by either completely deleting the target directory before copying, or at least emptying it.</p>
                <p class="standard">If you copy the source code of your application from the system on which you’re developing it to the production system, you should be aware that this process includes all files, that is, not only the source code, but also, for example, files and directories created by using a version control system<a class="indexanchor" id="i25_10"/> such as Git<a class="indexanchor" id="i25_11"/> (<span class="url"><a href="http://git-scm.com">http://git-scm.com</a></span>). This information isn’t part of your application, so it must not appear in the production system that your users have access to. This requirement has a very simple background: If you use Git for version control of your application, the <span class="italic">.git</span><a class="indexanchor" id="i25_12"/> directory<a class="indexanchor" id="i25_13"/> contains a complete clone of your repository. This can become a security risk if the users of your application can gain access to this directory and read its contents. Such a repository may contain security-critical information such as access information to the database server. So when deploying, you should exclude the <span class="italic">.git</span> directory from the copy operation.</p>
                <p class="standard">If your target system on which you want to run your application is a Windows system, you can copy your source code to the system using directory shares. After you’ve mounted the shared directory to your local system, you can copy the files either from the command line or from Windows Explorer.</p>
            
            
                <h4 class="t4" id="h25.1.1.2"><a id="p715"/>File Transfer Protocol</h4>
                <p class="standard">Another system-independent way to deploy the source code of your application is to use a File Transfer Protocol (FTP) server. FTP is a protocol specifically designed for the transfer of files. FTP clients are available for every system, so you shouldn’t have any problems here. To use FTP for deployment, an FTP server<a class="indexanchor" id="i25_14"/> must be installed and configured on the target system so that you can reach the target directory.</p>
                <p class="standard">Once you’ve successfully copied the source code of your application to the target system, you’re only one step away from you and your users being able to use the application. All you need to do at this point is launch your application. Even if you have only updated the software, a restart<a class="indexanchor" id="i25_15"/> of the application is required for Node.js to reread the application source code and for the changes to take final effect. If you don’t restart the application, problems and inconsistencies may occur because all components of the application that are executed directly have already been read, and most of them have been converted into machine code by the V8 engine. If you read files such as templates only at runtime, they’ll have an up-to-date status even without a restart.</p>
            
        
        
            <h3 class="t3" id="h25.1.2">25.1.2    File Synchronization via rsync<a class="indexanchor" id="i25_16"/></h3>
            <p class="standard">One of the problems that arise when deploying via the simplest variant, that is, copying, is that files which are no longer needed are retained. But even for this case, there are tools that make your life easier. One of these tools on Unix-based systems is <samp class="listingcharacter listingcharacter">rsync</samp>, which you can find at <span class="url"><a href="http://rsync.samba.org">http://rsync.samba.org</a></span>. It consists of two parts: a program and a protocol. The purpose of this tool is to synchronize<a class="indexanchor" id="i25_17"/> files between two systems. In this case, synchronization is always initiated by one side. For you, this means that you develop the source code of your application on a system as before and trigger the synchronization from this system to the server system on which the application is to be run. <samp class="listingcharacter listingcharacter">rsync</samp> is available as free software under the GNU General Public License (GPL). <span class="crossreference "><a href="25_001.html#l25.2">Listing 25.2</a></span> shows how easily you can synchronize the source code of your application using the <samp class="listingcharacter listingcharacter">rsync</samp> command line on your developer system. The example in <span class="crossreference "><a href="25_001.html#l25.1">Listing 25.1</a></span> is used as the basis here.</p>
            <div class="listing " id="l25.2"><pre>$ rsync -ar --delete /srv/node/myapp <br/>nodejs@prod.myexample.com:/srv/node/myapp </pre></div>
            <p class="caption "><b>Listing 25.2</b>    
            Synchronizing Source Code with “rsync”</p>
            <p class="standard">The command line in <span class="crossreference "><a href="25_001.html#l25.2">Listing 25.2</a></span> means that you want to initiate a synchronization process in which as many properties of the files as possible are to be retained via the <samp class="listingcharacter listingcharacter">-a</samp> option. <samp class="listingcharacter listingcharacter">-r</samp> means that the synchronization should take place recursively; that is, it should include subdirectories as well. The <samp class="listingcharacter listingcharacter">--delete</samp> option ensures that redundant files are removed on the remote system. Finally, the last two options specify the source and target of the synchronization process. If you aren’t sure whether the <samp class="listingcharacter listingcharacter">rsync</samp> command does exactly what you want it to do, you can use the <samp class="listingcharacter listingcharacter">--dry-run</samp><a class="indexanchor" id="i25_18"/> option to only simulate <a id="p716"/>the execution and see what effect the command will have on your target system. If there are new files on the source system or files whose contents have changed, these files are created on the target system, or the changes are applied, respectively. If a file no longer exists on the source system but still exists on the target system, this file will be deleted.</p>
            <p class="standard">The advantage of using <samp class="listingcharacter listingcharacter">rsync</samp> is that, similar to <samp class="listingcharacter listingcharacter">scp</samp>, you can use SSH for the file transport. Consequently, the transport of your data is encrypted. However, when you restart your application, the same applies as to the process of copying the files. You need to restart<a class="indexanchor" id="i25_19"/> your application’s process so that the updated source code files are reread.</p>
            <p class="standard">The next problem you come across when running a Node.js application is that your application stops running as soon as you reboot your system or it has rebooted itself for some reason.</p>
        
        
            <h3 class="t3" id="h25.1.3">25.1.3    Application as a Service</h3>
            <p class="standard">Even with the best operating system, it can happen occasionally that it has to be restarted—either because updates have been applied or because the system crashes<a class="indexanchor" id="i25_20"/> due to an error in the software or hardware or due to an operating error. If this happens, the application you launched from the command line won’t automatically restart too. Another issue involved with this way of launching your application is that you always have to connect to the server and access the command line to launch your application. The concept of services or daemons<a class="indexanchor" id="i25_21"/> provides help in this context. In essence, this means you make your application a service of the server system that is automatically booted at system startup. In this case, you no longer need to log in to the system and start the application manually. All you need to do is make sure that the system boots up. Everything else is done for you by your operating system. In the following sections, you’ll learn how to make your application run as a service on different systems.</p>
            
                <h4 class="t4" id="h25.1.3.1">Services on Unix<a class="indexanchor" id="i25_22"/></h4>
                <p class="standard">The various Unix distributions differ in the way the system’s services are started. One of the most widely used systems for managing services is systemd<a class="indexanchor" id="i25_23"/>. For this reason, here you’ll learn how you can create a service for your Node.js application using systemd. <span class="crossreference "><a href="25_001.html#l25.3">Listing 25.3</a></span> shows a simple variant of a unit script.</p>
                <div class="listing " id="l25.3"><pre>[Unit]<br/>Description=Express Application<br/>After=network.target<br/><br/>[Service]<br/>User=node<br/>WorkingDirectory=/srv/node<br/>ExecStart=npm start<br/><br/><a id="p717"/>[Install]<br/>WantedBy=multi-user.target </pre></div>
                <p class="caption "><b>Listing 25.3</b>    
            Startup Script for a Node.js Service on Ubuntu</p>
                <p class="standard">You can save this script under the name <span class="italic">express-app.service</span> in the <samp class="listingcharacter listingcharacter">/etc/system/system/</samp> directory. Then you can start your application via the <samp class="listingcharacter listingcharacter">sudo systemctl start express-app</samp> command. The <samp class="listingcharacter listingcharacter">sudo systemctl enable express-app</samp> command makes sure your application is launched automatically after system startup.</p>
            
            
                <h4 class="t4" id="h25.1.3.2">Services on Windows<a class="indexanchor" id="i25_24"/></h4>
                <p class="standard">With the help of a few workarounds, it’s also possible to start a Node.js server as a service on Windows. To do so, you need the source code of your application and two helper files. On the command line, you enter the command from <span class="crossreference "><a href="25_001.html#l25.4">Listing 25.4</a></span>.</p>
                <div class="listing " id="l25.4"><pre>instsrv.exe nodeServer C:\srvany.exe </pre></div>
                <p class="caption "><b>Listing 25.4</b>    
            Creating a Service</p>
                <p class="standard">The command from <span class="crossreference "><a href="25_001.html#l25.4">Listing 25.4</a></span> enables you to create an entry in the Windows registry for your application. With its help, you can start it as a service later. Then you use the <samp class="listingcharacter listingcharacter">regedit</samp> tool to create a new key named <span class="italic">parameters</span> via the path, <span class="italic">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\nodeServer</span>. You name it “Application” and assign it the type “REG_SZ” and the value “node C:\server.js”. Finally, the last step is to start the service via the service management of your system.</p>
                <p class="standard">The following sections describe some best practices for dealing with modules in applications.</p>
            
            
                <h4 class="t4" id="h25.1.3.3">node-windows<a class="indexanchor" id="i25_25"/>, node-mac<a class="indexanchor" id="i25_26"/>, and node-linux<a class="indexanchor" id="i25_27"/><a class="indexanchor" id="i25_28"/></h4>
                <p class="standard">Installing a Node.js application as an operating system service is quite cumbersome in most cases. For this reason, three projects have been launched to address this shortcoming. The projects are called <samp class="listingcharacter listingcharacter">node-windows</samp>, <samp class="listingcharacter listingcharacter">node-mac</samp>, and <samp class="listingcharacter listingcharacter">node-linux</samp>, depending on the operating system. All three packages are installed via Node Package Manager (npm). Normally, the installation should be done globally. In the following step, you need a configuration script<a class="indexanchor" id="i25_29"/> that is structured like the example in <span class="crossreference "><a href="25_001.html#l25.5">Listing 25.5</a></span>.</p>
                <div class="listing " id="l25.5"><pre><span class="rot">const</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> Service </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">require(</span><span class="hellblau">'node-windows'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="rot">const</span><span class="schwarz"> service </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">new </span><span class="schwarz">Service({</span><span class="schwarz"><br/></span>  name<span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">'Node.js Webserver'</span><span class="schwarz">,</span><span class="schwarz"><br/></span>  description<span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">'Webserver listening on port 80.'</span><span class="schwarz">,</span><span class="schwarz"><br/></span>  script<span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">'C:\\srv\\app\\index.js'</span><span class="schwarz">,</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"><br/></span><br/>service<span class="schwarz">.on(</span><span class="hellblau">'install'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span><a id="p718"/>  service<span class="schwarz">.start();</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"><br/></span><br/>service<span class="schwarz">.install();</span><span class="schwarz"> </span></pre></div>
                <p class="caption "><b>Listing 25.5</b>    
            Configuration for “node-windows”</p>
                <p class="standard">This configuration script allows you to register your application as an operating system service and respond to various events, such as deinstallation.</p>
            
        
        
            <h3 class="t3" id="h25.1.4">25.1.4    node_modules in Deployment<a class="indexanchor" id="i25_30"/></h3>
            <p class="standard">In most cases, you use modules from external sources such as the npm repository in your application. When deploying your application, you have two options for dealing with these modules: You can either install the modules on your developer system and deploy them from there to the production system, or exclude the modules from synchronization and install them separately on the production system.</p>
            <p class="standard">For npm modules that don’t have any external dependencies, such as Express or <samp class="listingcharacter listingcharacter">lodash</samp>, the first option, where you simply synchronize the <span class="italic">node_modules</span> directory as well, is no problem at all. These modules are system independent and can be easily copied. But things get more difficult with modules that are based on specific libraries. Examples of this primarily include database drivers such as the MySQL driver, which is based on <samp class="listingcharacter listingcharacter">libmysql</samp>, or the driver for SQLite3, which requires a working version of <samp class="listingcharacter listingcharacter">sqlite3</samp>. As long as the source and target systems have the same or very similar structures, hardly any problems are to be expected. However, if the systems have different software versions or even different operating systems, these modules won’t work. In this case, you have to resort to the second option of handling the <span class="italic">node_modules</span> directory and exclude from synchronization either the entire directory or at least the modules that cause problems. Following the deployment, you must then manually install or update the relevant modules on the target system. <span class="crossreference "><a href="25_001.html#l25.6">Listing 25.6</a></span> shows how you can use the <samp class="listingcharacter listingcharacter">--exclude</samp> option of <samp class="listingcharacter listingcharacter">rsync</samp> to avoid synchronizing the SQLite3 driver.</p>
            <div class="listing " id="l25.6"><pre>$ rsync -ar --delete --exclude='node_modules/sqlite3 /srv/node/myapp <br/>nodejs@prod.myexample.com:/srv/node/myapp </pre></div>
            <p class="caption "><b>Listing 25.6</b>    
            Excluding Modules from Synchronization</p>
            <p class="standard">In addition to these ways of deploying an application, you can of course use npm to install your application on a system.</p>
        
        
            <h3 class="t3" id="h25.1.5">25.1.5    Installing Applications Using Node Package Manager<a class="indexanchor" id="i25_31"/></h3>
            <p class="standard">In <span class="crossreference "><a href="21_001.html#h21">Chapter 21</a></span>, you learned how to publish an npm package to the npm registry, making it widely available. You can also use this platform to deploy your application. The <a id="p719"/>advantage of this deployment variant is that you can access the registry infrastructure. So, you don’t have to bother about hosting a repository and providing the servers needed to do so. Another advantage of using npm as a deployment tool is that you can draw on the functionality of the package manager. Specifically, this means you can install your application with just one command. In doing so, you don’t have to worry about resolving dependencies. Instead, the npm takes does this job for you; it downloads all the packages listed as dependencies in your application’s <span class="italic">package.json</span><a class="indexanchor" id="i25_32"/> file and saves them in the <span class="italic">node_modules</span> directory. The major drawback of this method is that any package you publish to the registry is freely available on the internet. This is usually not a problem for open-source projects<a class="indexanchor" id="i25_33"/>. However, for applications you create for yourself or for a company, publishing is usually out of the question. Such applications often contain access data to databases, algorithms, and workflows that shouldn’t fall into the hands of third parties. So if you want to use npm and the npm repository, you should consider it carefully and weigh the pros and cons. Alternatively, you can use the paid private repositories<a class="indexanchor" id="i25_34"/> of npm. They provide you with access control and can make your packages accessible only to certain people and systems.</p>
            <p class="standard">Another aspect to keep in mind when using npm for deployment is that you have to rely on the availability of the repository. This means you can’t install your application if you can’t access the npm registry, for example, because the server is offline. But there is a solution to this problem as well: The repository is based on standard components, and so in just a few steps, you can replicate the repository on your own server and then no longer depend on the central server being available. The basis for your own repository is CouchDB. CouchDB<a class="indexanchor" id="i25_35"/> is a database whose approach is similar to that of MongoDB. More information on CouchDB is available at <span class="url"><a href="https://couchdb.apache.org">https://couchdb.apache.org</a></span>. The contents of these databases are organized in documents. At <span class="url"><a href="https://www.npmjs.com/package/npm-registry-couchapp">https://www.npmjs.com/package/npm-registry-couchapp</a></span>, you can learn how to create a replication of the official <span class="url"><a href="http://npmjs.com">npmjs.com</a></span> repository. This process is relatively complex. Alternatively, you can use proxy solutions<a class="indexanchor" id="i25_36"/> such as Sinopia<a class="indexanchor" id="i25_37"/>, Verdaccio<a class="indexanchor" id="i25_38"/>, Artifactory<a class="indexanchor" id="i25_39"/>, or Nexus<a class="indexanchor" id="i25_40"/>, which cache responses from the repository locally. Additionally, you can publish your own packages on such a proxy server.</p>
            <p class="standard">Once you’ve set up your local npm repository, you need to make one more adjustment to the <samp class="listingcharacter listingcharacter">npm</samp> command before you can use your own repository. <span class="crossreference "><a href="25_001.html#l25.7">Listing 25.7</a></span> shows what this adjustment looks like.</p>
            <div class="listing " id="l25.7"><pre>npm config set http://localhost:5984/registry/_design/app/_rewrite </pre></div>
            <p class="caption "><b>Listing 25.7</b>    
            Setting the Registry URL for npm</p>
            <p class="standard">However, npm offers you yet another way to install applications on a system. The following section describes this in greater detail.</p>
        
        
            <h3 class="t3" id="h25.1.6">25.1.6    <a id="p720"/>Installing Packages Locally<a class="indexanchor" id="i25_41"/></h3>
            <p class="standard">If you don’t want to publish your application, the public npm repository isn’t an option. Instead, you can also use npm<a class="indexanchor" id="i25_42"/> to install packages locally. With this type of installation, you reap the benefits of both worlds. On one hand, you keep your own application under lock and key and make it available only to an authorized group of people, and, on the other hand, you can access the public repository for dependencies. All you need to do for this is to create a <span class="italic">package.json</span> file for your application that lists the dependencies, among other things. If you pack this file together with the source code of your application into a compressed tar archive<a class="indexanchor" id="i25_43"/> and make it available for download via a web server, you can easily install your application via the command line. <span class="crossreference "><a href="25_001.html#l25.8">Listing 25.8</a></span> is based on the assumption that you’re running a local web server and make the file <span class="italic">myApp.tgz</span> available there.</p>
            <div class="listing " id="l25.8"><pre>$ npm install http://localhost/myApp.tgz </pre></div>
            <p class="caption "><b>Listing 25.8</b>    
            Installing an npm Package from a Web Server</p>
            <p class="standard">In <span class="crossreference "><a href="25_001.html#l25.8">Listing 25.8</a></span>, the <span class="italic">myApp.tgz</span> file gets downloaded and unpacked. After that, the <span class="italic">package.json</span> file is evaluated, and the appropriate dependencies are downloaded and installed as well. Alternatively, you can save the file locally and install it from there by specifying the file name.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>