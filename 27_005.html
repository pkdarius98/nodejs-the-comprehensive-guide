<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Microservices with Node.js" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Microservices with Node.js" name="description"/>
            <meta content="en" name="language"/>
            <title>Microservices with Node.js</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h27.5">27.5    <a id="p768"/>API Gateway<a class="indexanchor" id="i27_53"/></h2>
        <p class="standard">The API gateway brings together the individual microservices of the application. This has the advantage that the clients of the application don’t communicate with multiple endpoints, but only with one central gateway, which can handle the internal distribution of requests and, in this role, is able to distribute the loads. In addition, the API gateway plays a security-critical role<a class="indexanchor" id="i27_54"/> by hiding the internal structure of the microservice application from the outside world.</p>
        <p class="standard">It also handles central tasks such as authentication and, if necessary, scheduling of encrypted communication<a class="indexanchor" id="i27_55"/>. Depending on the requirements, communication within the microservice application can also take place unencrypted on a secured network. In the following sections, you’ll learn how to implement authentication and route the requests to the user service.</p>
        
            <h3 class="t3" id="h27.5.1">27.5.1    Connecting the User Service<a class="indexanchor" id="i27_56"/></h3>
            <p class="standard">The API gateway is an Express application that has a model-view-controller (MVC) structure<a class="indexanchor" id="i27_57"/>. However, instead of communicating directly with a database in the models, you query the respective microservices at this point. You store the files of this service in the <span class="italic">api</span> directory parallel to the <span class="italic">user</span> directory. You initialize the API gateway in the first step via the <samp class="listingcharacter listingcharacter">npm init</samp> command to create a <span class="italic">package.json</span> file. Then you install Express and the <samp class="listingcharacter listingcharacter">uuid</samp> and <samp class="listingcharacter listingcharacter">amqplib</samp> packages using the <samp class="listingcharacter listingcharacter">npm install express uuid amqplib</samp> command. The resulting <span class="italic">package.json</span> file is shown in <span class="crossreference "><a href="27_005.html#l27.11">Listing 27.11</a></span>.</p>
            <div class="listing " id="l27.11"><pre><span class="schwarz">{</span><br/>  <span class="hellblau">"name"</span><span class="schwarz">: </span><span class="hellblau">"api-gateway"</span><span class="schwarz">,</span><br/>  <span class="hellblau">"version"</span><span class="schwarz">: </span><span class="hellblau">"1.0.0"</span><span class="schwarz">,</span><br/>  <span class="hellblau">"description"</span><span class="schwarz">: </span><span class="hellblau">""</span><span class="schwarz">,</span><br/>  <span class="hellblau">"main"</span><span class="schwarz">: </span><span class="hellblau">"index.js"</span><span class="schwarz">,</span><br/>  <span class="hellblau">"private"</span><span class="schwarz">: </span><span class="rot">true</span><span class="schwarz">,</span><br/>  <span class="hellblau">"type"</span><span class="schwarz">: </span><span class="hellblau">"module"</span><span class="schwarz">,</span><br/>  <span class="hellblau">"scripts"</span><span class="schwarz">: {</span><br/>    <span class="hellblau">"start"</span><span class="schwarz">: </span><span class="hellblau">"node index.js"</span><span class="schwarz"><br/></span>  },<br/>  <span class="hellblau">"keywords"</span><span class="schwarz">: [],</span><br/>  <span class="hellblau">"author"</span><span class="schwarz">: </span><span class="hellblau">""</span><span class="schwarz">,</span><br/>  <span class="hellblau">"license"</span><span class="schwarz">: </span><span class="hellblau">"ISC"</span><span class="schwarz">,</span><br/>  <span class="hellblau">"dependencies"</span><span class="schwarz">: {</span><br/>    <span class="hellblau">"amqplib"</span><span class="schwarz">: </span><span class="hellblau">"^0.8.0"</span><span class="schwarz">,</span><br/>    <span class="hellblau">"express"</span><span class="schwarz">: </span><span class="hellblau">"^4.17.1"</span><span class="schwarz">,</span><br/>    <span class="hellblau">"uuid"</span><span class="schwarz">: </span><span class="hellblau">"^8.3.2"</span><span class="schwarz"><br/></span> <br/>  }<br/>} <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.11</b>    
            “package.json” File of the API Gateway (api/package.json)</p>
            <p class="standard"><a id="p769"/>Based on this, you can then start implementing the API gateway entry point. This is a regular Express application with body parser<a class="indexanchor" id="i27_58"/> middleware and a separate router for the <span class="italic">/user</span> path. The source code of this entry file, which you save under the name <span class="italic">index.js</span> in the <span class="italic">api</span> directory, is shown in <span class="crossreference "><a href="27_005.html#l27.12">Listing 27.12</a></span>.</p>
            <div class="listing " id="l27.12"><pre><span class="rot">import</span><span class="schwarz"> express </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { router </span><span class="rot">as</span><span class="schwarz"> userRouter } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./user/index.js'</span><span class="schwarz">;</span><br/> <br/><span class="rot">const</span><span class="schwarz"> app </span><span class="dunkelblau">=</span><span class="schwarz"> express();</span><br/> <br/>app.use(express.json());<br/>app.use(<span class="hellblau">'/user'</span><span class="schwarz">, userRouter);</span><br/> <br/>app.listen(8080, () <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'API Gateway is listening'</span><span class="schwarz">)); </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.12</b>    
            Entry File to the API Gateway (api/index.js)</p>
            <p class="standard">In the API gateway, you provide a separate module in a separate subdirectory for each service that can be communicated with to decouple the application as much as possible. The router of the user module defines the public interface<a class="indexanchor" id="i27_59"/> with which the clients of the application can communicate. For the current development state of the application, only two routes are needed: one to query all user data and one to create users. You save the router in the <span class="italic">api/user/index.js</span> file, as shown in <span class="crossreference "><a href="27_005.html#l27.13">Listing 27.13</a></span>.</p>
            <div class="listing " id="l27.13"><pre><span class="rot">import</span><span class="schwarz"> { Router } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { getAllAction, createAction } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./controller.js'</span><span class="schwarz">;</span><br/> <br/><span class="rot">const</span><span class="schwarz"> router </span><span class="dunkelblau">=</span><span class="schwarz"> Router();</span><br/> <br/>router.get(<span class="hellblau">'/'</span><span class="schwarz">, getAllAction);</span><br/>router.post(<span class="hellblau">'/'</span><span class="schwarz">, createAction);</span><br/> <br/><span class="rot">export</span><span class="schwarz"> { router }; </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.13</b>    
            Router of the User Module (api/user/index.js)</p>
            <p class="standard">The two actions make sure that the required information gets extracted from the request and forwarded to the model. Finally, with the model’s response, you generate the response to the client, which you send in JSON format.</p>
            <p class="standard">When implementing the user controller in <span class="crossreference "><a href="27_005.html#l27.14">Listing 27.14</a></span>, you’re still independent of the underlying model, so the exchange of the communication link affects only one place, while the rest of the API gateway structure remains unchanged. In the implementation, you simply assume that the model passes the information and results via promises, which you handle in the controller with <samp class="listingcharacter listingcharacter">async</samp>/<samp class="listingcharacter listingcharacter">await</samp>.</p>
            <div class="listing " id="l27.14"><pre><span class="rot"><a id="p770"/>import</span><span class="schwarz"> { getAll, create } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./model.js'</span><span class="schwarz">;</span><br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">async</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> getAllAction(request, response) {</span><br/>  <span class="rot">try</span><span class="schwarz"> {</span><br/>    <span class="rot">const</span><span class="schwarz"> userData </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> getAll();</span><br/>    response.json(userData);<br/>  } <span class="rot">catch </span><span class="schwarz">(</span><span class="rot">e</span><span class="schwarz">) {</span><br/>    <span class="magenta">console</span><span class="schwarz">.error(e);</span><br/>    response.status(500).json(<span class="hellblau">'Interal server error'</span><span class="schwarz">);</span><br/>  }<br/>}<br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">async</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> createAction(request, response) {</span><br/>  <span class="rot">try</span><span class="schwarz"> {</span><br/>    <span class="rot">const</span><span class="schwarz"> newUser </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> create(request.body);</span><br/>    response.json(newUser);<br/>  } <span class="rot">catch </span><span class="schwarz">(</span><span class="rot">e</span><span class="schwarz">) {</span><br/>    <span class="magenta">console</span><span class="schwarz">.error(e);</span><br/>    response.status(500).json(<span class="hellblau">'Internal server error'</span><span class="schwarz">);</span><br/>  }<br/>} <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.14</b>    
            Implementation of the User Controller in the API Gateway (user/api/controller.js)</p>
        
        
            <h3 class="t3" id="h27.5.2">27.5.2    Asynchronous Communication with the User Service<a class="indexanchor" id="i27_60"/></h3>
            <p class="standard">Up to this point, you’ve structured the API gateway like a traditional Express application. The problem now is that you have to work with a very decoupled type of communication. For a normal database or web service that you address via HTTP<a class="indexanchor" id="i27_61"/>, you can use promises or callback functions. In this case, however, you send a message to the message queue, which is accepted by the user service and answered at a later time. Because the model is primarily concerned with communication, this is the first place you need to worry about exchanging information with the message queue. In <span class="crossreference "><a href="27_005.html#l27.15">Listing 27.15</a></span>, you send a message over the message queue within the <samp class="listingcharacter listingcharacter">getAll</samp> and the <samp class="listingcharacter listingcharacter">create</samp> function each, which is accepted and processed by the user service.</p>
            <div class="listing " id="l27.15"><pre><span class="rot">import</span><span class="schwarz"> { v4 </span><span class="rot">as</span><span class="schwarz"> uuidv4 } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'uuid'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { getChannel, queue } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'../connect.js'</span><span class="schwarz">;</span><br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">async</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> getAll() {</span><br/>  <span class="rot">const</span><span class="schwarz"> channel </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> getChannel();</span><br/>  <span class="rot">const</span><span class="schwarz"> message </span><span class="dunkelblau">=</span><span class="schwarz"> {</span><br/>    id: uuidv4(),<br/><a id="p771"/>    role: <span class="hellblau">'user'</span><span class="schwarz">,</span><br/>    cmd: <span class="hellblau">'getAll'</span><span class="schwarz">,</span><br/>  };<br/> <br/>  channel.sendToQueue(queue, Buffer.from(JSON.stringify(message)));<br/> <br/>  <span class="rot">return</span><span class="schwarz"> message;</span><br/>}<br/> <br/>Export <span class="rot">async</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> create(data) {</span><br/>  <span class="rot">const</span><span class="schwarz"> channel </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> getChannel();</span><br/>  <span class="rot">const</span><span class="schwarz"> message </span><span class="dunkelblau">=</span><span class="schwarz"> {</span><br/>    id: uuidv4(),<br/>    role: <span class="hellblau">'user'</span><span class="schwarz">,</span><br/>    cmd: <span class="hellblau">'create'</span><span class="schwarz">,</span><br/>    data,<br/>  };<br/> <br/>  channel.sendToQueue(queue, Buffer.from(JSON.stringify(message)));<br/> <br/>  <span class="rot">return</span><span class="schwarz"> message;</span><br/>} <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.15</b>    
            Model Implementation in the API Gateway (api/user/model.js)</p>
            <p class="standard">The central element of the model implementation is the communication with the message queue. So, at this point, you need to make some adjustments to the source code of your application to handle this changed method of information exchange. The core of the implementation is the <span class="italic">connect.js</span> file in the <span class="italic">api</span> directory. It’s responsible for connecting to the message queue<a class="indexanchor" id="i27_62"/> and provides functions you can use to process the asynchronous messages.</p>
            <p class="standard"><span class="crossreference "><a href="27_005.html#l27.16">Listing 27.16</a></span> contains the source code of the <span class="italic">connect.js</span> file in the <span class="italic">api</span> directory. You already know the <samp class="listingcharacter listingcharacter">getChannel</samp> function from the user service. You also use this function in the API gateway to connect to the message queue. One difference from the previous approach can be found in the <samp class="listingcharacter listingcharacter">registerHandler</samp> function. This function uses the <samp class="listingcharacter listingcharacter">consume</samp> method of the <samp class="listingcharacter listingcharacter">channel</samp> object you created using the <samp class="listingcharacter listingcharacter">getChannel</samp> function to receive messages. The <samp class="listingcharacter listingcharacter">registerHandler</samp> function responds only to messages with <samp class="listingcharacter listingcharacter">role user</samp> and <samp class="listingcharacter listingcharacter">cmd answer</samp>. To map a response from the user service to a command from the API gateway, you use the <samp class="listingcharacter listingcharacter">id</samp> of the messages, which are the same for the request and response. The pattern you build here is referred to as request/reply<a class="indexanchor" id="i27_63"/>. You can find a detailed description of this pattern at <span class="url"><a href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html">www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html</a></span>.</p>
            <div class="listing " id="l27.16"><pre><span class="rot"><a id="p772"/>import</span><span class="schwarz"> { connect } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'amqplib'</span><span class="schwarz">;</span><br/> <br/><span class="rot">let</span><span class="schwarz"> channel </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">null</span><span class="schwarz">;</span><br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">const</span><span class="schwarz"> queue </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="hellblau">'user'</span><span class="schwarz">;</span><br/> <br/><span class="rot">const</span><span class="schwarz"> registry </span><span class="dunkelblau">=</span><span class="schwarz"> {};</span><br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> register(id, response) {</span><br/>  registry[id] <span class="dunkelblau">=</span><span class="schwarz"> response;</span><br/>}<br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> answer(id, data) {</span><br/>  registry[id].send(data);<br/>  <span class="rot">delete</span><span class="schwarz"> registry[id];</span><br/>}<br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">async</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> getChannel() {</span><br/>  <span class="rot">try</span><span class="schwarz"> {</span><br/>    <span class="rot">if</span><span class="schwarz"> (channel) {</span><br/>      <span class="rot">return</span><span class="schwarz"> channel;</span><br/>    }<br/>    <span class="rot">const</span><span class="schwarz"> connection </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> connect(</span><span class="hellblau">'amqp://rabbitmq'</span><span class="schwarz">);</span><br/>    channel <span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> connection.createChannel();</span><br/> <br/>    <span class="rot">const</span><span class="schwarz"> ok </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> channel.assertQueue(queue);</span><br/> <br/>    <span class="rot">if</span><span class="schwarz"> (ok) {</span><br/>      <span class="rot">return</span><span class="schwarz"> channel;</span><br/>    }<br/>  } <span class="rot">catch </span><span class="schwarz">(</span><span class="rot">error</span><span class="schwarz">) {</span><br/>    <span class="magenta">console</span><span class="schwarz">.error(error);</span><br/>    <span class="rot">throw</span><span class="schwarz"> error;</span><br/>  }<br/>}<br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> registerHandler(channel) {</span><br/>  channel.consume(queue, (receivedMessage) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>    <span class="rot">const</span><span class="schwarz"> messageData </span><span class="dunkelblau">=</span><span class="schwarz"> JSON.parse(receivedMessage.content.toString());</span><br/> <br/>    <span class="rot">if</span><span class="schwarz"> (messageData.role </span><span class="dunkelblau">===</span><span class="schwarz"> </span><span class="hellblau">'user'</span><span class="schwarz"> </span><span class="dunkelblau">&amp;&amp;</span><span class="schwarz"> messageData.cmd </span><span class="dunkelblau">===</span><span class="schwarz"> </span><span class="hellblau">'answer'</span><span class="schwarz">) {</span><br/>      answer(messageData.id, messageData.data);<br/>      channel.ack(receivedMessage);<br/>    } <span class="rot">else</span><span class="schwarz"> {</span><br/>      channel.nack(receivedMessage);<br/><a id="p773"/>    }<br/>  });<br/>} <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.16</b>    
            Connecting the Message Queue (api/connect.js)</p>
            <p class="standard">In the API gateway, you save the response objects of the user requests in an object structure named <samp class="listingcharacter listingcharacter">registry</samp> with the <samp class="listingcharacter listingcharacter">id</samp> of the message as the key. If a message is received from the user service via the message queue, you can extract the response object from the <samp class="listingcharacter listingcharacter">registry</samp> object and send the data received from the user service to the user as a JSON response. To secure the communication, you can include time-outs<a class="indexanchor" id="i27_64"/>. If a message is received and takes longer to process than the specified time-out value, the receiver throws an exception. In the code example, caching the response objects is done by calling the <samp class="listingcharacter listingcharacter">register</samp> function in the controller, whereas responding to the request is done using the <samp class="listingcharacter listingcharacter">answer</samp> function you call inside the <samp class="listingcharacter listingcharacter">registerHandler</samp> function.</p>
            <p class="standard">In the next step, you need to integrate the functions of this file into the application. Let’s start with the entry into the API gateway—the <span class="italic">index.js</span> file in the <span class="italic">api</span> directory. Here you call the <samp class="listingcharacter listingcharacter">getChannel</samp> and <samp class="listingcharacter listingcharacter">registerHandler</samp> functions, as shown in <span class="crossreference "><a href="27_005.html#l27.17">Listing 27.17</a></span>.</p>
            <div class="listing " id="l27.17"><pre><span class="rot">import</span><span class="schwarz"> express </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { router </span><span class="rot">as</span><span class="schwarz"> userRouter } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./user/index.js'</span><span class="schwarz">;</span><br/><span class="bold"><samp class="listingcharacter listingcharacter"><span class="rot">import</span><span class="schwarz"> { getChannel, registerHandler } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./connect.js'</span><span class="schwarz">;</span><br/> <br/><span class="rot">const</span><span class="schwarz"> channel </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> getChannel();</span><br/>registerHandler(channel);<br/> </samp></span><br/><span class="rot">const</span><span class="schwarz"> app </span><span class="dunkelblau">=</span><span class="schwarz"> express();</span><br/> <br/>app.use(express.json());<br/>app.use(<span class="hellblau">'/user'</span><span class="schwarz">, userRouter);</span><br/> <br/>app.listen(8080, () <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'API Gateway is listening'</span><span class="schwarz">)); </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.17</b>    
            Connecting to the Message Queue (api/index.js)</p>
            <p class="standard">For a complete implementation of the communication between API gateway and the user service, you only need to handle the responses of the user service in the API gateway. This is done in the controller of the user module, that is, in the <span class="italic">controller.js</span> file in the <span class="italic">user</span> directory of the API gateway, as shown in <span class="crossreference "><a href="27_005.html#l27.18">Listing 27.18</a></span>.</p>
            <div class="listing " id="l27.18"><pre><span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="rot">import</span><span class="schwarz"> { register } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'../connect.js'</span><span class="schwarz">;</span></samp></span><br/><span class="rot">import</span><span class="schwarz"> { getAll, create } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./model.js'</span><span class="schwarz">;</span><br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">async</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> getAllAction(request, response) {</span><br/>  <span class="rot">try</span><span class="schwarz"> {</span><br/><a id="p774"/>    <span class="bold"><samp class="listingcharacter listingcharacter"><span class="rot">const</span><span class="schwarz"> { id } </span><span class="dunkelblau">=</span></samp></span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> getAll();</span><br/>    <span class="bold"><samp class="listingcharacter listingcharacter">register(id, response);</samp></span><br/>  } <span class="rot">catch </span><span class="schwarz">(</span><span class="rot">e</span><span class="schwarz">) {</span><br/>    <span class="magenta">console</span><span class="schwarz">.error(e);</span><br/>    response.status(500).json(<span class="hellblau">'Interal server error'</span><span class="schwarz">);</span><br/>  }<br/>}<br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">async</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> createAction(request, response) {</span><br/>  <span class="rot">try</span><span class="schwarz"> {</span><br/>    <span class="bold"><samp class="listingcharacter listingcharacter"><span class="rot">const</span><span class="schwarz"> { id } </span><span class="dunkelblau">=</span></samp></span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> create(request.body);</span><br/>    <span class="bold"><samp class="listingcharacter listingcharacter">register(id, response);</samp></span><br/>  } <span class="rot">catch </span><span class="schwarz">(</span><span class="rot">e</span><span class="schwarz">) {</span><br/>    <span class="magenta">console</span><span class="schwarz">.error(e);</span><br/>    response.status(500).json(<span class="hellblau">'Internal server error'</span><span class="schwarz">);</span><br/>  }<br/>} <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.18</b>    
            Integrating Message Queue Responses (api/user/controller.js)</p>
            <p class="standard">When all data records have been read and when you create a new one, you receive the created message object from the model<a class="indexanchor" id="i27_65"/>. From this, you extract the <samp class="listingcharacter listingcharacter">id</samp> of the message using a destructuring statement and call the <samp class="listingcharacter listingcharacter">register</samp> function from the <span class="italic">connect.js</span> file with this information and the <samp class="listingcharacter listingcharacter">response</samp> object. As soon as the response is received via the message queue, the user’s request is answered with the data from the user service.</p>
        
        
            <h3 class="t3" id="h27.5.3">27.5.3    Docker Setup of the API Gateway<a class="indexanchor" id="i27_66"/></h3>
            <p class="standard">Before you can test your application, you still need a container for the API gateway. For this purpose, you must create a file named <span class="italic">Dockerfile</span> and place it in the root directory of the API gateway. You can see the contents of this file in <span class="crossreference "><a href="27_005.html#l27.19">Listing 27.19</a></span>.</p>
            <div class="listing " id="l27.19"><pre>FROM node<span class="schwarz">:16.8.0</span><br/>WORKDIR <span class="dunkelblau">/</span><span class="schwarz">usr</span><span class="dunkelblau">/</span><span class="schwarz">src</span><span class="dunkelblau">/</span><span class="schwarz">app</span><br/>COPY <span class="rot">package</span><span class="dunkelblau">*</span><span class="schwarz">.json .</span><span class="dunkelblau">/</span><span class="schwarz"><br/></span>RUN npm install<br/>COPY . .<br/>EXPOSE 8080<br/>CMD [ <span class="hellblau">"node"</span><span class="schwarz">, </span><span class="hellblau">"index.js"</span><span class="schwarz"> ] </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.19</b>    
            Dockerfile for the API Gateway (api/Dockerfile)</p>
            <p class="standard">You integrate the API Gateway container<a class="indexanchor" id="i27_67"/> into your <span class="italic">docker-compose.yml</span> file in the next step, as you can see in <span class="crossreference "><a href="27_005.html#l27.20">Listing 27.20</a></span>.</p>
            <div class="listing " id="l27.20"><pre><a id="p775"/>Version<span class="schwarz">: </span><span class="hellblau">'3'</span><span class="schwarz"><br/></span>services:<br/>  mongodb:<br/>    image: mongo:latest<br/>    container_name: <span class="hellblau">'mongodb'</span><span class="schwarz"><br/></span>    ports:<br/>      <span class="dunkelblau">-</span><span class="schwarz"> 27017:27017</span><br/>  mongo<span class="dunkelblau">-</span><span class="schwarz">seed:</span><br/>    image: mongo:latest<br/>    links:<br/>      <span class="dunkelblau">-</span><span class="schwarz"> mongodb</span><br/>    volumes:<br/>      <span class="dunkelblau">-</span><span class="schwarz"> .</span><span class="dunkelblau">/</span><span class="schwarz">initUser.json:</span><span class="dunkelblau">/</span><span class="schwarz">initUser.json</span><br/>    command: <span class="hellblau">'mongoimport -host mongodb -db users -collection users  </span><img alt="inline image" class="inline_image" src="bilder/umbruchpfeil.png"/><br/>      -type json -file /initUser.json -jsonArray'<span class="schwarz"><br/></span>  rabbitmq:<br/>    image: rabbitmq:latest<br/>    ports:<br/>      <span class="dunkelblau">-</span><span class="schwarz"> 5672:5672</span><br/>  user:<br/>    build:<br/>      context: user<br/>    depends_on:<br/>      <span class="dunkelblau">-</span><span class="schwarz"> </span><span class="hellblau">'mongodb'</span><span class="schwarz"><br/></span>      <span class="dunkelblau">-</span><span class="schwarz"> </span><span class="hellblau">'rabbitmq'</span><span class="schwarz"><br/></span>    restart: on<span class="dunkelblau">-</span><span class="schwarz">failure</span><br/>    links:<br/>      <span class="dunkelblau">-</span><span class="schwarz"> </span><span class="hellblau">'rabbitmq'</span><span class="schwarz"><br/></span>  <span class="bold"><samp class="listingcharacter listingcharacter">api:<br/>    build:<br/>      context: api<br/>    ports:<br/>      <span class="dunkelblau">-</span><span class="schwarz"> 8080:8080</span><br/>    depends_on:<br/>      <span class="dunkelblau">-</span></samp></span><span class="schwarz"> </span><span class="hellblau">'</span><span class="bold"><samp class="listingcharacter listingcharacter">user</samp></span>'<span class="schwarz"><br/></span>    <span class="bold"><samp class="listingcharacter listingcharacter">restart: on<span class="dunkelblau">-</span><span class="schwarz">failure</span><br/>    links:<br/>      <span class="dunkelblau">-</span><span class="schwarz"> rabbitmq </span></samp></span> <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.20</b>    
            “docker-compose.yml” File Extension</p>
            <p class="standard">Now you can start your application via the <samp class="listingcharacter listingcharacter">docker-compose up</samp> command and access the API gateway. The simplest variant is to open the address <span class="italic">http://localhost:8080/user</span> in your browser. Then the combination of API gateway and user service will provide the <a id="p776"/>list of existing users. Things will get more interesting when you use the creating endpoint, that is, <span class="italic">http://localhost:8080/user</span>, with the <samp class="listingcharacter listingcharacter">POST</samp> method. To do this, you can either use a command-line tool such as cURL<a class="indexanchor" id="i27_68"/> or a graphical interface such as Postman. <span class="crossreference "><a href="27_005.html#l27.21">Listing 27.21</a></span> shows the corresponding cURL command, while <span class="crossreference "><a href="27_005.html#f27.6">Figure 27.6</a></span> shows the view in Postman.</p>
            <div class="listing " id="l27.21"><pre>$ curl <br/>  -X POST <br/>  –-data '{"username": "jdoe", "password": "test"}' <br/>  –-header 'content-type:application/json' <br/>  localhost:8080/user </pre></div>
            <p class="caption "><b>Listing 27.21</b>    
            Creating a New User with cURL</p>
            <div class="imagebox figure-type"><a href="img-f27.6.html" id="f27.6"><img alt="Creating a New User with Postman" id="img-f27.6" src="bilderklein/klein27_006.png"/></a></div>
            <p class="caption "><b>Figure 27.6</b>    
            Creating a New User with Postman</p>
        
        
            <h3 class="t3" id="h27.5.4">27.5.4    Authentication<a class="indexanchor" id="i27_69"/></h3>
            <p class="standard">Currently, all users can still access their endpoints uncontrolled. But we’ll change that in the next step. Because microservices don’t care about authentication, you need to implement this in the API gateway. Depending on how you implement your application, you can choose from different mechanisms. In this context, the authentication via JSON web tokens (JWTs)<a class="indexanchor" id="i27_70"/> has become widely used. You already learned about the implementation of this strategy in detail in <span class="crossreference "><a href="09_001.html#h9">Chapter 9</a></span>, so we’ll limit the discussion here to a brief overview as well as the implementation of the relevant code passages.</p>
            <p class="standard"><a id="p777"/>You install the packages required for JWT authentication<a class="indexanchor" id="i27_71"/> in the API gateway, that is, in the <span class="italic">api</span> directory, using the <samp class="listingcharacter listingcharacter">npm install jsonwebtoken express-jwt</samp> command. Then you create a new file named <span class="italic">auth.js</span> containing the routes relevant for authentication. <span class="crossreference "><a href="27_005.html#l27.22">Listing 27.22</a></span> shows the source code of this file.</p>
            <div class="listing " id="l27.22"><pre><span class="rot">import</span><span class="schwarz"> jwt </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'jsonwebtoken'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { Router } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { getAll } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./user/model.js'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { register } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./connect.js'</span><span class="schwarz">;</span><br/> <br/><span class="rot">const</span><span class="schwarz"> router </span><span class="dunkelblau">=</span><span class="schwarz"> Router();</span><br/> <br/>router.post(<span class="hellblau">'/'</span><span class="schwarz">, </span><span class="rot">async</span><span class="schwarz"> (request, response) </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="rot">try</span><span class="schwarz"> {</span><br/>    <span class="rot">const</span><span class="schwarz"> { id } </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> getAll();</span><br/>    register(id, (users) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>      <span class="rot">const</span><span class="schwarz"> user </span><span class="dunkelblau">=</span><span class="schwarz"> users.find(</span><br/>        (u) <span class="dunkelblau">=&gt;</span><span class="schwarz"><br/></span>          u.username <span class="dunkelblau">===</span><span class="schwarz"> request.body.username </span><span class="dunkelblau">&amp;&amp;</span><span class="schwarz"><br/></span>          u.password <span class="dunkelblau">===</span><span class="schwarz"> request.body.password,</span><br/>      );<br/> <br/>      <span class="rot">if</span><span class="schwarz"> (user) {</span><br/>        <span class="rot">const</span><span class="schwarz"> payload </span><span class="dunkelblau">=</span><span class="schwarz"> { ...user };</span><br/>        <span class="rot">delete</span><span class="schwarz"> payload.password;</span><br/>        <span class="rot">const</span><span class="schwarz"> token </span><span class="dunkelblau">=</span><span class="schwarz"> jwt.sign(payload, </span><span class="hellblau">'secret'</span><span class="schwarz">);</span><br/>        response.json({ token });<br/>      } <span class="rot">else</span><span class="schwarz"> {</span><br/>        response.status(401).json(<span class="hellblau">'unauthorized'</span><span class="schwarz">);</span><br/>      }<br/>    });<br/>  } <span class="rot">catch</span><span class="schwarz"> € {</span><br/>    response.status(401).json(<span class="hellblau">'unauthorized'</span><span class="schwarz">);</span><br/>  }<br/>});<br/> <br/><span class="rot">export</span><span class="schwarz"> { router };  </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.22</b>    
            Authentication in the API Gateway (api/auth.js)</p>
            <p class="standard">The logic behind the <samp class="listingcharacter listingcharacter">login</samp> route<a class="indexanchor" id="i27_72"/> works a bit differently from the previous implementations in the user controller. For this reason, a modification in the <span class="italic">connect.js</span> file is also required. So far, you’ve passed the <samp class="listingcharacter listingcharacter">id</samp> of the request and the response object. A response via the message queue ensured that the data was sent directly to the user. In this case, you need the user data, but the requesting user should receive a token<a class="indexanchor" id="i27_73"/> and not the user <a id="p778"/>list. Consequently, you make sure that you can register a callback function in addition to the response object. In <span class="crossreference "><a href="27_005.html#l27.23">Listing 27.23</a></span>, you already benefit from this modification and register such a callback function, which then takes care of sending the response to the user.</p>
            <div class="listing " id="l27.23"><pre><span class="rot">import</span><span class="schwarz"> { connect } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'amqplib'</span><span class="schwarz">;</span><br/> <br/><span class="rot">let</span><span class="schwarz"> channel </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">null</span><span class="schwarz">;</span><br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">const</span><span class="schwarz"> queue </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="hellblau">'user'</span><span class="schwarz">;</span><br/> <br/><span class="rot">const</span><span class="schwarz"> registry </span><span class="dunkelblau">=</span><span class="schwarz"> {};</span><br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> register(id, response) {...}</span><br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> answer(id, data) {</span><br/>  <span class="bold"><samp class="listingcharacter listingcharacter"><span class="rot">if</span><span class="schwarz"> (</span><span class="rot">typeof</span><span class="schwarz"> registry[id] </span><span class="dunkelblau">===</span><span class="schwarz"> </span><span class="hellblau">'function'</span><span class="schwarz">) {</span><br/>    registry[id](data);<br/>  } <span class="rot">else</span><span class="schwarz"> {</span></samp></span><br/>    registry[id].send(data);<br/>  <span class="bold"><samp class="listingcharacter listingcharacter">}</samp></span><br/>  <span class="rot">delete</span><span class="schwarz"> registry[id];</span><br/>}<br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">async</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> getChannel() {...}</span><br/> <br/><span class="rot">export</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> registerHandler(channel) {...} </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.23</b>    
            Modification of the “connect.js” File (api/connect.js)</p>
            <p class="standard">To enable authentication, you include the router you just created from the <span class="italic">auth.js</span> file in your application’s entry file and secure the user route with <samp class="listingcharacter listingcharacter">express-jwt</samp><a class="indexanchor" id="i27_74"/>. In <span class="crossreference "><a href="27_005.html#l27.24">Listing 27.24</a></span>, you can see how this works.</p>
            <div class="listing " id="l27.24"><pre><span class="rot">import</span><span class="schwarz"> express </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'express'</span><span class="schwarz">;</span><br/><span class="bold"><samp class="listingcharacter listingcharacter"><span class="rot">import</span><span class="schwarz"> expressJwt </span><span class="rot">from</span></samp></span><span class="schwarz"> </span><span class="hellblau">'</span><span class="bold"><samp class="listingcharacter listingcharacter">express-jwt</samp></span>'<span class="bold"><samp class="listingcharacter listingcharacter"><span class="schwarz">;</span></samp></span><br/><span class="rot">import</span><span class="schwarz"> { router </span><span class="rot">as</span><span class="schwarz"> userRouter } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./user/index.js'</span><span class="schwarz">;</span><br/><span class="bold"><samp class="listingcharacter listingcharacter"><span class="rot">import</span><span class="schwarz"> { router </span><span class="rot">as</span><span class="schwarz"> loginRouter } </span><span class="rot">from</span></samp></span><span class="schwarz"> </span><span class="hellblau">'</span><span class="bold"><samp class="listingcharacter listingcharacter">./auth.js</samp></span>'<span class="bold"><samp class="listingcharacter listingcharacter"><span class="schwarz">;</span></samp></span><br/><span class="rot">import</span><span class="schwarz"> { getChannel, registerHandler } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'./connect.js'</span><span class="schwarz">;</span><br/> <br/><span class="rot">const</span><span class="schwarz"> channel </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> getChannel();</span><br/>registerHandler(channel);<br/> <br/><span class="rot">const</span><span class="schwarz"> app </span><span class="dunkelblau">=</span><span class="schwarz"> express();</span><br/> <br/>app.use(express.json());<br/><span class="bold"><samp class="listingcharacter listingcharacter"><a id="p779"/>app.use(</samp></span><span class="hellblau">'</span><span class="bold"><samp class="listingcharacter listingcharacter">/login</samp></span>'<span class="bold"><samp class="listingcharacter listingcharacter"><span class="schwarz">, loginRouter);</span></samp></span><br/>app.use(<span class="hellblau">'/user'</span><span class="schwarz">, </span><span class="bold"><samp class="listingcharacter listingcharacter">expressJwt({ secret:</samp></span> <span class="hellblau">'</span><span class="bold"><samp class="listingcharacter listingcharacter">secret</samp></span>'<span class="bold"><samp class="listingcharacter listingcharacter"><span class="schwarz"> }),</span></samp></span> userRouter);<br/> <br/><span class="bold"><samp class="listingcharacter listingcharacter">app.use((err, request, response, next) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="rot">if</span><span class="schwarz"> (err.name </span><span class="dunkelblau">===</span></samp></span><span class="schwarz"> </span><span class="hellblau">'</span><span class="bold"><samp class="listingcharacter listingcharacter">UnauthorizedError</samp></span>'<span class="bold"><samp class="listingcharacter listingcharacter"><span class="schwarz">) {</span><br/>    response.status(401).json(</samp></span><span class="hellblau">'</span><span class="bold"><samp class="listingcharacter listingcharacter">unauthorized</samp></span>'<span class="bold"><samp class="listingcharacter listingcharacter"><span class="schwarz">);</span><br/>  } <span class="rot">else</span><span class="schwarz"> {</span><br/>    next();<br/>  }<br/>});<br/> </samp></span><br/>app.listen(8080, () <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'API Gateway is listening'</span><span class="schwarz">)); </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 27.24</b>    
            Integrating Authentication (api/index.js)</p>
            <p class="standard">The integration of an authentication process now enables you to assign requests to your application to specific users and filter the delivered results accordingly. For this purpose, you need to pass this information to the individual microservices. In the simplest case, this can be done by using parameters in the request. Alternatively, you can implement a central user service that microservices can request. For this to work, the API gateway passes the user’s identification as a token<a class="indexanchor" id="i27_75"/> to the microservice, which has the token resolved by the central user service and thus receives the user information.</p>
            <p class="standard">After you’ve created a JWT using the <samp class="listingcharacter listingcharacter">login</samp> route, you can use Postman or cURL<a class="indexanchor" id="i27_76"/> to create new users and read the current user list. <span class="crossreference "><a href="27_005.html#l27.25">Listing 27.25</a></span> shows the cURL call you can use to generate a new JWT.</p>
            <div class="listing " id="l27.25"><pre><span class="bold"><samp class="listingcharacter listingcharacter">$ curl <br/>  -H "Content-Type: application/json" <br/>  -X POST <br/>  -d</samp></span> '<span class="bold"><samp class="listingcharacter listingcharacter">{</samp></span>"<span class="bold"><samp class="listingcharacter listingcharacter">username</samp></span>"<span class="bold"><samp class="listingcharacter listingcharacter">:</samp></span> "<span class="bold"><samp class="listingcharacter listingcharacter">sspringer</samp></span>"<span class="bold"><samp class="listingcharacter listingcharacter">,</samp></span> "<span class="bold"><samp class="listingcharacter listingcharacter">password</samp></span>"<span class="bold"><samp class="listingcharacter listingcharacter">:</samp></span> "<span class="bold"><samp class="listingcharacter listingcharacter">test</samp></span>"<span class="bold"><samp class="listingcharacter listingcharacter">}</samp></span>' <br/>  <span class="bold"><samp class="listingcharacter listingcharacter">http://localhost:8080/login</samp></span><br/>{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyIwIjp7Il9pZCI6IjViMzc0ZWI2NzQ0MDQzMDQ1OGRmN2JhMCIsInVzZXJuYW1lIjoic3NwcmluZ2VyIiwicGFzc3dvcmQiOiJ0ZXN0In0sIjEiOnsiX2lkIjoiNWIzNzUwNWUzYzg3YzljMjJlNzIyMGU2IiwidXNlcm5hbWUiOiJzc3ByaW5nZXIiLCJwYXNzd29yZCI6inRlc3QifSwiMiI6eyJfaWQiOiI1YjM3NTBiYzAxN2MxODk1ZjA1MzFlM2EiLCJ1c2VybmFtZSI6InNzcHJpbmdlciIsInBhc3N3b3JkIjoidGVzdCJ9LCIzIjp7Il9pZCI6IjViM2IwYWQwMDE3YzE4OTVmMDUzMWVkMyIsInVzZXJuYW1lIjoic3NwcmluZ2VyIiwicGFzc3dvcmQiOiJ0ZXN0In0sImlhdCI6MTUzMDY4MTIxN30.skb4ubpta8-YcA35cIJML54Cm2-Ty6UFTik2tHMgzJ0"} </pre></div>
            <p class="caption "><b>Listing 27.25</b>    
            Creating a New Token</p>
            <p class="standard">With the token, you can now read the user list, for example. For this purpose, as shown in <span class="crossreference "><a href="27_005.html#l27.26">Listing 27.26</a></span>, you send a <samp class="listingcharacter listingcharacter">GET</samp> request to <span class="italic">http://localhost:8080/user</span> and set the <samp class="listingcharacter listingcharacter">authorization</samp> header<a class="indexanchor" id="i27_77"/> accordingly. In response, you’ll receive a list of users of the system.</p>
            <div class="listing " id="l27.26"><pre><span class="bold"><samp class="listingcharacter listingcharacter"><a id="p780"/>$ curl -H "Content-Type: application/json" -H "Authorization: Bearer I1NiIsInR 5cCI6IkpXVCJ9.eyIwIjp7Il9pZCI6IjViMzc0ZWI2NzQ0MDQzMDQ1OGRmN2JhMCIsInVzZXJuYW1lIjoic3NwcmluZ2VyIiwicGFzc3dvcmQiOiJ0ZXN0In0sIjEiOnsiX2lkIjoiNWIzNzUwNWUzYzg3YzljMjJlNzIyMGU2IiwidXNlcm5hbWUiOiJzc3ByaW5nZXIiLCJwYXNzd29yZCI6InRlc3QifSwiMiI6eyJfaWQiOiI1YjM3NTBiYzAxN2MxODk1ZjA1MzFlM2EiLCJ1c2vybmFtZSI6InNzcHJpbmdlciIsInBhc3N3b3JkIjoidGVzdCJ9LCIzIjp7Il9pZCI6IjViM2IwYWQwMDE3YzE4OTVmMDUzMWVkMyIsInVzZXJuYW1lIjoic3NwcmluZ2VyIiwicGFzc3dvcmQiOiJ0ZXN0I0sImlhdCI6MTUzMDY4MTIxN30.skb4ubpta8-YcA35cIJML54Cm2-Ty6UFTik2tHMgzJ0" http://localhost:8080/user</samp></span><br/>[<br/>{"_id":"5b374eb67440430458df7ba0","username":"sspringer","password":"test"},<br/>{"_id":"5b3751191efbf54985a67480","username":"John","password":"secret"},<br/>] </pre></div>
            <p class="caption "><b>Listing 27.26</b>    
            Reading the User List</p>
            <p class="standard">This step completes another component of your microservice application, as you can see in <span class="crossreference "><a href="27_005.html#f27.7">Figure 27.7</a></span>.</p>
            <div class="imagebox figure-type"><a href="img-f27.7.html" id="f27.7"><img alt="API Gateway in the Microservice Architecture" id="img-f27.7" src="bilderklein/klein27_007.png"/></a></div>
            <p class="caption "><b>Figure 27.7</b>    
            API Gateway in the Microservice Architecture</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>