<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="RxJS" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - RxJS" name="description"/>
            <meta content="en" name="language"/>
            <title>RxJS</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h17.2">17.2    Operators<a class="indexanchor" id="i17_34"/></h2>
        <p class="standard">The operators represent the core of RxJS. If you use the library without the operators, that is, only the observables and observers, you only have an <samp class="listingcharacter listingcharacter">EventEmitter</samp> with some limitations, which we’ll describe in <span class="crossreference "><a href="17_003.html#h17.3">Section 17.3</a></span> on RxJS subjects. ReactiveX define a variety of different operators. To be able to keep the overview in this context, several <a id="p526"/>tools are available to you. In a first, rather rough overview, the operators are divided into several categories<a class="indexanchor" id="i17_35"/>:</p>
        <ul>
            <li>
                <p class="standard first-item last-item"><span class="bold">Creation operators<br/></span>These types of operators are used to generate new observables.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Transformation operators<br/></span>You can use these operators to convert data packages of an observable into a different form.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Filtering operators<br/></span>These operators allow you to respond only to specific data packages in the observable.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Join operators<br/></span>With RxJS, you can combine multiple observables. This category of operators provides you with the necessary tools to do so.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Error handling operators<br/></span>In addition to the error callback in the <samp class="listingcharacter listingcharacter">subscribe</samp> method of the observable, you can use these operators to deal with errors that occur.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Utility operators<br/></span>This category includes operators that provide additional help in dealing with observables.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Conditional operators<br/></span>You can formulate conditions based on these operators.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Connection operators<br/></span>These operators affect the behavior of the <samp class="listingcharacter listingcharacter">subscribe</samp> method of an observable.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Conversion operator<br/></span>The operator of this category is used to transform an observable into another data structure.</p>
            </li>
        </ul>
        <p class="standard">In addition to the different types of operators, there is also a decision tree<a class="indexanchor" id="i17_36"/> you can use to find the right operator for you at <span class="url"><a href="https://rxjs.dev/operator-decision-tree">https://rxjs.dev/operator-decision-tree</a></span>. However, the best way to get familiar with and master the use of RxJS and its operators is by actively applying them. If you’re new to RxJS, you should practice using the library in a secured environment to get used to using the individual elements. You’ll see that the more often you use the tool, the more confident and quicker your choice of the appropriate operator will be.</p>
        <p class="standard">If you take a look at the<a class="indexanchor" id="i17_37"/> ReactiveX documentation, you’ll quickly come across the <span class="italic">marble diagrams</span><a class="indexanchor" id="i17_38"/>, which are visual representations of how various operators work. The individual events of an observable are displayed as circles. In the upper part of such a diagram you can see the input stream, below it follows the application of the operator, and in the lower part of the figure is the result. <span class="crossreference "><a href="17_002.html#f17.1">Figure 17.1</a></span> contains the marble diagram <a id="p527"/>for the <samp class="listingcharacter listingcharacter">map</samp> operator. An input stream with integer values is multiplied by 10 by the <samp class="listingcharacter listingcharacter">map</samp> operator. In the output stream, the resulting values are located below the input values in each case to clarify the mapping.</p>
        <div class="imagebox figure-type"><a href="img-f17.1.html" id="f17.1"><img alt="Marble Diagram for the “map” Operator" id="img-f17.1" src="bilderklein/klein17_001.png"/></a></div>
        <p class="caption "><b>Figure 17.1</b>    
            Marble Diagram for the “map” Operator</p>
        <p class="standard">When using operators, the rule is that you group them via the <samp class="listingcharacter listingcharacter">pipe</samp> method of the observable. The <samp class="listingcharacter listingcharacter">pipe</samp> method accepts a variable number of operators as arguments that are applied to each data package of the observable in the order in which they are passed. Only the creation operators represent a special form because they aren’t applied to an observable; instead, they create observables themselves and return them. Consequently, these operators aren’t used in conjunction with the <samp class="listingcharacter listingcharacter">pipe</samp> method.</p>
        <p class="standard">In the following sections, you’ll learn about various operators in each category and see how you can use RxJS in the Node.js environment based on practical examples.</p>
        
            <h3 class="t3" id="h17.2.1">17.2.1    Creation Operators<a class="indexanchor" id="i17_39"/></h3>
            <p class="standard">So far, you’ve already become acquainted with two creation operators, namely, the <samp class="listingcharacter listingcharacter">from</samp> and the <samp class="listingcharacter listingcharacter">create</samp> operator. The <samp class="listingcharacter listingcharacter">from</samp> operator is especially versatile, as you’ll see next.</p>
            
                <h4 class="t4" id="h17.2.1.1">from<a class="indexanchor" id="i17_40"/> Operator</h4>
                <p class="standard">You can apply the <samp class="listingcharacter listingcharacter">from</samp> operator not only to array structures<a class="indexanchor" id="i17_41"/> but also to other iterable data structures<a class="indexanchor" id="i17_42"/> and promises<a class="indexanchor" id="i17_43"/>. The example in <span class="crossreference "><a href="17_002.html#l17.8">Listing 17.8</a></span> shows how you can convert a read file system operation to an observable.</p>
                <div class="listing " id="l17.8"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> readFile </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'fs/promises'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="schwarz">from(readFile(</span><span class="hellblau">'input.txt'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'utf-8'</span><span class="schwarz">))</span><span class="schwarz"><br/></span>  <span class="schwarz">.subscribe((</span><span class="schwarz">content</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'file: '</span><span class="schwarz">,</span><span class="schwarz"> content</span><span class="schwarz">);</span><span class="gruen"> // Output: file: Hello RxJS</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
                <p class="caption "><b>Listing 17.8</b>    
            “from” Operator for Promises</p>
                <p class="standard"><a id="p528"/>In <span class="crossreference "><a href="17_002.html#l17.8">Listing 17.8</a></span>, you use the promise-based variant of the <samp class="listingcharacter listingcharacter">readFile</samp> function. Using the <samp class="listingcharacter listingcharacter">from</samp> operator, you convert this promise into an observable so that you have access to all RxJS operators. When dealing with file system operations<a class="indexanchor" id="i17_44"/>, you should know that RxJS behaves the same way as the rest of the file system operations in Node.js: RxJS processes the file in blocks. In this case, the promise is resolved with the entire contents of the file, so RxJS doesn’t know line breaks or word separators. If you want to read a file line by line, you have to solve this yourself.</p>
            
            
                <h4 class="t4" id="h17.2.1.2">fromEvent<a class="indexanchor" id="i17_45"/>: Using EventEmitter Objects</h4>
                <p class="standard">Numerous interfaces in Node.js use the <samp class="listingcharacter listingcharacter">EventEmitter</samp> class. The <samp class="listingcharacter listingcharacter">fromEvent</samp> operator allows you to create an observable for specific events. In <span class="crossreference "><a href="17_002.html#l17.9">Listing 17.9</a></span>, we use the web server example and apply the <samp class="listingcharacter listingcharacter">fromEvent</samp> operator.</p>
                <div class="listing " id="l17.9"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'http'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> fromEvent </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> server </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createServer().listen(8080,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Server is listening'</span><span class="schwarz">),</span><span class="schwarz"><br/></span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/><span class="schwarz">fromEvent(</span><span class="schwarz">server</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'request'</span><span class="schwarz">).subscribe(([,</span><span class="schwarz"> response</span><span class="schwarz">])</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  response<span class="schwarz">.end(</span><span class="hellblau">'Hello RxJS'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
                <p class="caption "><b>Listing 17.9</b>    
            “fromEvent” Operator with a Web Server</p>
                <p class="standard">The reference to the web server you created via the <samp class="listingcharacter listingcharacter">createServer</samp> function derives from the <samp class="listingcharacter listingcharacter">EventEmitter</samp> class. Each incoming request triggers the <samp class="listingcharacter listingcharacter">request</samp> event. For this event, you create a new observable using the <samp class="listingcharacter listingcharacter">fromEvent</samp> operator. When a new request is received, an event gets triggered on the observable, and then all registered operators and the callback function you passed to the <samp class="listingcharacter listingcharacter">subscribe</samp> method are executed. One special feature you should note is that the object references of the event, that is, request and response, exist in the form of an array, which is why you need the destructuring operation in the <samp class="listingcharacter listingcharacter">subscribe</samp> call.</p>
            
            
                <h4 class="t4" id="h17.2.1.3">interval: Creating Time Intervals<a class="indexanchor" id="i17_46"/></h4>
                <p class="standard">Another frequently used operator is <samp class="listingcharacter listingcharacter">interval</samp>. This operator creates an observable that triggers an event at regular intervals, similar to the <samp class="listingcharacter listingcharacter">setInterval</samp> function. The <samp class="listingcharacter listingcharacter">interval</samp> operator is particularly well suited for combinations with other operators because it only returns a number representing the current run.</p>
                <p class="standard">Every second, the source code in <span class="crossreference "><a href="17_002.html#l17.10">Listing 17.10</a></span> triggers an event you subscribe to. In the callback function, you output the number of the current run and the current date and time.</p>
                <div class="listing " id="l17.10"><pre><span class="rot"><a id="p529"/>import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> interval </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="schwarz">interval(1000)</span><span class="schwarz"><br/></span>  <span class="schwarz">.subscribe((</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="magenta">console</span><span class="schwarz">.log(</span><span class="violett">`Iteration ${data}: ${new Date()}`</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
                <p class="caption "><b>Listing 17.10</b>    
            Creating Time Intervals</p>
                <p class="standard">With the <samp class="listingcharacter listingcharacter">interval</samp> operator, you should also note that it executes the first event only after the initial time span has elapsed, in this example, after one second. You can manipulate this behavior via the <samp class="listingcharacter listingcharacter">startWith</samp><a class="indexanchor" id="i17_47"/> operator, for example.</p>
            
        
        
            <h3 class="t3" id="h17.2.2">17.2.2    Transformation Operators<a class="indexanchor" id="i17_48"/></h3>
            <p class="standard">A transformation operator performs a classic mapping of an input value to an output according to defined rules. A typical example of a transformation operator is the <samp class="listingcharacter listingcharacter">map</samp> function<a class="indexanchor" id="i17_49"/>, which you already got to know at the beginning of this chapter.</p>
            
                <h4 class="t4" id="h17.2.2.1">scan<a class="indexanchor" id="i17_50"/>: Accumulator<a class="indexanchor" id="i17_51"/> Operator</h4>
                <p class="standard">Another example is the <samp class="listingcharacter listingcharacter">scan</samp> operator. You pass a function to it in which you have access to the current element as well as the result of the last execution of the function. <span class="crossreference "><a href="17_002.html#l17.11">Listing 17.11</a></span> clarifies this context.</p>
                <div class="listing " id="l17.11"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> range </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> scan </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="schwarz">range(1,</span><span class="schwarz"> </span><span class="schwarz">10)</span><span class="schwarz"><br/></span>  <span class="schwarz">.pipe(scan((</span><span class="schwarz">acc</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="magenta">value</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> acc </span><span class="dunkelblau">+</span><span class="schwarz"> </span><span class="magenta">value</span><span class="schwarz">))</span><span class="schwarz"><br/></span>  <span class="schwarz">.subscribe((</span><span class="magenta">value</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="magenta">value</span><span class="schwarz">));</span><span class="schwarz"> </span></pre></div>
                <p class="caption "><b>Listing 17.11</b>    
            Applying the “scan” Operator</p>
                <p class="standard">The <samp class="listingcharacter listingcharacter">range</samp><a class="indexanchor" id="i17_52"/> operator generates a sequence of numbers. In this case, it starts at <samp class="listingcharacter listingcharacter">1</samp> and ends at <samp class="listingcharacter listingcharacter">10</samp>. An event is triggered for each value. On the first run, the <samp class="listingcharacter listingcharacter">scan</samp> operator receives the values <samp class="listingcharacter listingcharacter">0</samp> as the initial value because the function hasn’t been executed before, and <samp class="listingcharacter listingcharacter">1</samp> as the first value of the sequence of numbers. With the second event, the values <samp class="listingcharacter listingcharacter">1</samp> and <samp class="listingcharacter listingcharacter">2</samp> are passed, then with the third event <samp class="listingcharacter listingcharacter">3</samp> and <samp class="listingcharacter listingcharacter">3</samp>. The execution ends with the 10th value.</p>
            
            
                <h4 class="t4" id="h17.2.2.2">buffer: Buffering Observables<a class="indexanchor" id="i17_53"/></h4>
                <p class="standard">You can use the <samp class="listingcharacter listingcharacter">buffer</samp> operator to aggregate the events of an observable<a class="indexanchor" id="i17_54"/>. For this purpose, you combine two observables. The events of the outer observable are supposed to be buffered. The inner observable specifies the size of the buffer. In <span class="crossreference "><a href="17_002.html#l17.12">Listing 17.12</a></span>, the outer observable triggers an event every 100 milliseconds. The <samp class="listingcharacter listingcharacter">map</samp> operator enables <a id="p530"/>you to turn the continuous sequence into a random number between <samp class="listingcharacter listingcharacter">0</samp> and <samp class="listingcharacter listingcharacter">100</samp>. By using the <samp class="listingcharacter listingcharacter">buffer</samp> operator with another interval of one second, you make sure that all events of the outer observable are grouped together. In the callback of the <samp class="listingcharacter listingcharacter">subscribe</samp> method, this causes you to receive an array of multiple numbers instead of single numbers. <span class="crossreference "><a href="17_002.html#l17.13">Listing 17.13</a></span> shows an excerpt from the output.</p>
                <div class="listing " id="l17.12"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> interval </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> map</span><span class="schwarz">,</span><span class="schwarz"> buffer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="schwarz">interval(100)</span><span class="schwarz"><br/></span>  <span class="schwarz">.pipe(</span><span class="schwarz"><br/></span>    <span class="schwarz">map(()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> Math</span><span class="schwarz">.floor(</span><span class="schwarz">Math</span><span class="schwarz">.random()</span><span class="schwarz"> </span><span class="dunkelblau">*</span><span class="schwarz"> </span><span class="schwarz">100)),</span><span class="schwarz"><br/></span>    <span class="schwarz">buffer(interval(1000)),</span><span class="schwarz"><br/></span>  <span class="schwarz">)</span><span class="schwarz"><br/></span>  <span class="schwarz">.subscribe((</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">data</span><span class="schwarz">));</span><span class="schwarz"> </span></pre></div>
                <p class="caption "><b>Listing 17.12</b>    
            Buffering Observables</p>
                <div class="listing " id="l17.13"><pre>[ 40, 16, 21, 29, 4, 26, 14, 98, 33 ]<br/>[ 42, 12, 56, 5, 93, 21, 13, 80, 28, 42 ]<br/>[ 93, 24, 42, 30, 40, 72, 10, 32, 52, 79 ]<br/>... </pre></div>
                <p class="caption "><b>Listing 17.13</b>    
            Output When Buffering Observables</p>
                <p class="standard">The <samp class="listingcharacter listingcharacter">interval</samp> observables used in this example are intended to be examples of any asynchronous observables. At this point, you can also use any <samp class="listingcharacter listingcharacter">EventEmitters</samp>, whose events you can combine in this way.</p>
            
            
                <h4 class="t4" id="h17.2.2.3">mergeMap<a class="indexanchor" id="i17_55"/></h4>
                <p class="standard">The <samp class="listingcharacter listingcharacter">mergeMap</samp> operator is a mixture of a transformation and a join operator<a class="indexanchor" id="i17_56"/>. It links an outer observable with an inner observable and produces new data packages from it. You can use this operator, for example, if you have interdependent asynchronous queries. In the example in <span class="crossreference "><a href="17_002.html#l17.14">Listing 17.14</a></span>, you first query a resource to which a user is assigned. In a second request, you add all the user information to that resource. Due to the abstraction of the observables, you can perform the queries here using both promises and <samp class="listingcharacter listingcharacter">EventEmitters</samp>. The higher-level logic remains unaffected.</p>
                <div class="listing " id="l17.14"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> Observable </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> mergeMap </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> resources </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">return</span><span class="schwarz"> Observable</span><span class="schwarz">.create((</span><span class="schwarz">observer</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    observer<span class="schwarz">.next({</span><span class="schwarz"><br/></span>      id<span class="schwarz">:</span><span class="schwarz"> </span><span class="schwarz">1,</span><span class="schwarz"><br/></span><a id="p531"/>      name<span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">'Main resource'</span><span class="schwarz">,</span><span class="schwarz"><br/></span>      user<span class="schwarz">:</span><span class="schwarz"> </span><span class="schwarz">2,</span><span class="schwarz"><br/></span>    <span class="schwarz">});</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">};</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> usersForResource </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">resource</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">return</span><span class="schwarz"> Observable</span><span class="schwarz">.create((</span><span class="schwarz">observer</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    observer<span class="schwarz">.next({</span><span class="schwarz"><br/></span>      <span class="schwarz">...</span><span class="schwarz">resource</span><span class="schwarz">,</span><span class="schwarz"><br/></span>      user<span class="schwarz">:</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>        id<span class="schwarz">:</span><span class="schwarz"> </span><span class="schwarz">2,</span><span class="schwarz"><br/></span>        name<span class="schwarz">:</span><span class="schwarz"> </span><span class="hellblau">'John'</span><span class="schwarz">,</span><span class="schwarz"><br/></span>      <span class="schwarz">},</span><span class="schwarz"><br/></span>    <span class="schwarz">});</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"><br/></span><span class="schwarz">};</span><span class="schwarz"><br/></span> <br/><span class="schwarz">resources()</span><span class="schwarz"><br/></span>  <span class="schwarz">.pipe(mergeMap((</span><span class="schwarz">resource</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">usersForResource(</span><span class="schwarz">resource</span><span class="schwarz">)))</span><span class="schwarz"><br/></span>  <span class="schwarz">.subscribe((</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">data</span><span class="schwarz">));</span><span class="schwarz"> </span></pre></div>
                <p class="caption "><b>Listing 17.14</b>    
            Using the “mergeMap” Operator</p>
                <p class="standard">The place where you can insert the asynchronous queries to a server system or database are the respective callback functions in the <samp class="listingcharacter listingcharacter">create</samp> calls.</p>
                <p class="standard">In addition to the <samp class="listingcharacter listingcharacter">mergeMap</samp> operator, other operators, such as <samp class="listingcharacter listingcharacter">flatMap</samp>, <samp class="listingcharacter listingcharacter">switchMap</samp>, and <samp class="listingcharacter listingcharacter">concatMap</samp>, are also capable of transforming an outer observable based on an inner observable, with the <samp class="listingcharacter listingcharacter">flatMap</samp> operator merely being an alias for <samp class="listingcharacter listingcharacter">mergeMap</samp>. In general, you use these operators when you need to subscribe to another observable in the <samp class="listingcharacter listingcharacter">subscribe</samp> method of an observable. The difference between the three operators is in the details of how you handle the order of the packages or whether the inner subscription is terminated, as described here:</p>
                <ul>
                    <li>
                        <p class="standard first-item last-item"><span class="bold"><samp class="listingcharacter listingcharacter">mergeMap</samp></span><span class="bold">/</span><a class="indexanchor" id="i17_57"/><span class="bold"><samp class="listingcharacter listingcharacter">flatMap</samp></span> <span class="bold"><samp class="listingcharacter listingcharacter"><br/></samp></span>This operator maintains the order in which the data packages are supplied, which means that the packages of different observables may overlap. The inner subscriptions aren’t terminated, but continue to run.</p>
                    </li>
                    <li>
                        <p class="standard first-item last-item"><span class="bold"><samp class="listingcharacter listingcharacter">switchMap</samp></span><a class="indexanchor" id="i17_58"/><br/>This operator takes only one data package of the inner observable and then proceeds to the next package of the outer observable.</p>
                    </li>
                    <li>
                        <p class="standard first-item last-item"><span class="bold"><samp class="listingcharacter listingcharacter">concatMap</samp></span><a class="indexanchor" id="i17_59"/><br/>Unlike <samp class="listingcharacter listingcharacter">mergeMap</samp>, the data packages of the different observables aren’t mixed. For this, the operator waits for the inner observable to complete.</p>
                    </li>
                </ul>
            
        
        
            <h3 class="t3" id="h17.2.3">17.2.3    <a id="p532"/>Filtering Operators<a class="indexanchor" id="i17_60"/></h3>
            <p class="standard">While with the transformation operators you changed the data packages of the observable, you use the filtering operators to restrict the data flow based on specific rules. You already got to know the classic <samp class="listingcharacter listingcharacter">filtering</samp> operator at the beginning of this chapter. It’s called with the current data package and passes it to the following operator or observer if the filtering condition is met.</p>
            <p class="standard">In addition to the <samp class="listingcharacter listingcharacter">filtering</samp> operator, this category contains operators that can be used to avoid a manual unsubscribe process. Typical representatives of this category are <samp class="listingcharacter listingcharacter">first</samp>, <samp class="listingcharacter listingcharacter">last</samp>, and the various <samp class="listingcharacter listingcharacter">take</samp> operators.</p>
            
                <h4 class="t4" id="h17.2.3.1">Access to Specific Elements<a class="indexanchor" id="i17_61"/> in an Observable</h4>
                <p class="standard">Not only do the RxJS operators allow you to filter all elements of an observable according to certain criteria, you can also limit the number of elements. For example, if you’re only interested in the first or last element, you can use the <samp class="listingcharacter listingcharacter">first</samp><a class="indexanchor" id="i17_62"/> or <samp class="listingcharacter listingcharacter">last</samp><a class="indexanchor" id="i17_63"/> operator, respectively. The <samp class="listingcharacter listingcharacter">take</samp><a class="indexanchor" id="i17_64"/> operator enables you to specify how many elements you want to obtain. Irrespective of which of these operators you use, as soon as the condition is met, an unsubscribe automatically takes place.</p>
                <div class="listing " id="l17.15"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> range </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> take</span><span class="schwarz">,</span><span class="schwarz"> first</span><span class="schwarz">,</span><span class="schwarz"> last </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="schwarz">range(1,</span><span class="schwarz"> </span><span class="schwarz">10)</span><span class="schwarz"><br/></span>  <span class="schwarz">.pipe(</span><span class="bold"><samp class="listingcharacter listingcharacter">first()</samp></span>)<br/>  .subscribe((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'first: '</span><span class="schwarz">, data));</span><br/>range(1, 10)<br/>  .pipe(<span class="bold"><samp class="listingcharacter listingcharacter">take(2)</samp></span>)<br/>  .subscribe((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'take 2: '</span><span class="schwarz">, data));</span><br/>range(1, 10)<br/>  .pipe(<span class="bold"><samp class="listingcharacter listingcharacter">last()</samp></span>)<br/>  .subscribe((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'last: '</span><span class="schwarz">, data)); </span><span class="schwarz"/></pre></div>
                <p class="caption "><b>Listing 17.15</b>    
            Using the “first”, “take”, and “last” Operators</p>
                <p class="standard">The <samp class="listingcharacter listingcharacter">last</samp> operator represents a special type. For it to work, the observable must be terminated. If this isn’t the case, the subscription callback function won’t be called. When using the <samp class="listingcharacter listingcharacter">range</samp> operator, the observable is terminated after the last element, and the <samp class="listingcharacter listingcharacter">last</samp> operator is called correctly, which you can see from the output on the console.</p>
                <p class="standard">For example, if you create an observable yourself with the <samp class="listingcharacter listingcharacter">create</samp> operator and let it fire values regularly in combination with an interval, you must call the <samp class="listingcharacter listingcharacter">complete</samp> method<a class="indexanchor" id="i17_65"/> of the observer to finish. <span class="crossreference "><a href="17_002.html#l17.16">Listing 17.16</a></span> illustrates this context with a concrete example.</p>
                <div class="listing " id="l17.16"><pre><span class="rot"><a id="p533"/>import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> Observable </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> last </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/>Observable<span class="schwarz">.create((</span><span class="schwarz">observer</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">let</span><span class="schwarz"> count </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">0;</span><span class="schwarz"><br/></span>  <span class="rot">const</span><span class="schwarz"> interval </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">setInterval(()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="dunkelblau">++</span><span class="schwarz">count </span><span class="dunkelblau">&gt;=</span><span class="schwarz"> </span><span class="schwarz">10)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      <span class="schwarz">clearInterval(</span><span class="schwarz">interval</span><span class="schwarz">);</span><span class="schwarz"><br/></span>      observer<span class="schwarz">.next(</span><span class="schwarz">count</span><span class="schwarz">);</span><span class="schwarz"><br/></span>      <span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter">observer.complete();</samp></span><br/>    }<br/>    observer.next(count);<br/>  }, 10);<br/>})<br/>  .pipe(last())<br/>  .subscribe((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'last: '</span><span class="schwarz">, data)); </span><span class="schwarz"/></pre></div>
                <p class="caption "><b>Listing 17.16</b>    
            The “last” Operator with a Self-Generated Observable</p>
                <p class="standard">If you comment out the line containing the <samp class="listingcharacter listingcharacter">observer.complete</samp> call, the callback function isn’t executed, and you won’t get any output on the console. Stumbling blocks like this always increase the amount of work during development when you debug the application.</p>
                <p class="standard">Operator <samp class="listingcharacter listingcharacter">takeUntil</samp><a class="indexanchor" id="i17_66"/> and its opposite <samp class="listingcharacter listingcharacter">skipUntil</samp><a class="indexanchor" id="i17_67"/> work similarly to the <samp class="listingcharacter listingcharacter">take</samp> operator, except that you don’t get a number but an observable and become active as soon as this observable fires.</p>
            
            
                <h4 class="t4" id="h17.2.3.2">Rejecting<a class="indexanchor" id="i17_68"/> Events with debounceTime<a class="indexanchor" id="i17_69"/></h4>
                <p class="standard">The <samp class="listingcharacter listingcharacter">debounceTime</samp> operator enables you to debounce packages based on time. Let’s take the example with the RxJS-based web server. Here you can automatically reject requests if there isn’t at least a period of five seconds between two requests. <span class="crossreference "><a href="17_002.html#l17.17">Listing 17.17</a></span> shows the actual implementation based on <span class="crossreference "><a href="17_002.html#l17.9">Listing 17.9</a></span>.</p>
                <div class="listing " id="l17.17"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createServer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'http'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> fromEvent </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> debounceTime </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> server </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createServer().listen(8080,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Server is listening'</span><span class="schwarz">),</span><span class="schwarz"><br/></span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/><span class="schwarz">fromEvent(</span><span class="schwarz">server</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'request'</span><span class="schwarz">)</span><span class="schwarz"><br/></span>  <span class="schwarz">.pipe(</span><span class="bold"><samp class="listingcharacter listingcharacter">debounceTime(5000)</samp></span>)<br/><a id="p534"/>  .subscribe(([, response]) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>    response.end(<span class="hellblau">'Hello RxJS'</span><span class="schwarz">);</span><br/>  }); <span class="schwarz"/></pre></div>
                <p class="caption "><b>Listing 17.17</b>    
            Using “debounceTime”</p>
                <p class="standard">You shouldn’t use the <samp class="listingcharacter listingcharacter">debounceTime</samp> operator for the communication between client and server because requests can be lost here. However, if the communication is between components or systems and resource-intensive operations are performed, it may be worthwhile to reject requests if the input conditions for the operation are still changing. If you need more flexibility, you can use the <samp class="listingcharacter listingcharacter">debounce</samp> operator instead of the <samp class="listingcharacter listingcharacter">debounceTime</samp> operator. This operator accepts a callback function that returns a <samp class="listingcharacter listingcharacter">timer</samp> observable<a class="indexanchor" id="i17_70"/>, which allows you to adjust the time period accordingly.</p>
            
        
        
            <h3 class="t3" id="h17.2.4">17.2.4    Join Operators<a class="indexanchor" id="i17_71"/></h3>
            <p class="standard">If you work in an application with RxJS, it often happens that you want to merge<a class="indexanchor" id="i17_72"/> the result of several observables and continue with the result. For this purpose, you can use a number of join operators. A widely used specimen of this category is the <samp class="listingcharacter listingcharacter">combineLatest</samp><a class="indexanchor" id="i17_73"/> operator. This operator takes multiple observables and triggers an event whenever one of the observables triggers an event. In doing so, the <samp class="listingcharacter listingcharacter">combineLatest</samp> operator combines the most recently sent data packages of all observables and makes them available to you.</p>
            <p class="standard">In <span class="crossreference "><a href="17_002.html#l17.18">Listing 17.18</a></span> you create three observables; depending on the application, these can involve any implementation, such as connections to other servers, for example. In this case, you create three <samp class="listingcharacter listingcharacter">timer</samp> observables that trigger an event at intervals of 500, 1,000, and 1,500 milliseconds, respectively. You extend the data package with a random number using the <samp class="listingcharacter listingcharacter">map</samp> operator and then combine the three observables via the <samp class="listingcharacter listingcharacter">combineLatest</samp> operator. This operator is applied to one of the three observables, and the remaining two are passed. As a result, a new observable is created, which outputs new data packages at intervals of 500 milliseconds, each consisting of the last values of the three observables. In the <samp class="listingcharacter listingcharacter">subscribe</samp> method, you use array destructuring to access the individual packages.</p>
            <div class="listing " id="l17.18"><pre><span class="rot">const</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> timer </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">require(</span><span class="hellblau">'rxjs'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="rot">const</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> combineLatest</span><span class="schwarz">,</span><span class="schwarz"> map </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">require(</span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> randomInt </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> Math</span><span class="schwarz">.floor(</span><span class="schwarz">Math</span><span class="schwarz">.random()</span><span class="schwarz"> </span><span class="dunkelblau">*</span><span class="schwarz"> </span><span class="schwarz">100);</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> timer1 </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">timer(0,</span><span class="schwarz"> </span><span class="schwarz">500).pipe(map(()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">randomInt()));</span><span class="schwarz"><br/></span><span class="rot">const</span><span class="schwarz"> timer2 </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">timer(0,</span><span class="schwarz"> </span><span class="schwarz">1000).pipe(map(()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">randomInt()));</span><span class="schwarz"><br/></span><span class="rot">const</span><span class="schwarz"> timer3 </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">timer(0,</span><span class="schwarz"> </span><span class="schwarz">1500).pipe(map(()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">randomInt()));</span><span class="schwarz"><br/></span> <br/><a id="p535"/>timer1<span class="schwarz">.pipe(</span><span class="bold"><samp class="listingcharacter listingcharacter">combineLatest(timer2, timer3)</samp></span>).subscribe(([t1, t2, t3]) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="violett">`</span><br/>    ${new Date()}<br/>    Timer1: ${t1}<br/>    Timer2: ${t2}<br/>    Timer3: ${t3}<br/>  `<span class="schwarz">);</span><br/>}); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 17.18</b>    
            Combination of Multiple Observables</p>
            <p class="standard">For clarification, you also have the current time included in the output. <span class="crossreference "><a href="17_002.html#l17.19">Listing 17.19</a></span> shows the output of the example.</p>
            <div class="listing " id="l17.19"><pre>    Sat Aug 21 2021 13:39:05 GMT+0200 (Central European Summer Time)<br/>    Timer1: 83<br/>    Timer2: 18<br/>    Timer3: 66<br/><br/>    Sat Aug 21 2021 13:39:06 GMT+0200 (Central European Summer Time)<br/>    Timer1: 83<br/>    Timer2: 18<br/>    Timer3: 49<br/>... </pre></div>
            <p class="caption "><b>Listing 17.19</b>    
            Output of the Combination of Multiple Observables</p>
        
        
            <h3 class="t3" id="h17.2.5">17.2.5    Error Handling Operators<a class="indexanchor" id="i17_74"/></h3>
            <p class="standard">You’ve already become acquainted with one of the most important means of error handling, namely, the second callback function of the <samp class="listingcharacter listingcharacter">subscribe</samp> method. RxJS provides you with additional operators to catch errors that occur between the observable and the observer.</p>
            
                <h4 class="t4" id="h17.2.5.1">Catching Errors with catchError<a class="indexanchor" id="i17_75"/></h4>
                <p class="standard">You can insert the <samp class="listingcharacter listingcharacter">catchError</samp> operator anywhere in the operator chain. The operator then catches all errors that have previously occurred in the chain. This allows you to respond dynamically to the various errors and also to insert multiple <samp class="listingcharacter listingcharacter">catchError</samp> operators. If an error is caught, the processing of the observable gets interrupted. <span class="crossreference "><a href="17_002.html#l17.20">Listing 17.20</a></span> shows an example of this.</p>
                <div class="listing " id="l17.20"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> Observable</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="rot">of</span><span class="schwarz"> </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> map</span><span class="schwarz">,</span><span class="schwarz"> catchError </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><a id="p536"/>Observable<span class="schwarz">.create((</span><span class="schwarz">observer</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.next(</span><span class="hellblau">'test 1'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.next(</span><span class="hellblau">'test 2'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter">observer.error(<span class="hellblau">'something went wrong'</span><span class="schwarz">);</span></samp></span><br/>  observer.next(<span class="hellblau">'test 3'</span><span class="schwarz">);</span><br/>  observer.complete();<br/>})<br/>  .pipe(<br/>    map((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>      <span class="rot">const</span><span class="schwarz"> mappedData </span><span class="dunkelblau">=</span><span class="schwarz"> data.toUpperCase();</span><br/>     <span class="gruen"> </span><span class="bold"><samp class="listingcharacter listingcharacter">// throw new Error('Mapping failed');</samp></span><span class="schwarz"><br/></span>      <span class="rot">return</span><span class="schwarz"> mappedData;</span><br/>    }),<br/>    <span class="bold"><samp class="listingcharacter listingcharacter">catchError((e, caught) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>      <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'the error was: '</span><span class="schwarz">, e);</span><br/>      <span class="rot">return</span><span class="schwarz"> of(</span><span class="hellblau">'test 3'</span><span class="schwarz">, </span><span class="hellblau">'test 4'</span><span class="schwarz">);</span><br/>    }),</samp></span><br/>  )<br/>  .subscribe((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(data)); </span><span class="schwarz"/></pre></div>
                <p class="caption "><b>Listing 17.20</b>    
            Handling Errors Using the “catchError” Operator</p>
                <p class="standard">In general, errors can occur at different points. You can trigger an error in the observable itself using the <samp class="listingcharacter listingcharacter">error</samp> method. But an operator can also cause an error. For example, if you enable the line in the <samp class="listingcharacter listingcharacter">map</samp> operator that triggers the error, you can also catch it using the <samp class="listingcharacter listingcharacter">catchError</samp> operator. No matter which error is triggered, the output of the <samp class="listingcharacter listingcharacter">test 3</samp> string doesn’t occur at all. The callback function of the <samp class="listingcharacter listingcharacter">catchError</samp> operator can in turn return an observable so that you can continue in the chain, which in this case continues the output with the strings <samp class="listingcharacter listingcharacter">test 3</samp> and <samp class="listingcharacter listingcharacter">test 4</samp>.</p>
            
            
                <h4 class="t4" id="h17.2.5.2">Trying Again<a class="indexanchor" id="i17_76"/> with retry<a class="indexanchor" id="i17_77"/></h4>
                <p class="standard">Unlike the <samp class="listingcharacter listingcharacter">catchError</samp> operator, which catches and handles an error, the <samp class="listingcharacter listingcharacter">retry</samp> operator makes sure that the observable is executed again in its entirety. This operator is particularly relevant when you work with unreliable data sources such as poorly accessible web servers.</p>
                <p class="standard">The source code in <span class="crossreference "><a href="17_002.html#l17.21">Listing 17.21</a></span> ensures that the observable is executed three times in total. In the third run, the processing is aborted due to an uncaught error. Specifying <samp class="listingcharacter listingcharacter">retry(2)</samp> ensures that there won’t occur an infinite loop. It’s important to note that the values from the observable are regenerated on a retry and don’t originate from a cache. By using the <samp class="listingcharacter listingcharacter">Math.random</samp> method, this fact becomes clear because each run produces different numbers.</p>
                <div class="listing " id="l17.21"><pre><span class="rot"><a id="p537"/>import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> Observable </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> retry </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/>Observable<span class="schwarz">.create((</span><span class="schwarz">observer</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'starting'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.next(</span><span class="schwarz">Math</span><span class="schwarz">.random());</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.next(</span><span class="schwarz">Math</span><span class="schwarz">.random());</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.error(</span><span class="hellblau">'something went wrong'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.next(</span><span class="schwarz">Math</span><span class="schwarz">.random());</span><span class="schwarz"><br/></span><span class="schwarz">})</span><span class="schwarz"><br/></span>  <span class="schwarz">.pipe(retry(2))</span><span class="schwarz"><br/></span>  <span class="schwarz">.subscribe((</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">data</span><span class="schwarz">));</span><span class="schwarz"> </span></pre></div>
                <p class="caption "><b>Listing 17.21</b>    
            Using the “retry” Operator</p>
            
        
        
            <h3 class="t3" id="h17.2.6">17.2.6    Utility Operators<a class="indexanchor" id="i17_78"/></h3>
            <p class="standard">The utility operators category contains operators that facilitate your work with RxJS.</p>
            
                <h4 class="t4" id="h17.2.6.1">Debugging<a class="indexanchor" id="i17_79"/> with the tap<a class="indexanchor" id="i17_80"/> Operator</h4>
                <p class="standard">If you work with chains of operators and implement them as arrow functions with an implicit return value, finding errors can be very time-consuming. This is where the <samp class="listingcharacter listingcharacter">tap</samp> operator comes into play. This operator doesn’t affect the chain of operators, but you can grab the value anywhere in the chain and output it or set a breakpoint<a class="indexanchor" id="i17_81"/>.</p>
                <p class="standard">If you run the source code from <span class="crossreference "><a href="17_002.html#l17.22">Listing 17.22</a></span>, you’ll see that the <samp class="listingcharacter listingcharacter">tap</samp> operator merely produces an output of the intermediate results, but doesn’t otherwise affect the operator chain, although the value <samp class="listingcharacter listingcharacter">undefined</samp> is returned.</p>
                <div class="listing " id="l17.22"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> range </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> filter</span><span class="schwarz">,</span><span class="schwarz"> tap</span><span class="schwarz">,</span><span class="schwarz"> map </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="schwarz">range(1,</span><span class="schwarz"> </span><span class="schwarz">10)</span><span class="schwarz"><br/></span>  <span class="schwarz">.pipe(</span><span class="schwarz"><br/></span>    <span class="schwarz">filter((</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> data </span><span class="dunkelblau">%</span><span class="schwarz"> </span><span class="schwarz">2</span><span class="schwarz"> </span><span class="dunkelblau">===</span><span class="schwarz"> </span><span class="schwarz">0),</span><span class="schwarz"><br/></span>    <span class="schwarz">tap((</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'value after filter: '</span><span class="schwarz">,</span><span class="schwarz"> data</span><span class="schwarz">)),</span><span class="schwarz"><br/></span>    <span class="schwarz">map((</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> data </span><span class="dunkelblau">*</span><span class="schwarz"> data</span><span class="schwarz">),</span><span class="schwarz"><br/></span>  <span class="schwarz">)</span><span class="schwarz"><br/></span>  <span class="schwarz">.subscribe((</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">data</span><span class="schwarz">));</span><span class="schwarz"> </span></pre></div>
                <p class="caption "><b>Listing 17.22</b>    
            Using the “tap” Operator</p>
            
            
                <h4 class="t4" id="h17.2.6.2">Defining Time-Outs<a class="indexanchor" id="i17_82"/></h4>
                <p class="standard">Another useful operator is the <samp class="listingcharacter listingcharacter">timeout</samp> operator. You can use it to determine that an error gets triggered after a certain period of time has elapsed without any data packages <a id="p538"/>from an observable. This operator is particularly useful if you’re connected to another system via a socket connection<a class="indexanchor" id="i17_83"/> and expect regular messages. For example, if the time between two messages is more than five seconds, you can conclude that there is a problem in the communication that you need to resolve.</p>
                <p class="standard">In <span class="crossreference "><a href="17_002.html#l17.23">Listing 17.23</a></span>, you create an observable that triggers an event after 500 and 2,000 milliseconds. Thus, there are 1,500 milliseconds between the two events. If you apply the <samp class="listingcharacter listingcharacter">timeout</samp> operator<a class="indexanchor" id="i17_84"/> with a value of <samp class="listingcharacter listingcharacter">1000</samp>, the 1,500 milliseconds will cause an error, which will occur as a <samp class="listingcharacter listingcharacter">TimeoutError</samp> that you catch in the error callback function of the <samp class="listingcharacter listingcharacter">subscribe</samp> method.</p>
                <div class="listing " id="l17.23"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> Observable </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> timeout </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/>Observable<span class="schwarz">.create((</span><span class="schwarz">observer</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="schwarz">setTimeout(()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    observer<span class="schwarz">.next(</span><span class="hellblau">'first package'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">},</span><span class="schwarz"> </span><span class="schwarz">500);</span><span class="schwarz"><br/></span>  <span class="schwarz">setTimeout(()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    observer<span class="schwarz">.next(</span><span class="hellblau">'second package'</span><span class="schwarz">);</span><span class="schwarz"><br/></span>  <span class="schwarz">},</span><span class="schwarz"> </span><span class="schwarz">2000);</span><span class="schwarz"><br/></span><span class="schwarz">})</span><span class="schwarz"><br/></span>  <span class="schwarz">.pipe(</span><span class="bold"><samp class="listingcharacter listingcharacter">timeout(1000)</samp></span>)<br/>  .subscribe(<br/>    (data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(data),</span><br/>    (error) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.error(</span><span class="hellblau">'error'</span><span class="schwarz">, error),</span><br/>  ); <span class="schwarz"/></pre></div>
                <p class="caption "><b>Listing 17.23</b>    
            Using the “timeout” Operator</p>
            
        
        
            <h3 class="t3" id="h17.2.7">17.2.7    Conditional Operators<a class="indexanchor" id="i17_85"/></h3>
            <p class="standard">You can use the conditional operators to define specific conditions for your observable.</p>
            
                <h4 class="t4" id="h17.2.7.1">Defining a Default Value<a class="indexanchor" id="i17_86"/></h4>
                <p class="standard">You can use the <samp class="listingcharacter listingcharacter">defaultIfEmpty</samp><a class="indexanchor" id="i17_87"/> operator if an observable doesn’t output a value. For this operator to work, the observable must be completed. The observable in <span class="crossreference "><a href="17_002.html#l17.24">Listing 17.24</a></span> is completed without calling the <samp class="listingcharacter listingcharacter">next</samp> method.</p>
                <div class="listing " id="l17.24"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> Observable </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> defaultIfEmpty </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/>Observable<span class="schwarz">.create((</span><span class="schwarz">observer</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.complete();</span><span class="schwarz"><br/></span><span class="schwarz">})</span><span class="schwarz"><br/></span><a id="p539"/>  <span class="schwarz">.pipe(</span><span class="bold"><samp class="listingcharacter listingcharacter">defaultIfEmpty(<span class="hellblau">'Observable did not emit a value'</span><span class="schwarz">)</span></samp></span>)<br/>  .subscribe((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(data)); </span><span class="schwarz"/></pre></div>
                <p class="caption "><b>Listing 17.24</b>    
            Defining a Default Value for an Empty Observable</p>
                <p class="standard">The <samp class="listingcharacter listingcharacter">defaultIfEmpty</samp> operator only takes effect if the observable doesn’t output any value. The element you pass to the operator is treated as a regular data package by subsequent operators and the <samp class="listingcharacter listingcharacter">subscribe</samp> method.</p>
            
            
                <h4 class="t4" id="h17.2.7.2">Condition for All Data Packages<a class="indexanchor" id="i17_88"/> of an Observable</h4>
                <p class="standard">The <samp class="listingcharacter listingcharacter">every</samp><a class="indexanchor" id="i17_89"/> operator allows you to define a condition that each data package of an observable must fulfill. Depending on the result, the return value is either <samp class="listingcharacter listingcharacter">true</samp> or <samp class="listingcharacter listingcharacter">false</samp>. <span class="crossreference "><a href="17_002.html#l17.25">Listing 17.25</a></span> shows the application of this operator.</p>
                <div class="listing " id="l17.25"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> range </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> every </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="schwarz">range(1,</span><span class="schwarz"> </span><span class="schwarz">9)</span><span class="schwarz"><br/></span>  <span class="schwarz">.pipe(</span><span class="bold"><samp class="listingcharacter listingcharacter">every((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> data </span><span class="dunkelblau">&lt;</span><span class="schwarz"> 10)</span></samp></span>)<br/>  .subscribe((result) <span class="dunkelblau">=&gt;</span><span class="schwarz"><br/></span>    result<br/>      <span class="dunkelblau">?</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'all values are smaller than 10'</span><span class="schwarz">)</span><br/>      : <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'there'</span><span class="schwarz">s at least one </span><span class="magenta">value</span><span class="schwarz"> greater than 10'),</span><br/>  ); <span class="schwarz"/></pre></div>
                <p class="caption "><b>Listing 17.25</b>    
            Using the “every” Operator</p>
            
        
        
            <h3 class="t3" id="h17.2.8">17.2.8    Connection Operators<a class="indexanchor" id="i17_90"/></h3>
            <p class="standard">The connection operators of RxJS affect the character of an observable. Normally, only one observer can connect to an observable. In addition, most observables are cold<a class="indexanchor" id="i17_91"/>, which means that they only trigger events after you subscribe to them.</p>
            <p class="standard">An example of such an operator is <samp class="listingcharacter listingcharacter">publish</samp>. With its help, you can call the <samp class="listingcharacter listingcharacter">subscribe</samp> method more than once. In addition, the observable doesn’t start outputting data packages until you call the <samp class="listingcharacter listingcharacter">connect</samp> method.</p>
            <p class="standard">Both subscribers from <span class="crossreference "><a href="17_002.html#l17.26">Listing 17.26</a></span> receive the same values. If you were to subscribe to such an observable without the <samp class="listingcharacter listingcharacter">publish</samp> operator, each observer would get different values. You can delay the output of the values by calling the <samp class="listingcharacter listingcharacter">connect</samp> method at a later time. If this behavior isn’t what you want, you can also use the <samp class="listingcharacter listingcharacter">share</samp> operator, which allows for simple multicasting, that is, notifying multiple operators at once.</p>
            <div class="listing " id="l17.26"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> Observable </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> publish </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs/operators'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> observable </span><span class="dunkelblau">=</span><span class="schwarz"> Observable</span><span class="schwarz">.create((</span><span class="schwarz">observer</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span><a id="p540"/>  observer<span class="schwarz">.next(</span><span class="schwarz">Math</span><span class="schwarz">.random());</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.next(</span><span class="schwarz">Math</span><span class="schwarz">.random());</span><span class="schwarz"><br/></span><span class="schwarz">}).pipe(</span><span class="bold"><samp class="listingcharacter listingcharacter">publish()</samp></span>);<br/> <br/>observable.subscribe((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Observer 1: '</span><span class="schwarz">, data));</span><br/>observable.subscribe((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Observer 2: '</span><span class="schwarz">, data));</span><br/> <br/>observable.connect(); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 17.26</b>    
            Multicasting with the “publish” Operator</p>
        
        
            <h3 class="t3" id="h17.2.9">17.2.9    Conversion Operators<a class="indexanchor" id="i17_92"/></h3>
            <p class="standard">The integration of RxJS into an existing application is facilitated by the fact that almost all data structures can be transferred into an RxJS observable. The <samp class="listingcharacter listingcharacter">lastValueFrom</samp> operator<a class="indexanchor" id="i17_93"/> allows you to extract the last value output by an observable encapsulated in a promise object and thus also embed your observable in an existing structure. This operator replaces the <samp class="listingcharacter listingcharacter">toPromise</samp> operator<a class="indexanchor" id="i17_94"/> that has been used for a long time.</p>
            <p class="standard"><span class="crossreference "><a href="17_002.html#l17.27">Listing 17.27</a></span> shows an example of converting an observable into a promise object. However, the <samp class="listingcharacter listingcharacter">lastValueFrom</samp> function is subject to some limitations because a promise can only represent the pending, resolved, and rejected states. As long as the observable isn’t yet completed, the promise is in the pending state, and the callback function of the <samp class="listingcharacter listingcharacter">then</samp> method isn’t executed. If the observable is completed, the promise is fulfilled with the last issued value. In the example, this means that only the last random number is passed on.</p>
            <div class="listing " id="l17.27"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> Observable</span><span class="schwarz">,</span><span class="schwarz"> lastValueFrom </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'rxjs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> observable </span><span class="dunkelblau">=</span><span class="schwarz"> Observable</span><span class="schwarz">.create((</span><span class="schwarz">observer</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.next(</span><span class="schwarz">Math</span><span class="schwarz">.random());</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.next(</span><span class="schwarz">Math</span><span class="schwarz">.random());</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.next(</span><span class="schwarz">Math</span><span class="schwarz">.random());</span><span class="schwarz"><br/></span>  observer<span class="schwarz">.complete();</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"><br/></span> <br/><span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter">lastValueFrom(observable)</samp></span><br/>  .then((data) <span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="magenta">console</span><span class="schwarz">.log(data)); </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 17.27</b>    
            Converting an Observable into a Promise Object</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>