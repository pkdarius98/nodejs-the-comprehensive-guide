<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Security" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Security" name="description"/>
            <meta content="en" name="language"/>
            <title>Security</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main"><h1 class="t1" id="h24">24    <a id="p683"/>Security</h1><p class="introductorynote indent_chapter_double">Always keep the bad guys separate from each other. The security of the world depends on it.<br/>—Theodor Fontane</p><p class="standard">In<a class="indexanchor" id="i24_00"/> addition to performance and good, intuitive usability, security is an essential aspect of web applications. <span class="italic">Security</span> is a generic term for a large number of individual disciplines, but all of them aim to maintain and improve the trustworthiness<a class="indexanchor" id="i24_01"/> of the application in its interaction with a user. And it’s precisely this very important aspect of software development that often receives far too little attention. This poses great risks, as Node.js is now used not only for simple web applications but also for mission-critical software.</p><p class="standard">Web applications are often the target of attacks. These result from a wide variety of motives. From harmless attempts to put a server under increased load (<span class="italic">distributed denial-of-service [DDOS] attacks</span>)<a class="indexanchor" id="i24_02"/>, to identity theft (<span class="italic">session hijacking</span>)<a class="indexanchor" id="i24_03"/>, to planned and well-prepared attacks on application vulnerabilities (<span class="italic">cross-site scripting</span>)<a class="indexanchor" id="i24_04"/>, the range of attack vectors offers a very wide variety.</p><p class="standard">As with all programming languages that provide access to system resources, server-side JavaScript with Node.js requires you to be aware of your responsibilities. With vulnerabilities in your application, you open a gateway to your system for attackers to damage it or take control of it. This fact also represents one of the most significant differences to client-side JavaScript. In the browser, you move with your JavaScript application within a sandbox, from which you normally have no external interfaces to the user’s overall system. In the worst case, the browser reports that a script is running too long and asks you to stop executing it. In Node.js, the situation is completely different, as here you work not only with the data of a single user, but with all the information available on the system.</p><p class="standard">This chapter covers various attack scenarios<a class="indexanchor" id="i24_05"/> and presents the relevant countermeasures. You’ll also be made aware of the need to pay attention to the security of your application and learn about various resources and technologies for this purpose. A security problem in an application can cause lasting damage to user confidence and often leads to a large number of customers leaving for the competition, not to mention possible legal consequences such as compensation claims.</p>
        <h2 class="t2" id="h24.1">24.1    <a id="p684"/>Filter Input<a class="indexanchor" id="i24_06"/> and Escape Output<a class="indexanchor" id="i24_07"/></h2>
        <p class="standard">You’ll come across two mnemonics again and again in web development: <span class="italic">filter input</span> and <span class="italic">escape output</span>. Basically, this means you should never trust information that enters your application from the outside, no matter where it comes from. Secondly, you should do everything you can to ensure that the information leaving your application toward the user or other systems can’t cause any harm.</p>
        
            <h3 class="t3" id="h24.1.1">24.1.1    Filter Input</h3>
            <p class="standard">The first part of this concept, input filtering, states that information coming into the application from outside is fundamentally untrustworthy or potentially harmful. Consequently, you don’t process such information until you’ve filtered it and thus ensured that it doesn’t contain any harmful components. You can think of this process as a kind of car wash. The information enters your application dirty, goes through a filtering process, and comes out clean. After that, you can process the information without hesitation.</p>
            <p class="standard">There are two different procedures for filtering input. You can reformulate invalid data so that it becomes valid data. However, this bears the risk that you may falsify information or even lose it altogether. The second, better variant is to reject invalid entries with a corresponding error message and to request a new, correct entry.</p>
        
        
            <h3 class="t3" id="h24.1.2">24.1.2    Blacklisting<a class="indexanchor" id="i24_08"/> and Whitelisting<a class="indexanchor" id="i24_09"/></h3>
            <p class="standard">In the context of input filtering, we often talk about blacklisting and whitelisting. Whitelisting is the stricter and more secure approach. A <span class="italic">whitelist</span> is a collection of values that are allowed as input. All values that aren’t whitelisted will be rejected. In this case, you have complete control over the values that come into your system. The <span class="italic">blacklist</span>, on the other hand, explicitly specifies the values that aren’t allowed into the system. The disadvantage of this approach is that there may well be values that are harmful to your system, but which you either don’t know or have forgotten. For this reason, from a security perspective, whitelisting is the approach you should always take. <span class="crossreference "><a href="24_001.html#l24.1">Listing 24.1</a></span> shows an example of a whitelisting approach. However, there are situations where this approach isn’t practicable, especially when the whitelist becomes too large because the set of allowed values is too large.</p>
            <div class="listing " id="l24.1"><pre><span class="rot">function</span><span class="schwarz"> execute(command) {</span><br/>  <span class="rot">const</span><span class="schwarz"> allowedCommands </span><span class="dunkelblau">=</span><span class="schwarz"> [</span><span class="hellblau">'list'</span><span class="schwarz">, </span><span class="hellblau">'create'</span><span class="schwarz">, </span><span class="hellblau">'update'</span><span class="schwarz">, </span><span class="hellblau">'delete'</span><span class="schwarz">];</span><br/> <br/>  <span class="rot">if</span><span class="schwarz"> (</span><br/>    <span class="dunkelblau">!</span><span class="schwarz">allowedCommands.find(</span><br/>      (allowedCommand) <span class="dunkelblau">=&gt;</span><span class="schwarz"> allowedCommand </span><span class="dunkelblau">===</span><span class="schwarz"> command.toLowerCase(),</span><br/>    )<br/><a id="p685"/>  ) {<br/>    <span class="rot">throw</span><span class="schwarz"> </span><span class="rot">new </span><span class="schwarz">Error(</span><span class="violett">`Command </span><span class="hellblau">"${command}"</span><span class="violett"> not allowed`</span><span class="schwarz">);</span><br/>  }<br/> <br/>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="violett">`Running </span><span class="hellblau">"${command}"</span><span class="violett">`</span><span class="schwarz">);</span><br/>}<br/> <br/>execute(<span class="hellblau">'list'</span><span class="schwarz">);  </span><span class="gruen"> </span><span class="bold"><samp class="listingcharacter listingcharacter">// Output: Running "list"</samp></span><span class="schwarz"><br/></span>execute(<span class="hellblau">'format'</span><span class="schwarz">);</span><span class="gruen"> </span><span class="bold"><samp class="listingcharacter listingcharacter">// Output: Error: Command "format" not allowed </samp></span><span class="schwarz"> </span><span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 24.1</b>    
            Whitelist for Function Arguments</p>
            <p class="standard">The example contains an <samp class="listingcharacter listingcharacter">execute</samp> function, which is used to execute commands. However, only a certain number of commands is allowed. To check this, you must define an array of values, that is, the whitelist, and test whether the passed string is included. If it is, you can continue with the function; otherwise, there is a security violation, and an exception is thrown. Such a whitelist can consist not only of static values but also, for example, of regular expressions to make the range of possible input values larger and to reduce the manual maintenance effort of the whitelist.</p>
            <p class="standard">That’s enough for now on the subject of input filtering. In the following section, you’ll learn more about handling outputs of your application.</p>
        
        
            <h3 class="t3" id="h24.1.3">24.1.3    Escape Output<a class="indexanchor" id="i24_10"/></h3>
            <p class="standard">The second basic security principle—<span class="italic">escape output</span>—concerns the data that leaves your application. Your goal should always be to do no harm, that is, to avoid passing malicious code to your users under any circumstances, which would justifiably cause lasting damage to the trust in your application. However, this entails two questions:</p>
            <ul>
                <li>
                    <p class="standard first-item last-item">Which systems are potential targets for data?</p>
                </li>
                <li>
                    <p class="standard first-item last-item">What is considered malicious code by these systems?</p>
                </li>
            </ul>
            <p class="standard">The first question is easy to answer: The range of target systems extends from a user’s web browser to a database server, which immediately leads to the answer to the second question. Malicious code is unique to each system. Whereas JavaScript code that has been injected for a browser means potential harm to the user, an injected delete command for a database server is a far greater danger. For this reason, you must decide how to handle your application’s output data<a class="indexanchor" id="i24_11"/> on a case-by-case basis.</p>
            <p class="standard"><span class="crossreference "><a href="24_001.html#l24.2">Listing 24.2</a></span> shows a very simple example of output escaping. In an HTTP server, you accept incoming requests from users, extract the value to the <samp class="listingcharacter listingcharacter">name</samp> key from the query string<a class="indexanchor" id="i24_12"/>, and send it back to the client. To prevent a user from submitting requests such as <samp class="listingcharacter listingcharacter">http://localhost:8080/?name=&lt;script&gt;alert("foo")&lt;/script&gt;</samp> and thus having <a id="p686"/>JavaScript code executed, you replace the opening and closing angle brackets within the <samp class="listingcharacter listingcharacter">cleanupName</samp> function with <samp class="listingcharacter listingcharacter">&amp;lt;</samp> and <samp class="listingcharacter listingcharacter">&amp;gt;</samp>.</p>
            <div class="listing " id="l24.2"><pre><span class="rot">import</span><span class="schwarz"> { createServer } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'http'</span><span class="schwarz">;</span><br/><span class="rot">import</span><span class="schwarz"> { parse } </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'url'</span><span class="schwarz">;</span><br/> <br/><span class="rot">function</span><span class="schwarz"> cleanupName(name) {</span><br/>  <span class="rot">return</span><span class="schwarz"> name.replace(</span><span class="dunkelblau">/&lt;/</span><span class="schwarz">g, </span><span class="hellblau">'&amp;lt;'</span><span class="schwarz">).replace(</span><span class="dunkelblau">/&gt;/</span><span class="schwarz">g, </span><span class="hellblau">'&amp;gt;'</span><span class="schwarz">);</span><br/>}<br/> <br/>createServer((req, res) <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="rot">const</span><span class="schwarz"> parts </span><span class="dunkelblau">=</span><span class="schwarz"> parse(req.url, </span><span class="rot">true</span><span class="schwarz">);</span><br/>  <span class="rot">let</span><span class="schwarz"> name </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="hellblau">''</span><span class="schwarz">;</span><br/> <br/>  <span class="rot">if</span><span class="schwarz"> (parts.query.name) {</span><br/>    name <span class="dunkelblau">=</span><span class="schwarz"> cleanName(parts.query.name);</span><br/>  }<br/> <br/>  res.end(<span class="violett">`&lt;div&gt;Hello ${name}&lt;/div&gt;`</span><span class="schwarz">);</span><br/>}).listen(8080); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 24.2</b>    
            Escaping Injected HTML</p>
            <p class="standard">This example represents only a very inadequate solution for cross-site scripting<a class="indexanchor" id="i24_13"/>. You’ll learn more about countermeasures against this type of attack later in this chapter. Incidentally, modern browsers now prevent such attacks by default and display corresponding error messages on the console. Nevertheless, you should not rely too much on this kind of client-side security mechanism<a class="indexanchor" id="i24_14"/>.</p>
            <p class="standard">After these rather basic topics, you’ll now learn more about the most common target of attacks in the Node.js environment: the Node.js server process.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>