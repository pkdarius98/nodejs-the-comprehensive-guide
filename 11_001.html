<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="GraphQL" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - GraphQL" name="description"/>
            <meta content="en" name="language"/>
            <title>GraphQL</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main"><h1 class="t1" id="h11">11    <a id="p337"/>GraphQL</h1><p class="introductorynote indent_chapter_double">He that breaks a thing to find out what it is has left the path of wisdom.<br/>—J. R. R. Tolkien</p><p class="standard">In<a class="indexanchor" id="i11_00"/> addition to the widely used representational state transfer (REST)<a class="indexanchor" id="i11_01"/> interfaces, GraphQL is also being used more and more frequently to generate web interfaces. Unlike REST, the query language—originally designed by Facebook<a class="indexanchor" id="i11_02"/>—provides for a more dynamic querying of resources. The consumer of an interface defines the expected structure in the query and can thus affect both the form and the amount of data in the response. Furthermore, with GraphQL, it’s possible to combine multiple resources in one query and thus map dependencies directly without the need for additional queries.</p><p class="standard">For all its advantages, you must always keep in mind that GraphQL isn’t magic. Any information your interface delivers must come from a source that you integrate on the server side. This also applies to all the relations you map in a query. The interface is only as good as your implementation underneath it.</p><p class="standard">GraphQL consists of three components: </p><ul>
        <li>
            <p class="standard first-item last-item"><span class="bold">Query</span><a class="indexanchor" id="i11_03"/><br/>The GraphQL client formulates a query to communicate with the server. A query can involve a read access, in which case, you use the query type <span class="italic">query</span><a class="indexanchor" id="i11_04"/>, or a write access, for which you use the <span class="italic">mutations</span><a class="indexanchor" id="i11_05"/>. A query must always follow the rules of the server’s GraphQL schema.</p>
        </li>
        <li>
            <p class="standard first-item last-item"><span class="bold">Schema</span><a class="indexanchor" id="i11_06"/><br/>The schema defines the data structure of the server and forms the basis for the queries. The schema of a GraphQL server defines an object structure using its own type system<a class="indexanchor" id="i11_07"/>. GraphQL seems very flexible at first sight. However, this flexibility only extends to the limits set by the schema. Everything must be defined in the schema that you want the GraphQL interface to have an effect on.</p>
        </li>
        <li>
            <p class="standard first-item last-item"><span class="bold">Resolvers</span><a class="indexanchor" id="i11_08"/><br/>GraphQL is simply a means to query and manipulate data. The GraphQL interface has no knowledge about the business logic of the application. This is where the resolvers come into play. They provide the interface to the actual Node.js application and are implemented as functions.</p>
        </li>
    </ul><p class="standard"><a id="p338"/>The reference implementation for Facebook’s GraphQL was written in Node.js. For this reason, the integration is very good for both Node.js and client-side JavaScript. You can find numerous other resources on this topic on the GraphQL website (<span class="url"><a href="https://graphql.org/">https://graphql.org/</a></span>).</p>
        <h2 class="t2" id="h11.1">11.1    GraphQL Libraries<a class="indexanchor" id="i11_09"/></h2>
        <p class="standard">At its core, GraphQL is just a language specification that defines certain rules. The actual implementation for the different programming languages and platforms is carried out by libraries. These exist for Go, Rust, and C, as well as for JavaScript. The most popular library is probably GraphQL.js, Facebook’s original reference implementation<a class="indexanchor" id="i11_10"/>. It’s implemented for running a GraphQL interface in Node.js and is independent of other frameworks. You can install the library via the command; <samp class="listingcharacter listingcharacter">npm install graphql</samp> and can then use it directly. <span class="crossreference "><a href="11_001.html#l11.1">Listing 11.1</a></span> shows a first simple example of using GraphQL.</p>
        <div class="listing " id="l11.1"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> buildSchema</span><span class="schwarz">,</span><span class="schwarz"> graphql </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'graphql'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> schema </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">buildSchema(</span><span class="violett">`</span><br/>  type Query {<br/>    greet: String<br/>  }<br/>`<span class="schwarz">);</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> root </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="schwarz">greet()</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">return</span><span class="schwarz"> </span><span class="hellblau">'Hello GraphQL!'</span><span class="schwarz">;</span><span class="schwarz"><br/></span>  <span class="schwarz">},</span><span class="schwarz"><br/></span><span class="schwarz">};</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> response </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">await</span><span class="schwarz"> </span><span class="schwarz">graphql(</span><span class="schwarz">schema</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'{ greet } '</span><span class="schwarz">,</span><span class="schwarz"> root</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">response</span><span class="schwarz">.</span><span class="schwarz">data</span><span class="schwarz">.</span><span class="schwarz">greet</span><span class="schwarz">);</span><span class="gruen"> // Ausgabe: Hello GraphQL!</span><span class="schwarz"> </span></pre></div>
        <p class="caption "><b>Listing 11.1</b>    
            Using the “graphql” Library</p>
        <p class="standard">In this example, you use GraphQL as an interface within an application. This means you don’t run a server process or make the interface publicly available. Instead, you first define the schema using the <samp class="listingcharacter listingcharacter">buildSchema</samp> function<a class="indexanchor" id="i11_11"/> from the <samp class="listingcharacter listingcharacter">graphql</samp> package. The schema defines a <samp class="listingcharacter listingcharacter">query</samp> type with the <samp class="listingcharacter listingcharacter">greet</samp> field of the string type. With a query, you can read this field. For the request to be supplied with a concrete value, you must define a resolver. To do this, you define the <samp class="listingcharacter listingcharacter">root</samp> object, which contains a <samp class="listingcharacter listingcharacter">greet</samp> function. This is located after the field and is executed with a query to produce the concrete value.</p>
        <p class="standard">The asynchronous <samp class="listingcharacter listingcharacter">graphql</samp> function enables you to formulate such a query to your GraphQL interface. To do this, you first pass the created schema, the query itself, and <a id="p339"/>the <samp class="listingcharacter listingcharacter">root</samp> object. The GraphQL function returns a <samp class="listingcharacter listingcharacter">promise</samp> object, so you can use the <samp class="listingcharacter listingcharacter">async</samp> keyword, as shown in the example. The <samp class="listingcharacter listingcharacter">response</samp> object within this promise contains, among other information, a <samp class="listingcharacter listingcharacter">data</samp> property representing the result of the query<a class="indexanchor" id="i11_12"/>. Depending on how you structure your query, the object structure below the <samp class="listingcharacter listingcharacter">data</samp> property will look different from query to query. In our case, it contains a <samp class="listingcharacter listingcharacter">greet</samp> property, which in turn contains the string <samp class="listingcharacter listingcharacter">Hello GraphQL!</samp>.</p>
        <p class="standard">This first example isn’t practical for a web server because you don’t create a publicly available GraphQL interface. But we’re going to change that in the following sections. The movie database, which you already know from the previous chapters, now gets a GraphQL interface.</p>
    </div><p class="signatur"/>
                    </body>
                </html>