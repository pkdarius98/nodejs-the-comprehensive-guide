<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Real-Time Web Applications" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Real-Time Web Applications" name="description"/>
            <meta content="en" name="language"/>
            <title>Real-Time Web Applications</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main"><h1 class="t1" id="h12">12    <a id="p357"/>Real-Time Web Applications</h1><p class="introductorynote indent_chapter_double">I won’t sell the future for instant profit.<br/>—Werner von Siemens</p><p class="standard">The<a class="indexanchor" id="i12_00"/> original web applications consisted of a large number of individual HTML pages<a class="indexanchor" id="i12_01"/> that were more or less tightly coupled together. User interaction in such applications takes place via classic forms for data entry and via links that redirect the user to another page. Each of these actions resulted in a complete page reload. This behavior feels less dynamic and flexible. A clear improvement was therefore the introduction of single-page applications<a class="indexanchor" id="i12_02"/>, where only parts of the page had to be reloaded after a user interaction, rather than the entire page. The user’s communication interface also changed from clearly visible form elements to intuitive operating concepts, in which the elements of user interaction are no longer modeled according to pure HTML specifications, but according to the usability of the application.</p><p class="standard">Even though this concept had brought web applications much closer to desktop applications in terms of their behavior, a major problem still remained: How does a user find out that the application data has changed? Communication in web applications is mostly based on HTTP<a class="indexanchor" id="i12_03"/>. However, this transmission protocol follows a classic client-server approach: a client sends a request to the server, and the server processes the request and sends a response. A return channel from the server to the client isn’t provided. Consequently, a client can ask for current data, but the server has no way to actively notify its clients when new data is available. However, new technologies such as server-sent events and the WebSocket application programming interface (API)<a class="indexanchor" id="i12_04"/> allow you to open such a communication channel from the server to the client when developing your application, thus enabling bidirectional communication<a class="indexanchor" id="i12_05"/> between client and server.</p><div class="box box_standard">
        <h6 class="boxheading">WebSocket<a class="indexanchor" id="i12_06"/></h6>
        <p class="standard first last">WebSocket is a standalone protocol that runs parallel to HTTP. Like HTTP, it exists in an unencrypted and an encrypted<a class="indexanchor" id="i12_07"/> variant. The initial communication takes place via HTTP. The client generates a request asking for a protocol switch<a class="indexanchor" id="i12_08"/> to WebSocket. As soon as the switch is completed, both endpoints, that is, client and server, have equal rights in communication and can send and receive messages. Because it’s event-based processing, as soon as a message is received, an event is triggered, and a callback function is executed. This means that WebSockets don’t block and are basically asynchronous.</p>
    </div><p class="standard"><a id="p358"/>In addition to WebSockets, there are other mechanisms that allow you to run real-time web applications. In this chapter, you’ll learn about some ways to make your web applications dynamic so that they behave even closer to classic desktop applications.</p>
        <h2 class="t2" id="h12.1">12.1    The Sample Application</h2>
        <p class="standard">For a real-time-enabled web application to show its benefits, some requirements have to be met. For purely static content, for example, a real-time web application adds no value whatsoever. This means that data must originate within your application. If multiple users use your application simultaneously and generate new information, this is a potential task you can use a real-time-enabled web application to solve. However, new information in your application doesn’t necessarily have to come from users directly. Another option consists of processes that run on the server and generate information to be sent to the users. In this context, time-controlled calculations<a class="indexanchor" id="i12_09"/> are conceivable that serve to prepare the existing data set. The third variant through which new information can be created in your application consists of querying external sources. This allows you to retrieve the latest stock prices or news from a web service at regular intervals. You can then prepare and store this data within your application and make it available to your users. The more up to date the information in your application is and the faster your users learn about that information, the more valuable your application is to those users.</p>
        <p class="standard">A classic example of real-time web applications is a multiclient chat<a class="indexanchor" id="i12_10"/>. This task fulfills all requirements, so that a real-time web application can show its strengths. Users log in to your application via a login screen. After logging in, a user can chat with other participants in a chat room.</p>
    </div><p class="signatur"/>
                    </body>
                </html>