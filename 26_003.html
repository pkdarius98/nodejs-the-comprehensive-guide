<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Performance" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Performance" name="description"/>
            <meta content="en" name="language"/>
            <title>Performance</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h26.3">26.3    Memory<a class="indexanchor" id="i26_36"/></h2>
        <p class="standard">Like any programming language, JavaScript must store the values of variables somewhere. Strictly speaking, this “somewhere” is an area of the memory. JavaScript is a language that tries to hide a lot of rather machine-based problems from you. Among other things, this includes memory management. For example, JavaScript has a garbage collector that releases memory that has been used but is no longer in use, while you have no way to control this from within your application. Likewise, you don’t have direct access to memory addresses<a class="indexanchor" id="i26_37"/>.</p>
        <p class="standard">On the other hand, you can influence the storage of data and the garbage collector<a class="indexanchor" id="i26_38"/> indirectly. The key to this lies in the scoping of JavaScript, that is, the validity of variables. The language standard generally provides for several areas of validity<a class="indexanchor" id="i26_39"/>:</p>
        <ul>
            <li>
                <p class="standard first-item last-item"><span class="bold">Global</span><a class="indexanchor" id="i26_40"/><br/>A global variable is available everywhere in the application. In Node.js, you use the <samp class="listingcharacter listingcharacter">global</samp> object to access the global namespace.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Function</span><a class="indexanchor" id="i26_41"/><br/>If you define a variable within a function, it’s only valid there and in all subfunctions.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Block</span><a class="indexanchor" id="i26_42"/><br/>The keywords <samp class="listingcharacter listingcharacter">let</samp> and <samp class="listingcharacter listingcharacter">const</samp> allow you to define variables that are valid only in a block such as a loop or a condition.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Closure</span><a class="indexanchor" id="i26_43"/><br/>The closure scope is the scope of a function and its defining context.</p>
            </li>
            <li>
                <p class="standard first-item last-item"><span class="bold">Module</span><a class="indexanchor" id="i26_44"/><br/>The module context is the scope of a file. A variable you define in a file is only valid there.</p>
            </li>
        </ul>
        <p class="standard"><a id="p742"/>If the JavaScript engine leaves a scope, the references to the memory areas of the variables are deleted. The garbage collector can then release the contents of the memory.</p>
        <p class="standard">However, if you intentionally or accidentally make sure that the references continue to exist, the memory can’t be released and remains used. In the course of a longer runtime, the memory consumption of your application grows steadily—a memory leak occurs.</p>
        
            <h3 class="t3" id="h26.3.1">26.3.1    Memory Leaks<a class="indexanchor" id="i26_45"/></h3>
            <p class="standard">There are several ways to create memory leaks. Typically, these are global variables in which structures are stored that are actually no longer needed. The garbage collector can’t take action here because global variables are always valid, so there is always at least one reference. Another source is timers or callbacks that haven’t been deregistered, so the references can’t be released either. The third variant are closure scopes. As you know, the closure scope is the scope of a function and its creating context. This means that as long as the function exists, the memory area surrounding it will continue to exist, even if you can no longer access it directly. You can continue to access it via the function, at least in theory. An example of a typical memory leak triggered by closure scoping is shown in <span class="crossreference "><a href="26_003.html#l26.7">Listing 26.7</a></span>.</p>
            <div class="listing " id="l26.7"><pre><span class="rot">let</span><span class="schwarz"> </span><span class="magenta">value</span><span class="schwarz"> </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">null</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="rot">const</span><span class="schwarz"> callback </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">const</span><span class="schwarz"> originalValue </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="magenta">value</span><span class="schwarz">;</span><span class="schwarz"><br/></span>  <span class="rot">function</span><span class="schwarz"> </span><span class="schwarz">doSomething()</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">originalValue</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="rot">return</span><span class="schwarz"> </span><span class="rot">true</span><span class="schwarz">;</span><span class="schwarz"><br/></span>  <span class="schwarz">}</span><span class="schwarz"><br/></span>  <span class="magenta">value</span><span class="schwarz"> </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    data<span class="schwarz">:</span><span class="schwarz"> </span><span class="rot">new </span><span class="schwarz">Array(1000000).fill(</span><span class="hellblau">'xxx'</span><span class="schwarz">),</span><span class="schwarz"><br/></span>    <span class="schwarz">getSize()</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      <span class="rot">return</span><span class="schwarz"> data</span><span class="schwarz">.</span><span class="schwarz">length</span><span class="schwarz">;</span><span class="schwarz"><br/></span>    <span class="schwarz">},</span><span class="schwarz"><br/></span>  <span class="schwarz">};</span><span class="schwarz"><br/></span><span class="schwarz">};</span><span class="schwarz"><br/></span><span class="schwarz">setInterval(</span><span class="schwarz">callback</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">100);</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 26.7</b>    
            Code Block with a Memory Leak</p>
            <p class="standard">Each time the callback function is executed in the interval, a new <samp class="listingcharacter listingcharacter">value</samp> object gets created. This object contains a <samp class="listingcharacter listingcharacter">data</samp> property with a very large array filled with the character string <samp class="listingcharacter listingcharacter">xxx</samp>. The <samp class="listingcharacter listingcharacter">getSize</samp> method has a closure scope containing the <samp class="listingcharacter listingcharacter">doSomething</samp> function, which in turn has a reference to <samp class="listingcharacter listingcharacter">originalValue</samp>, while <samp class="listingcharacter listingcharacter">originalValue</samp> is the object from the previous interval run. Due to this linking, the memory of all generated objects can’t be released, and the memory is visibly running full.</p>
        
        
            <h3 class="t3" id="h26.3.2">26.3.2    <a id="p743"/>Memory Analysis<a class="indexanchor" id="i26_46"/> in DevTools</h3>
            <p class="standard">As with the processor resource analysis, you can again use Chrome DevTools for your application’s memory consumption. To do this, you must start your application, which you’ve saved in a file named <span class="italic">index.js</span>, via the <samp class="listingcharacter listingcharacter">node --inspect-brk index.js</samp> command. Then you connect your Chrome DevTools to the Node.js process using the <span class="italic">chrome://inspect</span> address.</p>
            <p class="standard">By using the <samp class="listingcharacter listingcharacter">--inspect-brk</samp> option, the application is initially in a halted state. If you continue the execution by clicking the <span class="screenelement">Play</span> icon in the <span class="screenelement">Sources</span> tab, your source code will be executed, and memory consumption will increase. The first indication of this is provided by the <span class="screenelement">Memory</span> tab. Here you can see the current memory consumption<a class="indexanchor" id="i26_47"/> as well as a trend indicator at the very bottom under the <span class="screenelement">Select JavaScript VM instance</span> item. <span class="crossreference "><a href="26_003.html#f26.4">Figure 26.4</a></span> shows the display in DevTools.</p>
            <div class="imagebox figure-type"><a href="img-f26.4.html" id="f26.4"><img alt="Current Memory Consumption and Trend Display" id="img-f26.4" src="bilderklein/klein26_004.png"/></a></div>
            <p class="caption "><b>Figure 26.4</b>    
            Current Memory Consumption and Trend Display</p>
            <p class="standard">Above this memory display, you can analyze the memory further. Several options are available to you. You can take a heap snapshot<a class="indexanchor" id="i26_48"/>, which is a current memory image, or record memory utilization over a period of time. For the second variant, you can choose between <a class="indexanchor" id="i26_49"/><span class="screenelement">Allocation instrumentation on timeline</span> and <span class="screenelement">Allocation sampling</span><a class="indexanchor" id="i26_50"/>, whereby the second variant is more suitable for longer observation periods. To start a recording, select the type of recording using the radio buttons, and then click the <span class="screenelement">Record</span> button at the top left.</p>
            <p class="standard"><span class="crossreference "><a href="26_003.html#f26.5">Figure 26.5</a></span> contains an example of a heap snapshot of our application. In the left-hand column, you can see the name of the <span class="screenelement">Constructor</span>, while the second column shows the <span class="screenelement">Distance</span> to the root, that is, the nesting depth. This is followed by<a class="indexanchor" id="i26_51"/><a class="indexanchor" id="i26_52"/> <span class="screenelement">Shallow Size</span>, which <a id="p744"/>specifies the amount of memory of the respective objects themselves, and then <span class="screenelement">Retained Size</span>, which shows the amount of memory released when the objects are deleted. In the screenshot, you can see that the array we created in the code is responsible for 96% of the memory utilization, which is clearly the memory leak.</p>
            <div class="imagebox figure-type"><a href="img-f26.5.html" id="f26.5"><img alt="Heap Snapshot in DevTools" id="img-f26.5" src="bilderklein/klein26_005.png"/></a></div>
            <p class="caption "><b>Figure 26.5</b>    
            Heap Snapshot in DevTools</p>
            <p class="standard">If you choose the analysis over time instead of a heap snapshot, you start recording, go to the <span class="screenelement">Sources</span> tab, make sure the debugger keeps running, and then you can stop the recording at any time. After that, you should also pause the debugger again, or your system will run out of memory sooner or later. <span class="crossreference "><a href="26_003.html#f26.6">Figure 26.6</a></span> shows the display for the recording in the DevTools. Again, you get the information about the memory consumption of the different objects.</p>
            <p class="standard">This variant of memory analysis is particularly suitable if you suspect a memory leak during certain interactions with your application. In this case, start the recording, perform the action, and then stop the recording. Now you can take a look into the memory at the different times of execution. The third logging variant is somewhat more economical when it comes to the displayed information, but, at the same time, it’s significantly more performant in execution. <span class="crossreference "><a href="26_003.html#f26.7">Figure 26.7</a></span> shows an example of this.</p>
            <p class="standard">Chrome DevTools is an indispensable tool for analyzing memory leaks. Note, however, that our example is a very clear and distinct case of a memory leak. In real life, you’ll rarely be made aware of your problem so clearly, so troubleshooting in such a case may take more time.</p>
            <div class="imagebox figure-type"><a href="img-f26.6.html" id="f26.6"><img alt="Recording Memory Consumption over Time" id="img-f26.6" src="bilderklein/klein26_006.png"/></a></div>
            <p class="caption "><b>Figure 26.6</b>    
            <a id="p745"/>Recording Memory Consumption over Time</p>
            <div class="imagebox figure-type"><a href="img-f26.7.html" id="f26.7"><img alt="Memory Analysis with Allocation Sampling" id="img-f26.7" src="bilderklein/klein26_007.png"/></a></div>
            <p class="caption "><b>Figure 26.7</b>    
            Memory Analysis with Allocation Sampling</p>
            <p class="standard">Another helpful feature of DevTools in dealing with memory usage is the small garbage can icon in the top bar. If you click on it, the garbage collector<a class="indexanchor" id="i26_53"/> becomes active immediately. This allows you to perform a memory analysis and ensure that no memory which is no longer referenced is corrupting the image.</p>
            <p class="standard">However, you don’t always necessarily need DevTools to work with memory. Node.js itself also provides you with a couple of tools.</p>
        
        
            <h3 class="t3" id="h26.3.3">26.3.3    Node.js Memory Statistics<a class="indexanchor" id="i26_54"/></h3>
            <p class="standard">With the help of the <samp class="listingcharacter listingcharacter">process</samp> module, you can obtain rudimentary information about the memory utilization of your application. You can use the <samp class="listingcharacter listingcharacter">process.memoryUsage.rss</samp><a class="indexanchor" id="i26_55"/> method to obtain the <span class="italic"><a id="p746"/>resident set size</span><a class="indexanchor" id="i26_56"/> in bytes. This is the amount of memory consumed by the process with all C++ and JavaScript objects. The <samp class="listingcharacter listingcharacter">process.memoryUsage</samp> method returns an object with the following information:</p>
            <ul>
                <li>
                    <p class="standard first-item last-item"><span class="bold"><samp class="listingcharacter listingcharacter">rss</samp></span><a class="indexanchor" id="i26_57"/><br/>Resident set size that provides the same information as the <samp class="listingcharacter listingcharacter">process.memoryUsage.rss</samp> method.</p>
                </li>
                <li>
                    <p class="standard first-item last-item"><span class="bold"><samp class="listingcharacter listingcharacter">heapTotal</samp></span><a class="indexanchor" id="i26_58"/><br/>Total size of the heap memory of the V8 engine.</p>
                </li>
                <li>
                    <p class="standard first-item last-item"><span class="bold"><samp class="listingcharacter listingcharacter">heapUsed</samp></span><a class="indexanchor" id="i26_59"/><br/>Utilized heap memory of the V8 engine.</p>
                </li>
                <li>
                    <p class="standard first-item last-item"><span class="bold"><samp class="listingcharacter listingcharacter">external</samp></span><a class="indexanchor" id="i26_60"/><br/>Memory consumption by C++ objects bound to JavaScript objects.</p>
                </li>
                <li>
                    <p class="standard first-item last-item"><span class="bold"><samp class="listingcharacter listingcharacter">arrayBuffers</samp></span><a class="indexanchor" id="i26_61"/><br/>Memory consumed by <samp class="listingcharacter listingcharacter">ArrayBuffer</samp> objects.</p>
                </li>
            </ul>
            <p class="standard">You can manipulate the code from <span class="crossreference "><a href="26_003.html#l26.7">Listing 26.7</a></span> to output the memory statistics at certain interval runs, as shown in <span class="crossreference "><a href="26_003.html#l26.8">Listing 26.8</a></span>.</p>
            <div class="listing " id="l26.8"><pre><span class="rot">let</span><span class="schwarz"> </span><span class="magenta">value</span><span class="schwarz"> </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">null</span><span class="schwarz">;</span><span class="schwarz"><br/></span><span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="rot">let</span><span class="schwarz"> count </span><span class="dunkelblau">=</span><span class="schwarz"> 0;</span></samp></span><br/><span class="rot">const</span><span class="schwarz"> callback </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="rot">function</span><span class="schwarz"> () {</span><br/>  <span class="bold"><samp class="listingcharacter listingcharacter"><span class="rot">if</span><span class="schwarz"> (count</span><span class="dunkelblau">++</span><span class="schwarz"> </span><span class="dunkelblau">%</span><span class="schwarz"> 10 </span><span class="dunkelblau">===</span><span class="schwarz"> 0) {</span><br/>    <span class="rot">const</span><span class="schwarz"> { rss, heapTotal, heapUsed } </span><span class="dunkelblau">=</span><span class="schwarz"> process.memoryUsage();</span><br/>    <span class="magenta">console</span><span class="schwarz">.log(</span><br/>      <span class="violett">`RSS: ${rss}, Heap Total: ${heapTotal}, Heap Used: ${heapUsed}`</span><span class="schwarz">,</span><br/>    ); <br/>  }</samp></span><br/>  <span class="rot">const</span><span class="schwarz"> originalValue </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="magenta">value</span><span class="schwarz">;</span><br/>  <span class="rot">function</span><span class="schwarz"> doSomething() {</span><br/>    <span class="rot">if</span><span class="schwarz"> (originalValue) </span><span class="rot">return</span><span class="schwarz"> </span><span class="rot">true</span><span class="schwarz">;</span><br/>  }<br/>  <span class="magenta">value</span><span class="schwarz"> </span><span class="dunkelblau">=</span><span class="schwarz"> {</span><br/>    data: <span class="rot">new </span><span class="schwarz">Array(1000000).fill(</span><span class="hellblau">'xxx'</span><span class="schwarz">),</span><br/>    getSize() {<br/>      <span class="rot">return</span><span class="schwarz"> data.length;</span><br/>    },<br/>  };<br/>};<br/>setInterval(callback, 100); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 26.8</b>    
            Recording Memory Statistics in the Process</p>
            <p class="standard">First, you define a <samp class="listingcharacter listingcharacter">count</samp> variable, which you initialize with the value <samp class="listingcharacter listingcharacter">0</samp>. Then you check whether the <samp class="listingcharacter listingcharacter">count</samp> value that increased by 1 is divisible by 10. If this is the case, you read <a id="p747"/>the values for <samp class="listingcharacter listingcharacter">rss</samp>, <samp class="listingcharacter listingcharacter">heapTotal</samp> and <samp class="listingcharacter listingcharacter">heapUsed</samp> and then output them to the console. You can see an excerpt from the result in <span class="crossreference "><a href="26_003.html#l26.9">Listing 26.9</a></span>.</p>
            <div class="listing " id="l26.9"><pre>RSS: 21983232, Heap Total: 4558848, Heap Used: 3723880<br/>RSS: 104919040, Heap Total: 118198272, Heap Used: 83857760<br/>RSS: 185106432, Heap Total: 198275072, Heap Used: 163860280<br/>RSS: 265211904, Heap Total: 278351872, Heap Used: 243862368<br/>RSS: 345288704, Heap Total: 358428672, Heap Used: 323897032<br/>RSS: 425373696, Heap Total: 438505472, Heap Used: 403866632<br/>RSS: 505458688, Heap Total: 518582272, Heap Used: 483868872<br/>RSS: 585887744, Heap Total: 598134784, Heap Used: 563492760 </pre></div>
            <p class="caption "><b>Listing 26.9</b>    
            Output of the Memory Values</p>
            <p class="standard">As you can see in the output on the command line, all metrics, that is, <samp class="listingcharacter listingcharacter">RSS</samp>, <samp class="listingcharacter listingcharacter">Heap Total</samp>, and <samp class="listingcharacter listingcharacter">Heap Used</samp>, are steadily increasing. If such a case occurs in a real application, the system on which you run the application will continuously slow down as memory management becomes more and more extensive. The system will eventually start swapping content from the memory to the disk until the available memory is used up, and the system runs into a state of emergency.</p>
            <p class="standard">In addition to the processor and RAM, the network is another important resource, especially for web applications based on Node.js.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>