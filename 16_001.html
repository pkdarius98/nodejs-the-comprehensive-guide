<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Asynchronous Programming" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Asynchronous Programming" name="description"/>
            <meta content="en" name="language"/>
            <title>Asynchronous Programming</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main"><h1 class="t1" id="h16">16    <a id="p481"/>Asynchronous Programming</h1><p class="introductorynote indent_chapter_double">My advice is you should be able to do more than you do, than to do more than you can.<br/>—Bertold Brecht</p><p class="standard">The<a class="indexanchor" id="i16_00"/> architecture of Node.js expects an application to be run in one process and one thread. The advantage of this is that you don’t need to worry about concurrency and the resource access problems it creates. To avoid performance issues caused by this architecture, most of the platform’s features are implemented in such a way that much of the work can be outsourced, allowing Node.js to remain responsive. The key to this is the asynchronous processing of tasks. So far, you’ve already learned about some of the features of JavaScript and Node.js that can help you deal with asynchronicity. In this chapter, you’ll get to know the asynchronous concepts in greater detail. We’ll also take a look at advanced concepts that allow you to distribute your Node.js application across multiple processes or threads, making better use of local resources.</p>
        <h2 class="t2" id="h16.1">16.1    Basic Principles of Asynchronous Programming</h2>
        <p class="standard">Most features of Node.js are based on <span class="italic">asynchronicity</span>. You can see this by working with either promises or callback functions. For you as a developer, asynchronicity means that you have to wait until the result of an operation is available. This makes program control more difficult at first because you can’t work with direct return values as usual. If Node.js allowed you to perform operations synchronously despite its single-threaded approach<a class="indexanchor" id="i16_01"/>, and if such an operation took longer, the platform wouldn’t be able to perform other tasks simultaneously during that time. This becomes obvious when you look at the source code shown in <span class="crossreference "><a href="16_001.html#l16.1">Listing 16.1</a></span>.</p>
        <div class="listing " id="l16.1"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> readFileSync </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'fs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Operation 1'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="rot">const</span><span class="schwarz"> content </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">readFileSync(</span><span class="hellblau">'input.txt'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'utf-8'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Content: '</span><span class="schwarz">,</span><span class="schwarz"> content</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Operation 2'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Operation 3'</span><span class="schwarz">);</span><span class="schwarz"> </span></pre></div>
        <p class="caption "><b>Listing 16.1</b>    
            Sequential Program Flow</p>
        <p class="standard"><a id="p482"/>In the source code, you first run the first <samp class="listingcharacter listingcharacter">console.log</samp> statement. After that, you read the contents of the <span class="italic">input.txt</span> file synchronously. This means you’re waiting for the return<a class="indexanchor" id="i16_02"/> of the operation. In the meantime, all other operations have to wait, so the subsequent <samp class="listingcharacter listingcharacter">console.log</samp> statements, which are independent of the file contents, can’t be run either. <span class="crossreference "><a href="16_001.html#f16.1">Figure 16.1</a></span> clarifies this process.</p>
        <div class="imagebox figure-type"><a href="img-f16.1.html" id="f16.1"><img alt="Synchronous Program Flow" id="img-f16.1" src="bilderklein/klein16_001.png"/></a></div>
        <p class="caption "><b>Figure 16.1</b>    
            Synchronous Program Flow</p>
        <p class="standard">When you save the source code from <span class="crossreference "><a href="16_001.html#l16.1">Listing 16.1</a></span> in a file named <span class="italic">index.js</span>, create another <span class="italic">input.txt</span> file that contains the line <samp class="listingcharacter listingcharacter">Hello Node.js</samp>, and then run the source code via the <samp class="listingcharacter listingcharacter">node index.js</samp> command, you’ll get output as shown in <span class="crossreference "><a href="16_001.html#l16.2">Listing 16.2</a></span>.</p>
        <div class="listing " id="l16.2"><pre>$ <span class="bold"><samp class="listingcharacter listingcharacter">node index.js</samp></span><br/>Operation 1<br/>Content:  Hello Node.js<br/>Operation 2<br/>Operation 3 </pre></div>
        <p class="caption "><b>Listing 16.2</b>    
            Output of the Synchronous Program</p>
        <p class="standard">Now, you need to remove potentially blocking operations<a class="indexanchor" id="i16_03"/> such as file reading from the application process. The Node.js platform provides you with several options to do that by means of modules as they help you swap out certain routines. What sounds like an abstract concept in theory is used in many modules of Node.js. Specifically, you can find asynchronous operations in the <samp class="listingcharacter listingcharacter">fs</samp> module, for example. <span class="crossreference "><a href="16_001.html#l16.3">Listing 16.3</a></span> shows how asynchronous file reading works.</p>
        <div class="listing " id="l16.3"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> readFile </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'fs'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Operation 1'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz"><a id="p483"/>readFile(</span><span class="hellblau">'input.txt'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="hellblau">'utf-8'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">err</span><span class="schwarz">,</span><span class="schwarz"> content</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Content: '</span><span class="schwarz">,</span><span class="schwarz"> content</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"><br/></span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Operation 2'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'Operation 3'</span><span class="schwarz">);</span><span class="schwarz"> </span></pre></div>
        <p class="caption "><b>Listing 16.3</b>    
            Asynchronous Reading of Files</p>
        <p class="standard">In contrast to synchronous execution, here the file is read asynchronous, meaning that the two subsequent <samp class="listingcharacter listingcharacter">console.log</samp> statements are run immediately and don’t wait until the file has been read entirely. Once the contents of the file are available, the <samp class="listingcharacter listingcharacter">console.log</samp> statement from the callback function<a class="indexanchor" id="i16_04"/> gets executed. This results in a slightly different program flow, as you can see in <span class="crossreference "><a href="16_001.html#f16.2">Figure 16.2</a></span>.</p>
        <div class="imagebox figure-type"><a href="img-f16.2.html" id="f16.2"><img alt="Asynchronous Program Flow" id="img-f16.2" src="bilderklein/klein16_002.png"/></a></div>
        <p class="caption "><b>Figure 16.2</b>    
            Asynchronous Program Flow</p>
        <p class="standard">When reading a single small text file, this type of operation isn’t yet a problem. However, if a large number of small files or a few large files are to be processed, these operations may take a long time in total. If you process this information away from users or other systems, that is, in an environment that is not time critical, you can also execute the files directly in the main thread of your application. However, if users come into <a id="p484"/>play who are working with your application at the same time, the parallel requests cause delays because the requests can only be processed sequentially<a class="indexanchor" id="i16_05"/>.</p>
        <p class="standard">The asynchronous processing<a class="indexanchor" id="i16_06"/> of tasks, such as reading a file, is based on the event-driven infrastructure<a class="indexanchor" id="i16_07"/> of Node.js. Internally, the request is passed to the operating system, and the callback function is registered to handle the response. The operating system takes care of processing the task from this point on. For the logic of your application, this means that the subsequent command is executed after calling the <samp class="listingcharacter listingcharacter">readFile</samp> method, so the processing of the application isn’t blocked by the read operation. Finally, when the read operation has been completed, the result is returned to Node.js. The Node.js platform then takes care of calling the previously registered callback function. For the callback function to be executed, the processing of the application must be briefly halted.</p>
        <p class="standard">If you rebuild the previous <span class="italic">index.js</span> file from <span class="crossreference "><a href="16_001.html#l16.1">Listing 16.1</a></span> to match the code state from <span class="crossreference "><a href="16_001.html#l16.3">Listing 16.3</a></span> and then run the application via the <samp class="listingcharacter listingcharacter">node index.js</samp> command, you get the output shown in <span class="crossreference "><a href="16_001.html#l16.4">Listing 16.4</a></span>.</p>
        <div class="listing " id="l16.4"><pre>$ <span class="bold"><samp class="listingcharacter listingcharacter">node index.js</samp></span><br/>Operation 1<br/>Operation 2<br/>Operation 3<br/>Content:  Hello Node.js </pre></div>
        <p class="caption "><b>Listing 16.4</b>    
            Output of the Asynchronous Program Flow</p>
        <p class="standard">A characteristic of asynchronous processing is the registration of callback functions<a class="indexanchor" id="i16_08"/>. The difference here becomes especially clear when you look at the methods in the <samp class="listingcharacter listingcharacter">fs</samp> module. Here, a synchronous counterpart exists for almost every asynchronous method. Thus, the <samp class="listingcharacter listingcharacter">readFile</samp> method is also available in its synchronous form as <samp class="listingcharacter listingcharacter">readFileSync</samp>. Both methods differ only in the number of their parameters and in their return value<a class="indexanchor" id="i16_09"/>. The synchronous version of the method has one parameter less. You don’t need a callback function in this case because the method returns the results directly. The asynchronous <samp class="listingcharacter listingcharacter">readFile</samp> method returns <samp class="listingcharacter listingcharacter">undefined</samp> as a value. The processing of the returned content, once the results are available, takes place within the callback function.</p>
        <p class="standard">If an error occurs during the execution of the operation—for example, the file that <samp class="listingcharacter listingcharacter">readFile</samp> is supposed to read doesn’t exist—you’ll receive an object containing the corresponding error message as the first argument of the callback function. If you ignore this object, your application will continue to run nevertheless. The case is different with the synchronous version of the method. Only one return value is available here, so the error message can’t be encapsulated in a separate object in addition to the returned data. If the file to be read with <samp class="listingcharacter listingcharacter">readFileSync</samp> can’t be found, the method returns an exception, which you must handle with a <samp class="listingcharacter listingcharacter">try-catch</samp><a class="indexanchor" id="i16_10"/> block, or the execution of your entire application will be interrupted.</p>
        <p class="standard"><a id="p485"/>The <samp class="listingcharacter listingcharacter">child_process</samp> module allows you to create asynchronous operations for your own application, to which you can swap out calculations.</p>
        
            <h3 class="t3" id="h16.1.1">16.1.1    The child_process<a class="indexanchor" id="i16_11"/> Module</h3>
            <p class="standard">The <samp class="listingcharacter listingcharacter">child_process</samp> module combines a set of methods for asynchronous programming of applications for you. At this point, we’ll primarily focus on the basic structure of the module and the <samp class="listingcharacter listingcharacter">ChildProcess</samp> class it contains.</p>
            <div class="box box_standard">
                <h6 class="boxheading">Child Processes<a class="indexanchor" id="i16_12"/> in Node.js</h6>
                <p class="standard first last">A child process is an independent process coupled with the parent process that created it. Using the <samp class="listingcharacter listingcharacter">child_process</samp> module, you can fork any number of child processes. However, you should keep in mind that each of these processes consumes system resources<a class="indexanchor" id="i16_13"/> such as memory and CPU time. If you have more child processes than CPU cores, the child processes compete for the CPU and slow each other down. Parent and child processes can communicate directly with each other via messages. For larger amounts of data, you can also use sockets for communication.</p>
            </div>
            <p class="standard">Like the parent process<a class="indexanchor" id="i16_14"/>, which is your actual application, each child process<a class="indexanchor" id="i16_15"/> has three streams: a standard input<a class="indexanchor" id="i16_16"/>, a standard output<a class="indexanchor" id="i16_17"/>, and the standard error output<a class="indexanchor" id="i16_18"/>. The child process can share all three streams with the parent process. However, you can also create stream objects and assign them to the child process. The three properties <samp class="listingcharacter listingcharacter">stdin</samp>, <samp class="listingcharacter listingcharacter">stdout</samp>, and <samp class="listingcharacter listingcharacter">stderr</samp> are available for this purpose. You get the object representing the child process as the return value of the <samp class="listingcharacter listingcharacter">spawn</samp>, <samp class="listingcharacter listingcharacter">exec</samp>, and <samp class="listingcharacter listingcharacter">fork</samp> methods. These methods can be used to start a child process. In the following sections, you’ll learn more about each method, its field of application, and the differences. Here it’s only worth mentioning that they return the representation of the child process, which you can use within your application to interact with the child process.</p>
            <p class="standard">Using the <samp class="listingcharacter listingcharacter">kill</samp> method<a class="indexanchor" id="i16_19"/>, you can send a signal from the parent process to the child process. The name of this method is somewhat misleading because you don’t need to terminate the process. You can rather use the method to send signals to enable inter-process communication. For example, you can use <samp class="listingcharacter listingcharacter">SIGKILL</samp><a class="indexanchor" id="i16_20"/> or <samp class="listingcharacter listingcharacter">SIGTERM</samp><a class="indexanchor" id="i16_21"/> to terminate the process. If you don’t provide a value when calling the method, <samp class="listingcharacter listingcharacter">SIGTERM</samp> is used by default, which gives the process an opportunity to perform various cleanup tasks before termination. In Node.js, this type of inter-process communication is solved using an event architecture. If you call the <samp class="listingcharacter listingcharacter">kill</samp> method on the child process, an <samp class="listingcharacter listingcharacter">exit</samp> event<a class="indexanchor" id="i16_22"/> is generated to which you can register a callback function. The first argument of this callback function is the return value of the child process if it terminated normally. If the process was terminated by a signal, this argument has the value <samp class="listingcharacter listingcharacter">null</samp>. The second argument is the signal that was sent to the child process, for example, the string <samp class="listingcharacter listingcharacter">SIGTERM</samp>.</p>
            <p class="standard"><a id="p486"/>The second method—<samp class="listingcharacter listingcharacter">disconnect</samp><a class="indexanchor" id="i16_23"/>—is used to terminate the communication link between the parent and child processes. In concrete terms, this means you can no longer exchange messages between the parent and child processes. Calling this method triggers the <samp class="listingcharacter listingcharacter">disconnect</samp> event in the child process, which you can in turn bind to with a callback function to respond accordingly. Besides triggering the event, the <samp class="listingcharacter listingcharacter">connected</samp> property is also set from the value <samp class="listingcharacter listingcharacter">true</samp> to <samp class="listingcharacter listingcharacter">false</samp>.</p>
            <p class="standard">In addition to the events already presented, the <samp class="listingcharacter listingcharacter">close</samp> event is special in that it gets triggered as soon as the stream object<a class="indexanchor" id="i16_24"/> representing the standard input of the child process is terminated by the <samp class="listingcharacter listingcharacter">end</samp> method. Again, you can bind a callback function to this event.</p>
            <p class="standard">The other methods of communication between the parent and child process will be introduced in the context of the <samp class="listingcharacter listingcharacter">fork</samp> method based on a concrete example.</p>
            <div class="box box_standard">
                <h6 class="boxheading">Processes and Threads<a class="indexanchor" id="i16_25"/></h6>
                <p class="standard first">A <span class="italic">process</span><a class="indexanchor" id="i16_26"/> is the representation of a program in an operating system. A process occupies an area of memory that usually is exclusively available to it. In addition, a process receives computing time from the processor to perform calculations. For more information on processes, see <span class="url"><a href="https://en.wikipedia.org/wiki/Process_(computing)">https://en.wikipedia.org/wiki/Process_(computing)</a></span>.</p>
                <p class="standard">A <span class="italic">thread</span><a class="indexanchor" id="i16_27"/>, on the other hand, is a part of a process and denotes a thread of execution within a program. In concrete terms, this means a process can consist of several threads. A thread has access to the resources of the process to which it’s assigned. Each thread of a process has its own stack<a class="indexanchor" id="i16_28"/>. A stack is a memory in which the thread can store elements and from which it can read them again. This stack is exclusive to one thread. The other threads of the process can’t access it. For more information on threads, see <span class="url"><a href="https://en.wikipedia.org/wiki/Thread_(computing)">https://en.wikipedia.org/wiki/Thread_(computing)</a></span>.</p>
                <p class="standard">When you run Node.js, a process gets started. Within this process, a single thread is executed because the Node.js platform is based on a single-threaded approach.</p>
                <p class="standard last">Node.js supports both multiple processes and multiple threads within an application. Both variants are represented by different modules—the <samp class="listingcharacter listingcharacter">child_process</samp> and the <samp class="listingcharacter listingcharacter">worker_threads</samp> modules.</p>
            </div>
        
    </div><p class="signatur"/>
                    </body>
                </html>