<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="Socket Server" name="title"/>
            <meta content="Sebastian Springer" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2022 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Node.js - The Comprehensive Guide - Socket Server" name="description"/>
            <meta content="en" name="language"/>
            <title>Socket Server</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000029756394" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_kapitel">
                        <div id="main">
        <h2 class="t2" id="h20.4">20.4    UDP Sockets<a class="indexanchor" id="i20_54"/></h2>
        <p class="standard">UDP works on the same level as TCP. However, in contrast to TCP, UDP has fundamentally different characteristics. With UDP, no connection gets established, which means there is no need for a handshake for any connection setup, making UDP much more lightweight than TCP. UDP isn’t suitable for transferring larger amounts of data due to the lack of a connection between the two endpoints of the communication, as the protocol doesn’t have the security mechanisms of TCP, so there’s no guarantee that information won’t get lost.</p>
        <p class="standard">As with TCP, the size of packages is also limited with UDP, so that, for example, a file to be transferred may have to be divided into several small parts. With TCP, the sequence number ensures that the packages can be assembled in the correct order on the side of the recipient. Such a feature doesn’t exist with UDP, so when you send data via UDP, you can’t assume that your packages will actually arrive. When the information reaches the recipient, it’s also impossible to guarantee whether this happens in the correct order.</p>
        <p class="standard">In summary, UDP is referred to as an unreliable and connectionless protocol. However, what doesn’t look very trustworthy at first glance serves a significant purpose in data transmission in information technology: UDP is always used when data must be transmitted quickly, and it doesn’t matter if individual packages don’t reach the recipient. Furthermore, when using UDP, the order of the packages doesn’t matter either.</p>
        <p class="standard">A classic area of use for this protocol is the Network Time Protocol (NTP), which is used by computers on the Internet to synchronize their clocks. The Domain Name System (DNS)<a class="indexanchor" id="i20_55"/>, which is used to resolve names on the network, also uses a UDP connection between client and server for sending requests. These two services are only a small part of all the usage areas for UDP in network communication. Because UDP is such an important protocol, Node.js also supports implementing servers and clients for UDP. The <samp class="listingcharacter listingcharacter">dgram</samp> module<a class="indexanchor" id="i20_56"/> is available for this purpose. The term <span class="italic">datagram</span><a class="indexanchor" id="i20_57"/> refers to a unit in the transmission of data through the network. The interfaces of the <samp class="listingcharacter listingcharacter">dgram</samp> module of Node.js are somewhat different from those of the modules you’ve encountered so far for communication between systems. In the following sections, you’ll learn how to complete a very simple client-server implementation for communication via UDP, which you’ll then extend step by step.</p>
        
            <h3 class="t3" id="h20.4.1">20.4.1    <a id="p611"/>Basic Principles of a UDP Server<a class="indexanchor" id="i20_58"/></h3>
            <p class="standard">UDP works similarly to TCP when it comes to addressing. You create a server and bind it to a specific address or port. Clients can then connect and communicate with the server using this combination. <span class="crossreference "><a href="20_004.html#l20.15">Listing 20.15</a></span> shows the implementation of a UDP server.</p>
            <div class="listing " id="l20.15"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createSocket </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'dgram'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> socket </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createSocket(</span><span class="hellblau">'udp6'</span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/>socket<span class="schwarz">.on(</span><span class="hellblau">'message'</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">data</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="schwarz">data</span><span class="schwarz">.toString());</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"><br/></span> <br/>socket<span class="schwarz">.bind(8080,</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'server listening on localhost:8080'</span><span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.15</b>    
            UDP Server (server.js)</p>
            <p class="standard">After importing the <samp class="listingcharacter listingcharacter">createSocket</samp> function from the <samp class="listingcharacter listingcharacter">dgram</samp> module, you can use it to create a UDP socket. You assign the type of socket to this function. The choice here is either <samp class="listingcharacter listingcharacter">udp4</samp> or <samp class="listingcharacter listingcharacter">udp6</samp>. This type specifies whether to use UDP with IPv4 or IPv6<a class="indexanchor" id="i20_59"/>. After calling this method, you have an unbound socket to continue working with. Like the other sockets, UDP sockets are event-based, so you can also bind callback functions to specific events here using the <samp class="listingcharacter listingcharacter">on</samp> method of the socket object. The example in <span class="crossreference "><a href="20_004.html#l20.15">Listing 20.15</a></span> shows two of these events. First, you bind a callback function to the <samp class="listingcharacter listingcharacter">message</samp> event, which gets triggered when data is sent through the socket. Here you can access a <samp class="listingcharacter listingcharacter">buffer</samp> object<a class="indexanchor" id="i20_60"/> containing the corresponding data. In addition, the <samp class="listingcharacter listingcharacter">bind</samp> method accepts a callback function that’s registered for the <samp class="listingcharacter listingcharacter">listening</samp> event. This event gets triggered as soon as the socket is successfully bound to an address and port, thus allowing incoming connections. The functionality of this server is to output incoming data to the console. You’ll also be notified by a message when the connection is established and waiting for incoming datagrams. To test the functionality of your server, you should implement a UDP client<a class="indexanchor" id="i20_61"/> in the next step. <span class="crossreference "><a href="20_004.html#l20.16">Listing 20.16</a></span> shows how to proceed in this context.</p>
            <div class="listing " id="l20.16"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createSocket </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'dgram'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> message </span><span class="dunkelblau">=</span><span class="schwarz"> Buffer</span><span class="schwarz">.from(</span><span class="hellblau">'Hello Server'</span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> client </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createSocket(</span><span class="hellblau">'udp6'</span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/>client<span class="schwarz">.send(</span><span class="schwarz"><br/></span>  message<span class="schwarz">,</span><span class="schwarz"> </span><br/>  <span class="schwarz">0,</span><span class="schwarz"> </span><br/><a id="p612"/>  message<span class="schwarz">.</span><span class="schwarz">length</span><span class="schwarz">,</span><span class="schwarz"> </span><br/>  <span class="schwarz">8080,</span><span class="schwarz"> </span><br/>  <span class="schwarz">(</span><span class="schwarz">err</span><span class="schwarz">,</span><span class="schwarz"> bytes</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>    client<span class="schwarz">.close();</span><span class="schwarz"><br/></span>  <span class="schwarz">});</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.16</b>    
            UDP Client (client.js)</p>
            <p class="standard">The client-side implementation of a UDP socket is much simpler. You generate an unbound socket just as you did on the server side. However, instead of binding it to an address and port, you call the <samp class="listingcharacter listingcharacter">send</samp> method on the object. To this method, you pass a <samp class="listingcharacter listingcharacter">buffer</samp> object that contains the data to be sent. Then you must specify the offset and the length of the data within the buffer that should be sent. Finally, you need to specify which port<a class="indexanchor" id="i20_62"/> you want to send the data to. The callback function is executed as soon as the message has been sent. Inside the callback function, you have access to a possible error object and the number of bytes that were sent. At the end of the function, you should close the socket again via the <samp class="listingcharacter listingcharacter">close</samp> method because an open socket prevents the program from terminating.</p>
        
        
            <h3 class="t3" id="h20.4.2">20.4.2    Example Illustrating the UDP Server</h3>
            <p class="standard">In practice, UDP is particularly suitable for notifying clients of noncritical events or when receiving mass data. In the second case, however, you must make sure that there is so much data that the result isn’t affected by the loss of individual packages. In this section, you’ll extend the example from <span class="crossreference "><a href="20_004.html#l20.15">Listing 20.15</a></span> and <span class="crossreference "><a href="20_004.html#l20.16">Listing 20.16</a></span> by not only exchanging a string between client and server but also sending a continuous stream of data and subscribing to it. <span class="crossreference "><a href="20_004.html#l20.17">Listing 20.17</a></span> shows the modified source code of the server.</p>
            <div class="listing " id="l20.17"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createSocket </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'dgram'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> socket </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createSocket(</span><span class="hellblau">'udp6'</span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/><span class="bold"><span class="schwarz"/><samp class="listingcharacter listingcharacter"><span class="rot">let</span><span class="schwarz"> count </span><span class="dunkelblau">=</span><span class="schwarz"> 0;</span><br/> </samp></span><br/>socket.on(<span class="hellblau">'message'</span><span class="schwarz">, (data) </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="bold"><samp class="listingcharacter listingcharacter"><span class="magenta">console</span><span class="schwarz">.log(</span><span class="violett">`${count++}: ${data.toString()}`</span><span class="schwarz">);</span><br/> <br/>  <span class="rot">if</span><span class="schwarz"> (count </span><span class="dunkelblau">&gt;=</span><span class="schwarz"> 1000) {</span><br/>    socket.close();<br/>  }</samp></span><br/>});<br/> <br/><span class="bold"><samp class="listingcharacter listingcharacter">socket.on(<span class="hellblau">'close'</span><span class="schwarz">, () </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="violett">`received ${count} datagrams`</span><span class="schwarz">);</span><br/><a id="p613"/>});<br/> </samp></span><br/>socket.bind(8080, () <span class="dunkelblau">=&gt;</span><span class="schwarz"> {</span><br/>  <span class="magenta">console</span><span class="schwarz">.log(</span><span class="hellblau">'server listening on localhost:8080'</span><span class="schwarz">);</span><br/>}); <span class="schwarz"/></pre></div>
            <p class="caption "><b>Listing 20.17</b>    
            UDP Server for Receiving Multiple Datagrams (server.js)</p>
            <p class="standard">Due to the modifications, the server is designed to receive a total of 1,000 datagrams through the connection. After that, the connection is disconnected, and the number of received datagrams is output. For this purpose, you bind a callback function to the <samp class="listingcharacter listingcharacter">close</samp> event<a class="indexanchor" id="i20_63"/>. This event gets triggered as soon as the <samp class="listingcharacter listingcharacter">close</samp> method is called on the socket.</p>
            <p class="standard">Because there is no connection between client and server, you have no way to respond directly to the client here, so the server must decide for itself when to disconnect. <span class="crossreference "><a href="20_004.html#l20.18">Listing 20.18</a></span> contains the source code of the client.</p>
            <div class="listing " id="l20.18"><pre><span class="rot">import</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"> createSocket </span><span class="schwarz">}</span><span class="schwarz"> </span><span class="rot">from</span><span class="schwarz"> </span><span class="hellblau">'dgram'</span><span class="schwarz">;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> client </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">createSocket(</span><span class="hellblau">'udp6'</span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/><span class="rot">let</span><span class="schwarz"> count </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">1;</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> sendData </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">()</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>  <span class="rot">const</span><span class="schwarz"> message </span><span class="dunkelblau">=</span><span class="schwarz"> Buffer</span><span class="schwarz">.from(</span><span class="schwarz">Math</span><span class="schwarz">.ceil(</span><span class="schwarz">Math</span><span class="schwarz">.random()</span><span class="schwarz"> </span><span class="dunkelblau">*</span><span class="schwarz"> </span><span class="schwarz">100)</span><span class="schwarz"> </span><span class="dunkelblau">+</span><span class="schwarz"> </span><span class="hellblau">''</span><span class="schwarz">);</span><span class="schwarz"><br/></span> <br/>  client<span class="schwarz">.send(</span><span class="schwarz"><br/></span>    message<span class="schwarz">,</span><span class="schwarz"> </span><br/>    <span class="schwarz">0,</span><span class="schwarz"> </span><br/>    message<span class="schwarz">.</span><span class="schwarz">length</span><span class="schwarz">,</span><span class="schwarz"> </span><br/>    <span class="schwarz">8080,</span><span class="schwarz"> </span><br/>    <span class="schwarz">(</span><span class="schwarz">err</span><span class="schwarz">,</span><span class="schwarz"> bytes</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="dunkelblau">=&gt;</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>      count <span class="dunkelblau">+=</span><span class="schwarz"> </span><span class="schwarz">1;</span><span class="schwarz"><br/></span> <br/>      <span class="rot">if</span><span class="schwarz"> </span><span class="schwarz">(</span><span class="schwarz">count </span><span class="dunkelblau">&gt;</span><span class="schwarz"> </span><span class="schwarz">1000</span><span class="schwarz"> </span><span class="dunkelblau">||</span><span class="schwarz"> err</span><span class="schwarz">)</span><span class="schwarz"> </span><span class="schwarz">{</span><span class="schwarz"><br/></span>        client<span class="schwarz">.close();</span><span class="schwarz"><br/></span>        <span class="schwarz">clearInterval(</span><span class="schwarz">interval</span><span class="schwarz">);</span><span class="schwarz"><br/></span>      <span class="schwarz">}</span><span class="schwarz"><br/></span>    <span class="schwarz">}</span><span class="schwarz"><br/></span>  <span class="schwarz">);</span><span class="schwarz"><br/></span><span class="schwarz">};</span><span class="schwarz"><br/></span> <br/><span class="rot">const</span><span class="schwarz"> interval </span><span class="dunkelblau">=</span><span class="schwarz"> </span><span class="schwarz">setInterval(</span><span class="schwarz">sendData</span><span class="schwarz">,</span><span class="schwarz"> </span><span class="schwarz">1);</span><span class="schwarz"> </span></pre></div>
            <p class="caption "><b>Listing 20.18</b>    
            UDP Client for Sending Multiple Datagrams</p>
            <p class="standard"><a id="p614"/>As an example of a data source for the UDP client, random numbers are generated in <span class="crossreference "><a href="20_004.html#l20.18">Listing 20.18</a></span> at intervals of 1 millisecond and then sent to the server. As soon as an error occurs or 1,000 packages have been sent, the connection is terminated, and the interval<a class="indexanchor" id="i20_64"/> gets closed. If you start the server first and then the client, you can see how the 1,000 datagrams are transferred. Despite the high frequency, all data arrives error-free and without any problem. Even if you increase the number of datagrams, the behavior won’t change. When using UDP, you have to consider one more aspect: Like TCP packages, UDP datagrams are subject to a size limit<a class="indexanchor" id="i20_65"/> that may vary depending on the connection. If the size of the datagram exceeds the allowed size on the side of the recipient, the datagram gets discarded. However, the recipient won’t receive any error message in this context.</p>
            <p class="standard">Due to its properties, UDP is therefore only suitable for transmitting noncritical data. If your application requires all data to reach the recipient reliably, you should use TCP.</p>
        
    </div><p class="signatur"/>
                    </body>
                </html>